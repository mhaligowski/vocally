/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/p5/lib/addons/p5.sound.js":
/*!************************************************!*\
  !*** ./node_modules/p5/lib/addons/p5.sound.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** [p5.sound]  Version: 0.3.12 - 2020-01-06 */ 
 /**
 *  <p>p5.sound extends p5 with <a href="http://caniuse.com/audio-api"
 *  target="_blank">Web Audio</a> functionality including audio input,
 *  playback, analysis and synthesis.
 *  </p>
 *  <ul>
 *  <li><a href="#/p5.SoundFile"><b>p5.SoundFile</b></a>: Load and play sound files.</li>
 *  <li><a href="#/p5.Amplitude"><b>p5.Amplitude</b></a>: Get the current volume of a sound.</li>
 *  <li><a href="#/p5.AudioIn"><b>p5.AudioIn</b></a>: Get sound from an input source, typically
 *    a computer microphone.</li>
 *  <li><a href="#/p5.FFT"><b>p5.FFT</b></a>: Analyze the frequency of sound. Returns
 *    results from the frequency spectrum or time domain (waveform).</li>
 *  <li><a href="#/p5.Oscillator"><b>p5.Oscillator</b></a>: Generate Sine,
 *    Triangle, Square and Sawtooth waveforms. Base class of
 *    <li><a href="#/p5.Noise">p5.Noise</a> and <a href="#/p5.Pulse">p5.Pulse</a>.
 *    </li>
 *  <li>
 *    <a href="#/p5.MonoSynth">p5.MonoSynth</a> and <a href="#/p5.PolySynth">p5.PolySynth</a>: Play musical notes
 *  </li>
 *  <li><a href="#/p5.Envelope"><b>p5.Envelope</b></a>: An Envelope is a series
 *    of fades over time. Often used to control an object's
 *    output gain level as an "ADSR Envelope" (Attack, Decay,
 *    Sustain, Release). Can also modulate other parameters.</li>
 *  <li><a href="#/p5.Delay"><b>p5.Delay</b></a>: A delay effect with
 *    parameters for feedback, delayTime, and lowpass filter.</li>
 *  <li><a href="#/p5.Filter"><b>p5.Filter</b></a>: Filter the frequency range of a
 *    sound.
 *  </li>
 *  <li><a href="#/p5.Reverb"><b>p5.Reverb</b></a>: Add reverb to a sound by specifying
 *    duration and decay. </li>
 *  <b><li><a href="#/p5.Convolver">p5.Convolver</a>:</b> Extends
 *  <a href="#/p5.Reverb">p5.Reverb</a> to simulate the sound of real
 *    physical spaces through convolution.</li>
 *  <b><li><a href="#/p5.SoundRecorder">p5.SoundRecorder</a></b>: Record sound for playback
 *    / save the .wav file.
 *  <b><li><a href="#/p5.SoundLoop">p5.SoundLoop</a>, <a href="#/p5.Phrase">p5.Phrase</a></b>, <b><a href="#/p5.Part">p5.Part</a></b> and
 *  <b><a href="#/p5.Score">p5.Score</a></b>: Compose musical sequences.
 *  </li>
 *  <li><a href="#/p5/userStartAudio">userStartAudio</a>: Enable audio in a
 *  browser- and user-friendly way.</a>
 *  <p>p5.sound is on <a href="https://github.com/therewasaguy/p5.sound/">GitHub</a>.
 *  Download the latest version
 *  <a href="https://github.com/therewasaguy/p5.sound/blob/master/lib/p5.sound.js">here</a>.</p>
 *
 *  @module p5.sound
 *  @submodule p5.sound
 *  @for p5.sound
 *  @main
 */

/**
 *  p5.sound 
 *  https://p5js.org/reference/#/libraries/p5.sound
 *
 *  From the Processing Foundation and contributors
 *  https://github.com/processing/p5.js-sound/graphs/contributors
 *
 *  MIT License (MIT)
 *  https://github.com/processing/p5.js-sound/blob/master/LICENSE
 *
 *  Some of the many audio libraries & resources that inspire p5.sound:
 *   - TONE.js (c) Yotam Mann. Licensed under The MIT License (MIT). https://github.com/TONEnoTONE/Tone.js
 *   - buzz.js (c) Jay Salvat. Licensed under The MIT License (MIT). http://buzz.jaysalvat.com/
 *   - Boris Smus Web Audio API book, 2013. Licensed under the Apache License http://www.apache.org/licenses/LICENSE-2.0
 *   - wavesurfer.js https://github.com/katspaugh/wavesurfer.js
 *   - Web Audio Components by Jordan Santell https://github.com/web-audio-components
 *   - Wilm Thoben's Sound library for Processing https://github.com/processing/processing/tree/master/java/libraries/sound
 *
 *   Web Audio API: http://w3.org/TR/webaudio/
 */

 (function(modules) { 
 	var installedModules = {};
 	function __webpack_require__(moduleId) {
 		if(installedModules[moduleId]) {
 			return installedModules[moduleId].exports;
 		}
 		var module = installedModules[moduleId] = {
 			i: moduleId,
 			l: false,
 			exports: {}
 		};
 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
 		module.l = true;
 		return module.exports;
 	}
 	__webpack_require__.m = modules;
 	__webpack_require__.c = installedModules;
 	__webpack_require__.d = function(exports, name, getter) {
 		if(!__webpack_require__.o(exports, name)) {
 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
 		}
 	};
 	__webpack_require__.r = function(exports) {
 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
 		}
 		Object.defineProperty(exports, '__esModule', { value: true });
 	};
 	__webpack_require__.t = function(value, mode) {
 		if(mode & 1) value = __webpack_require__(value);
 		if(mode & 8) return value;
 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
 		var ns = Object.create(null);
 		__webpack_require__.r(ns);
 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
 		return ns;
 	};
 	__webpack_require__.n = function(module) {
 		var getter = module && module.__esModule ?
 			function getDefault() { return module['default']; } :
 			function getModuleExports() { return module; };
 		__webpack_require__.d(getter, 'a', getter);
 		return getter;
 	};
 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
 	__webpack_require__.p = "";
 	return __webpack_require__(__webpack_require__.s = 31);
 })
 ([
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){"use strict";function a(t,e){this.isUndef(t)||1===t?this.input=this.context.createGain():1<t&&(this.input=new Array(t)),this.isUndef(e)||1===e?this.output=this.context.createGain():1<e&&(this.output=new Array(t))}var e;return a.prototype.set=function(t,e,n){if(this.isObject(t))n=e;else if(this.isString(t)){var o={};o[t]=e,t=o}t:for(var i in t){e=t[i];var r=this;if(-1!==i.indexOf(".")){for(var s=i.split("."),u=0;u<s.length-1;u++)if((r=r[s[u]])instanceof a){s.splice(0,u+1);var p=s.join(".");r.set(p,e);continue t}i=s[s.length-1]}var c=r[i];this.isUndef(c)||(a.Signal&&c instanceof a.Signal||a.Param&&c instanceof a.Param?c.value!==e&&(this.isUndef(n)?c.value=e:c.rampTo(e,n)):c instanceof AudioParam?c.value!==e&&(c.value=e):c instanceof a?c.set(e):c!==e&&(r[i]=e))}return this},a.prototype.get=function(t){this.isUndef(t)?t=this._collectDefaults(this.constructor):this.isString(t)&&(t=[t]);for(var e={},n=0;n<t.length;n++){var o=t[n],i=this,r=e;if(-1!==o.indexOf(".")){for(var s=o.split("."),u=0;u<s.length-1;u++){var p=s[u];r[p]=r[p]||{},r=r[p],i=i[p]}o=s[s.length-1]}var c=i[o];this.isObject(t[o])?r[o]=c.get():a.Signal&&c instanceof a.Signal?r[o]=c.value:a.Param&&c instanceof a.Param?r[o]=c.value:c instanceof AudioParam?r[o]=c.value:c instanceof a?r[o]=c.get():this.isFunction(c)||this.isUndef(c)||(r[o]=c)}return e},a.prototype._collectDefaults=function(t){var e=[];if(this.isUndef(t.defaults)||(e=Object.keys(t.defaults)),!this.isUndef(t._super))for(var n=this._collectDefaults(t._super),o=0;o<n.length;o++)-1===e.indexOf(n[o])&&e.push(n[o]);return e},a.prototype.toString=function(){for(var t in a){var e=t[0].match(/^[A-Z]$/),n=a[t]===this.constructor;if(this.isFunction(a[t])&&e&&n)return t}return"Tone"},Object.defineProperty(a.prototype,"numberOfInputs",{get:function(){return this.input?this.isArray(this.input)?this.input.length:1:0}}),Object.defineProperty(a.prototype,"numberOfOutputs",{get:function(){return this.output?this.isArray(this.output)?this.output.length:1:0}}),a.prototype.dispose=function(){return this.isUndef(this.input)||(this.input instanceof AudioNode&&this.input.disconnect(),this.input=null),this.isUndef(this.output)||(this.output instanceof AudioNode&&this.output.disconnect(),this.output=null),this},a.prototype.connect=function(t,e,n){return Array.isArray(this.output)?(e=this.defaultArg(e,0),this.output[e].connect(t,0,n)):this.output.connect(t,e,n),this},a.prototype.disconnect=function(t,e,n){this.isArray(this.output)?this.isNumber(t)?this.output[t].disconnect():(e=this.defaultArg(e,0),this.output[e].disconnect(t,0,n)):this.output.disconnect.apply(this.output,arguments)},a.prototype.connectSeries=function(){if(1<arguments.length)for(var t=arguments[0],e=1;e<arguments.length;e++){var n=arguments[e];t.connect(n),t=n}return this},a.prototype.chain=function(){if(0<arguments.length)for(var t=this,e=0;e<arguments.length;e++){var n=arguments[e];t.connect(n),t=n}return this},a.prototype.fan=function(){if(0<arguments.length)for(var t=0;t<arguments.length;t++)this.connect(arguments[t]);return this},AudioNode.prototype.chain=a.prototype.chain,AudioNode.prototype.fan=a.prototype.fan,a.prototype.defaultArg=function(t,e){if(this.isObject(t)&&this.isObject(e)){var n={};for(var o in t)n[o]=this.defaultArg(e[o],t[o]);for(var i in e)n[i]=this.defaultArg(t[i],e[i]);return n}return this.isUndef(t)?e:t},a.prototype.optionsObject=function(t,e,n){var o={};if(1===t.length&&this.isObject(t[0]))o=t[0];else for(var i=0;i<e.length;i++)o[e[i]]=t[i];return this.isUndef(n)?o:this.defaultArg(o,n)},a.prototype.isUndef=function(t){return void 0===t},a.prototype.isFunction=function(t){return"function"==typeof t},a.prototype.isNumber=function(t){return"number"==typeof t},a.prototype.isObject=function(t){return"[object Object]"===Object.prototype.toString.call(t)&&t.constructor===Object},a.prototype.isBoolean=function(t){return"boolean"==typeof t},a.prototype.isArray=function(t){return Array.isArray(t)},a.prototype.isString=function(t){return"string"==typeof t},a.noOp=function(){},a.prototype._readOnly=function(t){if(Array.isArray(t))for(var e=0;e<t.length;e++)this._readOnly(t[e]);else Object.defineProperty(this,t,{writable:!1,enumerable:!0})},a.prototype._writable=function(t){if(Array.isArray(t))for(var e=0;e<t.length;e++)this._writable(t[e]);else Object.defineProperty(this,t,{writable:!0})},a.State={Started:"started",Stopped:"stopped",Paused:"paused"},a.prototype.equalPowerScale=function(t){var e=.5*Math.PI;return Math.sin(t*e)},a.prototype.dbToGain=function(t){return Math.pow(2,t/6)},a.prototype.gainToDb=function(t){return Math.log(t)/Math.LN10*20},a.prototype.intervalToFrequencyRatio=function(t){return Math.pow(2,t/12)},a.prototype.now=function(){return a.context.now()},a.now=function(){return a.context.now()},a.extend=function(t,e){function n(){}a.prototype.isUndef(e)&&(e=a),n.prototype=e.prototype,t.prototype=new n,(t.prototype.constructor=t)._super=e},Object.defineProperty(a,"context",{get:function(){return e},set:function(t){e=a.Context&&t instanceof a.Context?t:new a.Context(t),a.Context&&a.Context.emit("init",e)}}),Object.defineProperty(a.prototype,"context",{get:function(){return a.context}}),a.setContext=function(t){a.context=t},Object.defineProperty(a.prototype,"blockTime",{get:function(){return 128/this.context.sampleRate}}),Object.defineProperty(a.prototype,"sampleTime",{get:function(){return 1/this.context.sampleRate}}),Object.defineProperty(a,"supported",{get:function(){var t=window.hasOwnProperty("AudioContext")||window.hasOwnProperty("webkitAudioContext"),e=window.hasOwnProperty("Promise"),n=window.hasOwnProperty("Worker");return t&&e&&n}}),a.version="r10",window.TONE_SILENCE_VERSION_LOGGING||console.log("%c * Tone.js "+a.version+" * ","background: #000; color: #fff"),a}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (audiocontext) {
  var Master = function Master() {
    this.input = audiocontext.createGain();
    this.output = audiocontext.createGain(); 

    this.limiter = audiocontext.createDynamicsCompressor();
    this.limiter.threshold.value = -3;
    this.limiter.ratio.value = 20;
    this.limiter.knee.value = 1;
    this.audiocontext = audiocontext;
    this.output.disconnect(); 

    this.input.connect(this.limiter); 

    this.limiter.connect(this.output); 

    this.meter = audiocontext.createGain();
    this.fftMeter = audiocontext.createGain();
    this.output.connect(this.meter);
    this.output.connect(this.fftMeter); 

    this.output.connect(this.audiocontext.destination); 

    this.soundArray = []; 

    this.parts = []; 

    this.extensions = [];
  }; 


  var p5sound = new Master();
  /**
   * Returns a number representing the master amplitude (volume) for sound
   * in this sketch.
   *
   * @method getMasterVolume
   * @return {Number} Master amplitude (volume) for sound in this sketch.
   *                  Should be between 0.0 (silence) and 1.0.
   */

  p5.prototype.getMasterVolume = function () {
    return p5sound.output.gain.value;
  };
  /**
   *  <p>Scale the output of all sound in this sketch</p>
   *  Scaled between 0.0 (silence) and 1.0 (full volume).
   *  1.0 is the maximum amplitude of a digital sound, so multiplying
   *  by greater than 1.0 may cause digital distortion. To
   *  fade, provide a <code>rampTime</code> parameter. For more
   *  complex fades, see the Envelope class.
   *
   *  Alternately, you can pass in a signal source such as an
   *  oscillator to modulate the amplitude with an audio signal.
   *
   *  <p><b>How This Works</b>: When you load the p5.sound module, it
   *  creates a single instance of p5sound. All sound objects in this
   *  module output to p5sound before reaching your computer's output.
   *  So if you change the amplitude of p5sound, it impacts all of the
   *  sound in this module.</p>
   *
   *  <p>If no value is provided, returns a Web Audio API Gain Node</p>
   *
   *  @method  masterVolume
   *  @param {Number|Object} volume  Volume (amplitude) between 0.0
   *                                     and 1.0 or modulating signal/oscillator
   *  @param {Number} [rampTime]  Fade for t seconds
   *  @param {Number} [timeFromNow]  Schedule this event to happen at
   *                                 t seconds in the future
   */


  p5.prototype.masterVolume = function (vol, rampTime, tFromNow) {
    if (typeof vol === 'number') {
      var rampTime = rampTime || 0;
      var tFromNow = tFromNow || 0;
      var now = p5sound.audiocontext.currentTime;
      var currentVol = p5sound.output.gain.value;
      p5sound.output.gain.cancelScheduledValues(now + tFromNow);
      p5sound.output.gain.linearRampToValueAtTime(currentVol, now + tFromNow);
      p5sound.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime);
    } else if (vol) {
      vol.connect(p5sound.output.gain);
    } else {
      return p5sound.output.gain;
    }
  };
  /**
   *  `p5.soundOut` is the p5.sound master output. It sends output to
   *  the destination of this window's web audio context. It contains
   *  Web Audio API nodes including a dyanmicsCompressor (<code>.limiter</code>),
   *  and Gain Nodes for <code>.input</code> and <code>.output</code>.
   *
   *  @property {Object} soundOut
   */


  p5.prototype.soundOut = p5.soundOut = p5sound; 

  p5.soundOut._silentNode = p5sound.audiocontext.createGain();
  p5.soundOut._silentNode.gain.value = 0;

  p5.soundOut._silentNode.connect(p5sound.audiocontext.destination);

  return p5sound;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(5),__webpack_require__(8),__webpack_require__(22),__webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(n){"use strict";return n.Signal=function(){var t=this.optionsObject(arguments,["value","units"],n.Signal.defaults);this.output=this._gain=this.context.createGain(),t.param=this._gain.gain,n.Param.call(this,t),this.input=this._param=this._gain.gain,this.context.getConstant(1).chain(this._gain)},n.extend(n.Signal,n.Param),n.Signal.defaults={value:0,units:n.Type.Default,convert:!0},n.Signal.prototype.connect=n.SignalBase.prototype.connect,n.Signal.prototype.dispose=function(){return n.Param.prototype.dispose.call(this),this._param=null,this._gain.disconnect(),this._gain=null,this},n.Signal}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(2),__webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){"use strict";return i.Multiply=function(t){this.createInsOuts(2,0),this._mult=this.input[0]=this.output=new i.Gain,this._param=this.input[1]=this.output.gain,this._param.value=this.defaultArg(t,0)},i.extend(i.Multiply,i.Signal),i.Multiply.prototype.dispose=function(){return i.prototype.dispose.call(this),this._mult.dispose(),this._mult=null,this._param=null,this},i.Multiply}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var CrossFade = __webpack_require__(51);
  /**
   * Effect is a base class for audio effects in p5. <br>
   * This module handles the nodes and methods that are
   * common and useful for current and future effects.
   *
   *
   * This class is extended by <a href="/reference/#/p5.Distortion">p5.Distortion</a>,
   * <a href="/reference/#/p5.Compressor">p5.Compressor</a>,
   * <a href="/reference/#/p5.Delay">p5.Delay</a>,
   * <a href="/reference/#/p5.Filter">p5.Filter</a>,
   * <a href="/reference/#/p5.Reverb">p5.Reverb</a>.
   *
   * @class  p5.Effect
   * @constructor
   *
   * @param {Object} [ac]   Reference to the audio context of the p5 object
   * @param {AudioNode} [input]  Gain Node effect wrapper
   * @param {AudioNode} [output] Gain Node effect wrapper
   * @param {Object} [_drywet]   Tone.JS CrossFade node (defaults to value: 1)
   * @param {AudioNode} [wet]  Effects that extend this class should connect
   *                              to the wet signal to this gain node, so that dry and wet
   *                              signals are mixed properly.
   */


  p5.Effect = function () {
    this.ac = p5sound.audiocontext;
    this.input = this.ac.createGain();
    this.output = this.ac.createGain();
    /**
     *	The p5.Effect class is built
     * 	using Tone.js CrossFade
     * 	@private
     */

    this._drywet = new CrossFade(1);
    /**
     *	In classes that extend
     *	p5.Effect, connect effect nodes
     *	to the wet parameter
     */

    this.wet = this.ac.createGain();
    this.input.connect(this._drywet.a);
    this.wet.connect(this._drywet.b);

    this._drywet.connect(this.output);

    this.connect(); 

    p5sound.soundArray.push(this);
  };
  /**
   *  Set the output volume of the filter.
   *
   *  @method  amp
   *  @for p5.Effect
   *  @param {Number} [vol] amplitude between 0 and 1.0
   *  @param {Number} [rampTime] create a fade that lasts until rampTime
   *  @param {Number} [tFromNow] schedule this event to happen in tFromNow seconds
   */


  p5.Effect.prototype.amp = function (vol, rampTime, tFromNow) {
    var rampTime = rampTime || 0;
    var tFromNow = tFromNow || 0;
    var now = p5sound.audiocontext.currentTime;
    var currentVol = this.output.gain.value;
    this.output.gain.cancelScheduledValues(now);
    this.output.gain.linearRampToValueAtTime(currentVol, now + tFromNow + .001);
    this.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime + .001);
  };
  /**
   *  Link effects together in a chain
   *  Example usage: filter.chain(reverb, delay, panner);
   *  May be used with an open-ended number of arguments
   *
   *  @method chain
   *  @for p5.Effect
   *  @param {Object} [arguments]  Chain together multiple sound objects
   */


  p5.Effect.prototype.chain = function () {
    if (arguments.length > 0) {
      this.connect(arguments[0]);

      for (var i = 1; i < arguments.length; i += 1) {
        arguments[i - 1].connect(arguments[i]);
      }
    }

    return this;
  };
  /**
   *  Adjust the dry/wet value.
   *
   *  @method drywet
   *  @for p5.Effect
   *  @param {Number} [fade] The desired drywet value (0 - 1.0)
   */


  p5.Effect.prototype.drywet = function (fade) {
    if (typeof fade !== "undefined") {
      this._drywet.fade.value = fade;
    }

    return this._drywet.fade.value;
  };
  /**
   *  Send output to a p5.js-sound, Web Audio Node, or use signal to
   *  control an AudioParam
   *
   *  @method connect
   *  @for p5.Effect
   *  @param {Object} unit
   */


  p5.Effect.prototype.connect = function (unit) {
    var u = unit || p5.soundOut.input;
    this.output.connect(u.input ? u.input : u);
  };
  /**
   * Disconnect all output.
   * @method disconnect
   * @for p5.Effect
   */


  p5.Effect.prototype.disconnect = function () {
    if (this.output) {
      this.output.disconnect();
    }
  };

  p5.Effect.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);

    if (this.input) {
      this.input.disconnect();
      delete this.input;
    }

    if (this.output) {
      this.output.disconnect();
      delete this.output;
    }

    if (this._drywet) {
      this._drywet.disconnect();

      delete this._drywet;
    }

    if (this.wet) {
      this.wet.disconnect();
      delete this.wet;
    }

    this.ac = undefined;
  };

  return p5.Effect;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(e){"use strict";return e.WaveShaper=function(e,t){this._shaper=this.input=this.output=this.context.createWaveShaper(),this._curve=null,Array.isArray(e)?this.curve=e:isFinite(e)||this.isUndef(e)?this._curve=new Float32Array(this.defaultArg(e,1024)):this.isFunction(e)&&(this._curve=new Float32Array(this.defaultArg(t,1024)),this.setMap(e))},e.extend(e.WaveShaper,e.SignalBase),e.WaveShaper.prototype.setMap=function(e){for(var t=0,r=this._curve.length;t<r;t++){var s=t/(r-1)*2-1;this._curve[t]=e(s,t)}return this._shaper.curve=this._curve,this},Object.defineProperty(e.WaveShaper.prototype,"curve",{get:function(){return this._shaper.curve},set:function(e){this._curve=new Float32Array(e),this._shaper.curve=this._curve}}),Object.defineProperty(e.WaveShaper.prototype,"oversample",{get:function(){return this._shaper.oversample},set:function(e){if(-1===["none","2x","4x"].indexOf(e))throw new RangeError("Tone.WaveShaper: oversampling must be either 'none', '2x', or '4x'");this._shaper.oversample=e}}),e.WaveShaper.prototype.dispose=function(){return e.prototype.dispose.call(this),this._shaper.disconnect(),this._shaper=null,this._curve=null,this},e.WaveShaper}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var processorNames = __webpack_require__(10);
  /**
   * @for p5
   */

  /**
   * Returns a number representing the sample rate, in samples per second,
   * of all sound objects in this audio context. It is determined by the
   * sampling rate of your operating system's sound card, and it is not
   * currently possile to change.
   * It is often 44100, or twice the range of human hearing.
   *
   * @method sampleRate
   * @return {Number} samplerate samples per second
   */


  p5.prototype.sampleRate = function () {
    return p5sound.audiocontext.sampleRate;
  };
  /**
   *  Returns the closest MIDI note value for
   *  a given frequency.
   *
   *  @method freqToMidi
   *  @param  {Number} frequency A freqeuncy, for example, the "A"
   *                             above Middle C is 440Hz
   *  @return {Number}   MIDI note value
   */


  p5.prototype.freqToMidi = function (f) {
    var mathlog2 = Math.log(f / 440) / Math.log(2);
    var m = Math.round(12 * mathlog2) + 69;
    return m;
  };
  /**
   *  Returns the frequency value of a MIDI note value.
   *  General MIDI treats notes as integers where middle C
   *  is 60, C# is 61, D is 62 etc. Useful for generating
   *  musical frequencies with oscillators.
   *
   *  @method  midiToFreq
   *  @param  {Number} midiNote The number of a MIDI note
   *  @return {Number} Frequency value of the given MIDI note
   *  @example
   *  <div><code>
   *  let midiNotes = [60, 64, 67, 72];
   *  let noteIndex = 0;
   *  let midiVal, freq;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(startSound);
   *    osc = new p5.TriOsc();
   *    env = new p5.Envelope();
   *  }
   *
   *  function draw() {
   *    background(220);
   *    text('tap to play', 10, 20);
   *    if (midiVal) {
   *      text('MIDI: ' + midiVal, 10, 40);
   *      text('Freq: ' + freq, 10, 60);
   *    }
   *  }
   *
   *  function startSound() {
   *    // see also: userStartAudio();
   *    osc.start();
   *
   *    midiVal = midiNotes[noteIndex % midiNotes.length];
   *    freq = midiToFreq(midiVal);
   *    osc.freq(freq);
   *    env.ramp(osc, 0, 1.0, 0);
   *
   *    noteIndex++;
   *  }
   *  </code></div>
   */


  var midiToFreq = p5.prototype.midiToFreq = function (m) {
    return 440 * Math.pow(2, (m - 69) / 12.0);
  }; 


  var noteToFreq = function noteToFreq(note) {
    if (typeof note !== 'string') {
      return note;
    }

    var wholeNotes = {
      A: 21,
      B: 23,
      C: 24,
      D: 26,
      E: 28,
      F: 29,
      G: 31
    };
    var value = wholeNotes[note[0].toUpperCase()];
    var octave = ~~note.slice(-1);
    value += 12 * (octave - 1);

    switch (note[1]) {
      case '#':
        value += 1;
        break;

      case 'b':
        value -= 1;
        break;

      default:
        break;
    }

    return midiToFreq(value);
  };
  /**
   *  List the SoundFile formats that you will include. LoadSound
   *  will search your directory for these extensions, and will pick
   *  a format that is compatable with the client's web browser.
   *  <a href="http://media.io/">Here</a> is a free online file
   *  converter.
   *
   *  @method soundFormats
   *  @param {String} [...formats] i.e. 'mp3', 'wav', 'ogg'
   *  @example
   *  <div><code>
   *  function preload() {
   *    // set the global sound formats
   *    soundFormats('mp3', 'ogg');
   *
   *    // load either beatbox.mp3, or .ogg, depending on browser
   *    mySound = loadSound('assets/beatbox.mp3');
   *  }
   *
   *  function setup() {
   *       let cnv = createCanvas(100, 100);
   *       background(220);
   *       text('sound loaded! tap to play', 10, 20, width - 20);
   *       cnv.mousePressed(function() {
   *         mySound.play();
   *       });
   *     }
   *  </code></div>
   */


  p5.prototype.soundFormats = function () {
    p5sound.extensions = []; 

    for (var i = 0; i < arguments.length; i++) {
      arguments[i] = arguments[i].toLowerCase();

      if (['mp3', 'wav', 'ogg', 'm4a', 'aac'].indexOf(arguments[i]) > -1) {
        p5sound.extensions.push(arguments[i]);
      } else {
        throw arguments[i] + ' is not a valid sound format!';
      }
    }
  };

  p5.prototype.disposeSound = function () {
    for (var i = 0; i < p5sound.soundArray.length; i++) {
      p5sound.soundArray[i].dispose();
    }
  }; 


  p5.prototype.registerMethod('remove', p5.prototype.disposeSound);

  p5.prototype._checkFileFormats = function (paths) {
    var path; 

    if (typeof paths === 'string') {
      path = paths; 

      var extTest = path.split('.').pop(); 

      if (['mp3', 'wav', 'ogg', 'm4a', 'aac'].indexOf(extTest) > -1) {
        if (p5.prototype.isFileSupported(extTest)) {
          path = path;
        } else {
          var pathSplit = path.split('.');
          var pathCore = pathSplit[pathSplit.length - 1];

          for (var i = 0; i < p5sound.extensions.length; i++) {
            var extension = p5sound.extensions[i];
            var supported = p5.prototype.isFileSupported(extension);

            if (supported) {
              pathCore = '';

              if (pathSplit.length === 2) {
                pathCore += pathSplit[0];
              }

              for (var i = 1; i <= pathSplit.length - 2; i++) {
                var p = pathSplit[i];
                pathCore += '.' + p;
              }

              path = pathCore += '.';
              path = path += extension;
              break;
            }
          }
        }
      } 
      else {
          for (var i = 0; i < p5sound.extensions.length; i++) {
            var extension = p5sound.extensions[i];
            var supported = p5.prototype.isFileSupported(extension);

            if (supported) {
              path = path + '.' + extension;
              break;
            }
          }
        }
    } 
    else if (_typeof(paths) === 'object') {
        for (var i = 0; i < paths.length; i++) {
          var extension = paths[i].split('.').pop();
          var supported = p5.prototype.isFileSupported(extension);

          if (supported) {
            path = paths[i];
            break;
          }
        }
      }

    return path;
  };
  /**
   *  Used by Osc and Envelope to chain signal math
   */


  p5.prototype._mathChain = function (o, math, thisChain, nextChain, type) {
    for (var i in o.mathOps) {
      if (o.mathOps[i] instanceof type) {
        o.mathOps[i].dispose();
        thisChain = i;

        if (thisChain < o.mathOps.length - 1) {
          nextChain = o.mathOps[i + 1];
        }
      }
    }

    o.mathOps[thisChain - 1].disconnect();
    o.mathOps[thisChain - 1].connect(math);
    math.connect(nextChain);
    o.mathOps[thisChain] = math;
    return o;
  }; 


  function convertToWav(audioBuffer) {
    var leftChannel, rightChannel;
    leftChannel = audioBuffer.getChannelData(0); 

    if (audioBuffer.numberOfChannels > 1) {
      rightChannel = audioBuffer.getChannelData(1);
    } else {
      rightChannel = leftChannel;
    }

    var interleaved = interleave(leftChannel, rightChannel); 

    var buffer = new window.ArrayBuffer(44 + interleaved.length * 2);
    var view = new window.DataView(buffer); 

    writeUTFBytes(view, 0, 'RIFF');
    view.setUint32(4, 36 + interleaved.length * 2, true);
    writeUTFBytes(view, 8, 'WAVE'); 

    writeUTFBytes(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); 

    view.setUint16(22, 2, true);
    view.setUint32(24, p5sound.audiocontext.sampleRate, true);
    view.setUint32(28, p5sound.audiocontext.sampleRate * 4, true);
    view.setUint16(32, 4, true);
    view.setUint16(34, 16, true); 

    writeUTFBytes(view, 36, 'data');
    view.setUint32(40, interleaved.length * 2, true); 

    var lng = interleaved.length;
    var index = 44;
    var volume = 1;

    for (var i = 0; i < lng; i++) {
      view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
      index += 2;
    }

    return view;
  } 


  function interleave(leftChannel, rightChannel) {
    var length = leftChannel.length + rightChannel.length;
    var result = new Float32Array(length);
    var inputIndex = 0;

    for (var index = 0; index < length;) {
      result[index++] = leftChannel[inputIndex];
      result[index++] = rightChannel[inputIndex];
      inputIndex++;
    }

    return result;
  }

  function writeUTFBytes(view, offset, string) {
    var lng = string.length;

    for (var i = 0; i < lng; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }

  function safeBufferSize(idealBufferSize) {
    var bufferSize = idealBufferSize; 

    var tempAudioWorkletNode = new AudioWorkletNode(p5sound.audiocontext, processorNames.soundFileProcessor);

    if (tempAudioWorkletNode instanceof ScriptProcessorNode) {
      bufferSize = tempAudioWorkletNode.bufferSize;
    }

    tempAudioWorkletNode.disconnect();
    tempAudioWorkletNode = null;
    return bufferSize;
  }

  return {
    convertToWav: convertToWav,
    midiToFreq: midiToFreq,
    noteToFreq: noteToFreq,
    safeBufferSize: safeBufferSize
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(2),__webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){"use strict";return i.Add=function(t){this.createInsOuts(2,0),this._sum=this.input[0]=this.input[1]=this.output=new i.Gain,this._param=this.input[1]=new i.Signal(t),this._param.connect(this._sum)},i.extend(i.Add,i.Signal),i.Add.prototype.dispose=function(){return i.prototype.dispose.call(this),this._sum.dispose(),this._sum=null,this._param.dispose(),this._param=null,this},i.Add}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(20),__webpack_require__(45),__webpack_require__(46),__webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(t){return t.Type={Default:"number",Time:"time",Frequency:"frequency",TransportTime:"transportTime",Ticks:"ticks",NormalRange:"normalRange",AudioRange:"audioRange",Decibels:"db",Interval:"interval",BPM:"bpm",Positive:"positive",Cents:"cents",Degrees:"degrees",MIDI:"midi",BarsBeatsSixteenths:"barsBeatsSixteenths",Samples:"samples",Hertz:"hertz",Note:"note",Milliseconds:"milliseconds",Seconds:"seconds",Notation:"notation"},t.prototype.toSeconds=function(e){return this.isNumber(e)?e:this.isUndef(e)?this.now():this.isString(e)?new t.Time(e).toSeconds():e instanceof t.TimeBase?e.toSeconds():void 0},t.prototype.toFrequency=function(e){return this.isNumber(e)?e:this.isString(e)||this.isUndef(e)?new t.Frequency(e).valueOf():e instanceof t.TimeBase?e.toFrequency():void 0},t.prototype.toTicks=function(e){return this.isNumber(e)||this.isString(e)?new t.TransportTime(e).toTicks():this.isUndef(e)?t.Transport.ticks:e instanceof t.TimeBase?e.toTicks():void 0},t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(22),__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){"use strict";return window.GainNode&&!AudioContext.prototype.createGain&&(AudioContext.prototype.createGain=AudioContext.prototype.createGainNode),i.Gain=function(){var t=this.optionsObject(arguments,["gain","units"],i.Gain.defaults);this.input=this.output=this._gainNode=this.context.createGain(),this.gain=new i.Param({param:this._gainNode.gain,units:t.units,value:t.gain,convert:t.convert}),this._readOnly("gain")},i.extend(i.Gain),i.Gain.defaults={gain:1,convert:!0},i.Gain.prototype.dispose=function(){i.Param.prototype.dispose.call(this),this._gainNode.disconnect(),this._gainNode=null,this._writable("gain"),this.gain.dispose(),this.gain=null},i.prototype.createInsOuts=function(t,n){1===t?this.input=new i.Gain:1<t&&(this.input=new Array(t)),1===n?this.output=new i.Gain:1<n&&(this.output=new Array(t))},i.Gain}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports) {

module.exports = {
  recorderProcessor: 'recorder-processor',
  soundFileProcessor: 'sound-file-processor',
  amplitudeProcessor: 'amplitude-processor'
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  var CustomError = function CustomError(name, errorTrace, failedPath) {
    var err = new Error();
    var tempStack, splitStack;
    err.name = name;
    err.originalStack = err.stack + errorTrace;
    tempStack = err.stack + errorTrace;
    err.failedPath = failedPath; 

    var splitStack = tempStack.split('\n');
    splitStack = splitStack.filter(function (ln) {
      return !ln.match(/(p5.|native code|globalInit)/g);
    });
    err.stack = splitStack.join('\n');
    return err; 
  };

  return CustomError;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(18)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){function t(e,t,n){if(e.input)Array.isArray(e.input)?(o.prototype.isUndef(n)&&(n=0),this.connect(e.input[n])):this.connect(e.input,t,n);else try{e instanceof AudioNode?i.call(this,e,t,n):i.call(this,e,t)}catch(t){throw new Error("error connecting to node: "+e+"\n"+t)}}var i,r;return!window.hasOwnProperty("AudioContext")&&window.hasOwnProperty("webkitAudioContext")&&(window.AudioContext=window.webkitAudioContext),o.Context=function(t){for(var e in o.Emitter.call(this),t=t||new window.AudioContext,this._context=t,this._context)this._defineProperty(this._context,e);this._latencyHint="interactive",this._lookAhead=.1,this._updateInterval=this._lookAhead/3,this._computedUpdateInterval=0,this._worker=this._createWorker(),this._constants={}},o.extend(o.Context,o.Emitter),o.Emitter.mixin(o.Context),o.Context.prototype._defineProperty=function(e,n){this.isUndef(this[n])&&Object.defineProperty(this,n,{get:function(){return"function"==typeof e[n]?e[n].bind(e):e[n]},set:function(t){e[n]=t}})},o.Context.prototype.now=function(){return this._context.currentTime},o.Context.prototype._createWorker=function(){window.URL=window.URL||window.webkitURL;var t=new Blob(["var timeoutTime = "+(1e3*this._updateInterval).toFixed(1)+";self.onmessage = function(msg){\ttimeoutTime = parseInt(msg.data);};function tick(){\tsetTimeout(tick, timeoutTime);\tself.postMessage('tick');}tick();"]),e=URL.createObjectURL(t),n=new Worker(e);return n.addEventListener("message",function(){this.emit("tick")}.bind(this)),n.addEventListener("message",function(){var t=this.now();if(this.isNumber(this._lastUpdate)){var e=t-this._lastUpdate;this._computedUpdateInterval=Math.max(e,.97*this._computedUpdateInterval)}this._lastUpdate=t}.bind(this)),n},o.Context.prototype.getConstant=function(t){if(this._constants[t])return this._constants[t];for(var e=this._context.createBuffer(1,128,this._context.sampleRate),n=e.getChannelData(0),o=0;o<n.length;o++)n[o]=t;var i=this._context.createBufferSource();return i.channelCount=1,i.channelCountMode="explicit",i.buffer=e,i.loop=!0,i.start(0),this._constants[t]=i},Object.defineProperty(o.Context.prototype,"lag",{get:function(){var t=this._computedUpdateInterval-this._updateInterval;return t=Math.max(t,0)}}),Object.defineProperty(o.Context.prototype,"lookAhead",{get:function(){return this._lookAhead},set:function(t){this._lookAhead=t}}),Object.defineProperty(o.Context.prototype,"updateInterval",{get:function(){return this._updateInterval},set:function(t){this._updateInterval=Math.max(t,o.prototype.blockTime),this._worker.postMessage(Math.max(1e3*t,1))}}),Object.defineProperty(o.Context.prototype,"latencyHint",{get:function(){return this._latencyHint},set:function(t){var e=t;if(this._latencyHint=t,this.isString(t))switch(t){case"interactive":e=.1,this._context.latencyHint=t;break;case"playback":e=.8,this._context.latencyHint=t;break;case"balanced":e=.25,this._context.latencyHint=t;break;case"fastest":e=.01}this.lookAhead=e,this.updateInterval=e/3}}),o.supported?(i=AudioNode.prototype.connect,r=AudioNode.prototype.disconnect,AudioNode.prototype.connect!==t&&(AudioNode.prototype.connect=t,AudioNode.prototype.disconnect=function(e,t,n){if(e&&e.input&&Array.isArray(e.input))o.prototype.isUndef(n)&&(n=0),this.disconnect(e.input[n],t,n);else if(e&&e.input)this.disconnect(e.input,t,n);else try{r.apply(this,arguments)}catch(t){throw new Error("error disconnecting node: "+e+"\n"+t)}}),o.context=new o.Context):console.warn("This browser does not support Tone.js"),o.Context}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(7),__webpack_require__(3),__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){"use strict";return i.Scale=function(t,e){this._outputMin=this.defaultArg(t,0),this._outputMax=this.defaultArg(e,1),this._scale=this.input=new i.Multiply(1),this._add=this.output=new i.Add(0),this._scale.connect(this._add),this._setRange()},i.extend(i.Scale,i.SignalBase),Object.defineProperty(i.Scale.prototype,"min",{get:function(){return this._outputMin},set:function(t){this._outputMin=t,this._setRange()}}),Object.defineProperty(i.Scale.prototype,"max",{get:function(){return this._outputMax},set:function(t){this._outputMax=t,this._setRange()}}),i.Scale.prototype._setRange=function(){this._add.value=this._outputMin,this._scale.value=this._outputMax-this._outputMin},i.Scale.prototype.dispose=function(){return i.prototype.dispose.call(this),this._add.dispose(),this._add=null,this._scale.dispose(),this._scale=null,this},i.Scale}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(2),__webpack_require__(24)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){"use strict";return o.TimelineSignal=function(){var e=this.optionsObject(arguments,["value","units"],o.Signal.defaults);this._events=new o.Timeline(10),o.Signal.apply(this,e),e.param=this._param,o.Param.call(this,e),this._initial=this._fromUnits(this._param.value)},o.extend(o.TimelineSignal,o.Param),o.TimelineSignal.Type={Linear:"linear",Exponential:"exponential",Target:"target",Curve:"curve",Set:"set"},Object.defineProperty(o.TimelineSignal.prototype,"value",{get:function(){var e=this.now(),t=this.getValueAtTime(e);return this._toUnits(t)},set:function(e){var t=this._fromUnits(e);this._initial=t,this.cancelScheduledValues(),this._param.value=t}}),o.TimelineSignal.prototype.setValueAtTime=function(e,t){return e=this._fromUnits(e),t=this.toSeconds(t),this._events.add({type:o.TimelineSignal.Type.Set,value:e,time:t}),this._param.setValueAtTime(e,t),this},o.TimelineSignal.prototype.linearRampToValueAtTime=function(e,t){return e=this._fromUnits(e),t=this.toSeconds(t),this._events.add({type:o.TimelineSignal.Type.Linear,value:e,time:t}),this._param.linearRampToValueAtTime(e,t),this},o.TimelineSignal.prototype.exponentialRampToValueAtTime=function(e,t){t=this.toSeconds(t);var i=this._searchBefore(t);i&&0===i.value&&this.setValueAtTime(this._minOutput,i.time),e=this._fromUnits(e);var n=Math.max(e,this._minOutput);return this._events.add({type:o.TimelineSignal.Type.Exponential,value:n,time:t}),e<this._minOutput?(this._param.exponentialRampToValueAtTime(this._minOutput,t-this.sampleTime),this.setValueAtTime(0,t)):this._param.exponentialRampToValueAtTime(e,t),this},o.TimelineSignal.prototype.setTargetAtTime=function(e,t,i){return e=this._fromUnits(e),e=Math.max(this._minOutput,e),i=Math.max(this._minOutput,i),t=this.toSeconds(t),this._events.add({type:o.TimelineSignal.Type.Target,value:e,time:t,constant:i}),this._param.setTargetAtTime(e,t,i),this},o.TimelineSignal.prototype.setValueCurveAtTime=function(e,t,i,n){n=this.defaultArg(n,1);for(var a=new Array(e.length),l=0;l<a.length;l++)a[l]=this._fromUnits(e[l])*n;t=this.toSeconds(t),i=this.toSeconds(i),this._events.add({type:o.TimelineSignal.Type.Curve,value:a,time:t,duration:i}),this._param.setValueAtTime(a[0],t);for(var s=1;s<a.length;s++){var r=t+s/(a.length-1)*i;this._param.linearRampToValueAtTime(a[s],r)}return this},o.TimelineSignal.prototype.cancelScheduledValues=function(e){return e=this.toSeconds(e),this._events.cancel(e),this._param.cancelScheduledValues(e),this},o.TimelineSignal.prototype.setRampPoint=function(e){e=this.toSeconds(e);var t=this._toUnits(this.getValueAtTime(e)),i=this._searchBefore(e);if(i&&i.time===e)this.cancelScheduledValues(e+this.sampleTime);else if(i&&i.type===o.TimelineSignal.Type.Curve&&i.time+i.duration>e)this.cancelScheduledValues(e),this.linearRampToValueAtTime(t,e);else{var n=this._searchAfter(e);n&&(this.cancelScheduledValues(e),n.type===o.TimelineSignal.Type.Linear?this.linearRampToValueAtTime(t,e):n.type===o.TimelineSignal.Type.Exponential&&this.exponentialRampToValueAtTime(t,e)),this.setValueAtTime(t,e)}return this},o.TimelineSignal.prototype.linearRampToValueBetween=function(e,t,i){return this.setRampPoint(t),this.linearRampToValueAtTime(e,i),this},o.TimelineSignal.prototype.exponentialRampToValueBetween=function(e,t,i){return this.setRampPoint(t),this.exponentialRampToValueAtTime(e,i),this},o.TimelineSignal.prototype._searchBefore=function(e){return this._events.get(e)},o.TimelineSignal.prototype._searchAfter=function(e){return this._events.getAfter(e)},o.TimelineSignal.prototype.getValueAtTime=function(e){e=this.toSeconds(e);var t=this._searchAfter(e),i=this._searchBefore(e),n=this._initial;if(null===i)n=this._initial;else if(i.type===o.TimelineSignal.Type.Target){var a,l=this._events.getBefore(i.time);a=null===l?this._initial:l.value,n=this._exponentialApproach(i.time,a,i.value,i.constant,e)}else n=i.type===o.TimelineSignal.Type.Curve?this._curveInterpolate(i.time,i.value,i.duration,e):null===t?i.value:t.type===o.TimelineSignal.Type.Linear?this._linearInterpolate(i.time,i.value,t.time,t.value,e):t.type===o.TimelineSignal.Type.Exponential?this._exponentialInterpolate(i.time,i.value,t.time,t.value,e):i.value;return n},o.TimelineSignal.prototype.connect=o.SignalBase.prototype.connect,o.TimelineSignal.prototype._exponentialApproach=function(e,t,i,n,a){return i+(t-i)*Math.exp(-(a-e)/n)},o.TimelineSignal.prototype._linearInterpolate=function(e,t,i,n,a){return t+(a-e)/(i-e)*(n-t)},o.TimelineSignal.prototype._exponentialInterpolate=function(e,t,i,n,a){return(t=Math.max(this._minOutput,t))*Math.pow(n/t,(a-e)/(i-e))},o.TimelineSignal.prototype._curveInterpolate=function(e,t,i,n){var a=t.length;if(e+i<=n)return t[a-1];if(n<=e)return t[0];var l=(n-e)/i,s=Math.floor((a-1)*l),r=Math.ceil((a-1)*l),o=t[s],p=t[r];return r===s?o:this._linearInterpolate(s,o,r,p,l*(a-1))},o.TimelineSignal.prototype.dispose=function(){o.Signal.prototype.dispose.call(this),o.Param.prototype.dispose.call(this),this._events.dispose(),this._events=null},o.TimelineSignal}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var Effect = __webpack_require__(4);
  /**
   *  <p>A p5.Filter uses a Web Audio Biquad Filter to filter
   *  the frequency response of an input source. Subclasses
   *  include:</p>
   *  <a href="/reference/#/p5.LowPass"><code>p5.LowPass</code></a>:
   *  Allows frequencies below the cutoff frequency to pass through,
   *  and attenuates frequencies above the cutoff.<br/>
   *  <a href="/reference/#/p5.HighPass"><code>p5.HighPass</code></a>:
   *  The opposite of a lowpass filter. <br/>
   *  <a href="/reference/#/p5.BandPass"><code>p5.BandPass</code></a>:
   *  Allows a range of frequencies to pass through and attenuates
   *  the frequencies below and above this frequency range.<br/>
   *
   *  The <code>.res()</code> method controls either width of the
   *  bandpass, or resonance of the low/highpass cutoff frequency.
   *
   *  This class extends <a href = "/reference/#/p5.Effect">p5.Effect</a>.
   *  Methods <a href = "/reference/#/p5.Effect/amp">amp()</a>, <a href = "/reference/#/p5.Effect/chain">chain()</a>,
   *  <a href = "/reference/#/p5.Effect/drywet">drywet()</a>, <a href = "/reference/#/p5.Effect/connect">connect()</a>, and
   *  <a href = "/reference/#/p5.Effect/disconnect">disconnect()</a> are available.
   *
   *  @class p5.Filter
   *  @extends p5.Effect
   *  @constructor
   *  @param {String} [type] 'lowpass' (default), 'highpass', 'bandpass'
   *  @example
   *  <div><code>
  *  let fft, noise, filter;
  *
  *  function setup() {
  *    let cnv = createCanvas(100,100);
  *    cnv.mousePressed(makeNoise);
  *    fill(255, 0, 255);
  *
  *    filter = new p5.BandPass();
  *    noise = new p5.Noise();
  *    noise.disconnect();
  *    noise.connect(filter);
  *
  *    fft = new p5.FFT();
  *  }
  *
  *  function draw() {
  *    background(220);
  *
  *    // set the BandPass frequency based on mouseX
  *    let freq = map(mouseX, 0, width, 20, 10000);
  *    freq = constrain(freq, 0, 22050);
  *    filter.freq(freq);
  *    // give the filter a narrow band (lower res = wider bandpass)
  *    filter.res(50);
  *
  *    // draw filtered spectrum
  *    let spectrum = fft.analyze();
  *    noStroke();
  *    for (let i = 0; i < spectrum.length; i++) {
  *      let x = map(i, 0, spectrum.length, 0, width);
  *      let h = -height + map(spectrum[i], 0, 255, height, 0);
  *      rect(x, height, width/spectrum.length, h);
  *    }
  *    if (!noise.started) {
  *      text('tap here and drag to change frequency', 10, 20, width - 20);
  *    } else {
  *      text('Frequency: ' + round(freq)+'Hz', 20, 20, width - 20);
  *    }
  *  }
  *
  *  function makeNoise() {
  *    // see also: `userStartAudio()`
  *    noise.start();
  *    noise.amp(0.5, 0.2);
  *  }
  *
  *  function mouseReleased() {
  *    noise.amp(0, 0.2);
  *  }
  *
   *  </code></div>
   */


  p5.Filter = function (type) {
    Effect.call(this); 

    /**
      *  The p5.Filter is built with a
      *  <a href="http://www.w3.org/TR/webaudio/#BiquadFilterNode">
      *  Web Audio BiquadFilter Node</a>.
      *
      *  @property {DelayNode} biquadFilter
    */

    this.biquad = this.ac.createBiquadFilter();
    this.input.connect(this.biquad);
    this.biquad.connect(this.wet);

    if (type) {
      this.setType(type);
    } 


    this._on = true;
    this._untoggledType = this.biquad.type;
  };

  p5.Filter.prototype = Object.create(Effect.prototype);
  /**
   *  Filter an audio signal according to a set
   *  of filter parameters.
   *
   *  @method  process
   *  @param  {Object} Signal  An object that outputs audio
   *  @param {Number} [freq] Frequency in Hz, from 10 to 22050
   *  @param {Number} [res] Resonance/Width of the filter frequency
   *                        from 0.001 to 1000
   */

  p5.Filter.prototype.process = function (src, freq, res, time) {
    src.connect(this.input);
    this.set(freq, res, time);
  };
  /**
   *  Set the frequency and the resonance of the filter.
   *
   *  @method  set
   *  @param {Number} [freq] Frequency in Hz, from 10 to 22050
   *  @param {Number} [res]  Resonance (Q) from 0.001 to 1000
   *  @param {Number} [timeFromNow] schedule this event to happen
   *                                seconds from now
   */


  p5.Filter.prototype.set = function (freq, res, time) {
    if (freq) {
      this.freq(freq, time);
    }

    if (res) {
      this.res(res, time);
    }
  };
  /**
   *  Set the filter frequency, in Hz, from 10 to 22050 (the range of
   *  human hearing, although in reality most people hear in a narrower
   *  range).
   *
   *  @method  freq
   *  @param  {Number} freq Filter Frequency
   *  @param {Number} [timeFromNow] schedule this event to happen
   *                                seconds from now
   *  @return {Number} value  Returns the current frequency value
   */


  p5.Filter.prototype.freq = function (freq, time) {
    var t = time || 0;

    if (freq <= 0) {
      freq = 1;
    }

    if (typeof freq === 'number') {
      this.biquad.frequency.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.biquad.frequency.exponentialRampToValueAtTime(freq, this.ac.currentTime + 0.02 + t);
    } else if (freq) {
      freq.connect(this.biquad.frequency);
    }

    return this.biquad.frequency.value;
  };
  /**
   *  Controls either width of a bandpass frequency,
   *  or the resonance of a low/highpass cutoff frequency.
   *
   *  @method  res
   *  @param {Number} res  Resonance/Width of filter freq
   *                       from 0.001 to 1000
   *  @param {Number} [timeFromNow] schedule this event to happen
   *                                seconds from now
   *  @return {Number} value Returns the current res value
   */


  p5.Filter.prototype.res = function (res, time) {
    var t = time || 0;

    if (typeof res === 'number') {
      this.biquad.Q.value = res;
      this.biquad.Q.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.biquad.Q.linearRampToValueAtTime(res, this.ac.currentTime + 0.02 + t);
    } else if (res) {
      res.connect(this.biquad.Q);
    }

    return this.biquad.Q.value;
  };
  /**
   * Controls the gain attribute of a Biquad Filter.
   * This is distinctly different from .amp() which is inherited from p5.Effect
   * .amp() controls the volume via the output gain node
   * p5.Filter.gain() controls the gain parameter of a Biquad Filter node.
   *
   * @method gain
   * @param  {Number} gain
   * @return {Number} Returns the current or updated gain value
   */


  p5.Filter.prototype.gain = function (gain, time) {
    var t = time || 0;

    if (typeof gain === 'number') {
      this.biquad.gain.value = gain;
      this.biquad.gain.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.biquad.gain.linearRampToValueAtTime(gain, this.ac.currentTime + 0.02 + t);
    } else if (gain) {
      gain.connect(this.biquad.gain);
    }

    return this.biquad.gain.value;
  };
  /**
   * Toggle function. Switches between the specified type and allpass
   *
   * @method toggle
   * @return {boolean} [Toggle value]
   */


  p5.Filter.prototype.toggle = function () {
    this._on = !this._on;

    if (this._on === true) {
      this.biquad.type = this._untoggledType;
    } else if (this._on === false) {
      this.biquad.type = 'allpass';
    }

    return this._on;
  };
  /**
   *  Set the type of a p5.Filter. Possible types include:
   *  "lowpass" (default), "highpass", "bandpass",
   *  "lowshelf", "highshelf", "peaking", "notch",
   *  "allpass".
   *
   *  @method  setType
   *  @param {String} t
   */


  p5.Filter.prototype.setType = function (t) {
    this.biquad.type = t;
    this._untoggledType = this.biquad.type;
  };

  p5.Filter.prototype.dispose = function () {
    Effect.prototype.dispose.apply(this);

    if (this.biquad) {
      this.biquad.disconnect();
      delete this.biquad;
    }
  };
  /**
   *  Constructor: <code>new p5.LowPass()</code> Filter.
   *  This is the same as creating a p5.Filter and then calling
   *  its method <code>setType('lowpass')</code>.
   *  See p5.Filter for methods.
   *
   *  @class p5.LowPass
   *  @constructor
   *  @extends p5.Filter
   */


  p5.LowPass = function () {
    p5.Filter.call(this, 'lowpass');
  };

  p5.LowPass.prototype = Object.create(p5.Filter.prototype);
  /**
   *  Constructor: <code>new p5.HighPass()</code> Filter.
   *  This is the same as creating a p5.Filter and then calling
   *  its method <code>setType('highpass')</code>.
   *  See p5.Filter for methods.
   *
   *  @class p5.HighPass
   *  @constructor
   *  @extends p5.Filter
   */

  p5.HighPass = function () {
    p5.Filter.call(this, 'highpass');
  };

  p5.HighPass.prototype = Object.create(p5.Filter.prototype);
  /**
   *  Constructor: <code>new p5.BandPass()</code> Filter.
   *  This is the same as creating a p5.Filter and then calling
   *  its method <code>setType('bandpass')</code>.
   *  See p5.Filter for methods.
   *
   *  @class p5.BandPass
   *  @constructor
   *  @extends p5.Filter
   */

  p5.BandPass = function () {
    p5.Filter.call(this, 'bandpass');
  };

  p5.BandPass.prototype = Object.create(p5.Filter.prototype);
  return p5.Filter;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(7),__webpack_require__(25),__webpack_require__(2),__webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(n){"use strict";return n.Subtract=function(t){this.createInsOuts(2,0),this._sum=this.input[0]=this.output=new n.Gain,this._neg=new n.Negate,this._param=this.input[1]=new n.Signal(t),this._param.chain(this._neg,this._sum)},n.extend(n.Subtract,n.Signal),n.Subtract.prototype.dispose=function(){return n.prototype.dispose.call(this),this._neg.dispose(),this._neg=null,this._sum.disconnect(),this._sum=null,this._param.dispose(),this._param=null,this},n.Subtract}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

global.TONE_SILENCE_VERSION_LOGGING = true;
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(35), __webpack_require__(12), __webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (StartAudioContext, Context, Tone) {
  var audiocontext = new window.AudioContext(); 

  Tone.context.dispose();
  Tone.setContext(audiocontext);
  /**
   * <p>Returns the Audio Context for this sketch. Useful for users
   * who would like to dig deeper into the <a target='_blank' href=
   * 'http://webaudio.github.io/web-audio-api/'>Web Audio API
   * </a>.</p>
   *
   * <p>Some browsers require users to startAudioContext
   * with a user gesture, such as touchStarted in the example below.</p>
   *
   * @for p5
   * @method getAudioContext
   * @return {Object}    AudioContext for this sketch
   * @example
   * <div><code>
   *  function draw() {
   *    background(255);
   *    textAlign(CENTER);
   *
   *    if (getAudioContext().state !== 'running') {
   *      text('click to start audio', width/2, height/2);
   *    } else {
   *      text('audio is enabled', width/2, height/2);
   *    }
   *  }
   *
   *  function touchStarted() {
   *    if (getAudioContext().state !== 'running') {
   *      getAudioContext().resume();
   *    }
   *    var synth = new p5.MonoSynth();
   *    synth.play('A4', 0.5, 0, 0.2);
   *  }
   *
   * </div></code>
   */

  p5.prototype.getAudioContext = function () {
    return audiocontext;
  };
  /**
   *  <p>It is not only a good practice to give users control over starting
   *  audio. This policy is enforced by many web browsers, including iOS and
   *  <a href="https://goo.gl/7K7WLu" title="Google Chrome's autoplay
   *  policy">Google Chrome</a>, which create the Web Audio API's
   *  <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext"
   *  title="Audio Context @ MDN">Audio Context</a>
   *  in a suspended state.</p>
   *
   *  <p>In these browser-specific policies, sound will not play until a user
   *  interaction event (i.e. <code>mousePressed()</code>) explicitly resumes
   *  the AudioContext, or starts an audio node. This can be accomplished by
   *  calling <code>start()</code> on a <code>p5.Oscillator</code>,
   *  <code> play()</code> on a <code>p5.SoundFile</code>, or simply
   *  <code>userStartAudio()</code>.</p>
   *
   *  <p><code>userStartAudio()</code> starts the AudioContext on a user
   *  gesture. The default behavior will enable audio on any
   *  mouseUp or touchEnd event. It can also be placed in a specific
   *  interaction function, such as <code>mousePressed()</code> as in the
   *  example below. This method utilizes
   *  <a href="https://github.com/tambien/StartAudioContext">StartAudioContext
   *  </a>, a library by Yotam Mann (MIT Licence, 2016).</p>
   *  @param  {Element|Array}   [element(s)] This argument can be an Element,
   *                                Selector String, NodeList, p5.Element,
   *                                jQuery Element, or an Array of any of those.
   *  @param  {Function} [callback] Callback to invoke when the AudioContext
   *                                has started
   *  @return {Promise}            Returns a Promise that resolves when
   *                                       the AudioContext state is 'running'
   *  @method userStartAudio
   *  @for p5
   *  @example
   *  <div><code>
   *  function setup() {
   *    // mimics the autoplay policy
   *    getAudioContext().suspend();
   *
   *    let mySynth = new p5.MonoSynth();
   *
   *    // This won't play until the context has resumed
   *    mySynth.play('A6');
   *  }
   *  function draw() {
   *    background(220);
   *    textAlign(CENTER, CENTER);
   *    text(getAudioContext().state, width/2, height/2);
   *  }
   *  function mousePressed() {
   *    userStartAudio();
   *  }
   *  </code></div>
   */


  p5.prototype.userStartAudio = function (elements, callback) {
    var elt = elements;

    if (elements instanceof p5.Element) {
      elt = elements.elt;
    } else if (elements instanceof Array && elements[0] instanceof p5.Element) {
      elt = elements.map(function (e) {
        return e.elt;
      });
    }

    return StartAudioContext(audiocontext, elt, callback);
  };

  return audiocontext;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}.call(this, __webpack_require__(34)))

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){"use strict";return o.Emitter=function(){this._events={}},o.extend(o.Emitter),o.Emitter.prototype.on=function(t,e){for(var i=t.split(/\W+/),r=0;r<i.length;r++){var n=i[r];this._events.hasOwnProperty(n)||(this._events[n]=[]),this._events[n].push(e)}return this},o.Emitter.prototype.off=function(t,e){for(var i=t.split(/\W+/),r=0;r<i.length;r++)if(t=i[r],this._events.hasOwnProperty(t))if(o.prototype.isUndef(e))this._events[t]=[];else for(var n=this._events[t],s=0;s<n.length;s++)n[s]===e&&n.splice(s,1);return this},o.Emitter.prototype.emit=function(t){if(this._events){var e=Array.apply(null,arguments).slice(1);if(this._events.hasOwnProperty(t))for(var i=this._events[t],r=0,n=i.length;r<n;r++)i[r].apply(this,e)}return this},o.Emitter.mixin=function(t){var e=["on","off","emit"];t._events={};for(var i=0;i<e.length;i++){var r=e[i],n=o.Emitter.prototype[r];t[r]=n}},o.Emitter.prototype.dispose=function(){return o.prototype.dispose.call(this),this._events=null,this},o.Emitter}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(c){"use strict";return c.SignalBase=function(){},c.extend(c.SignalBase),c.SignalBase.prototype.connect=function(e,n,a){return c.Signal&&c.Signal===e.constructor||c.Param&&c.Param===e.constructor||c.TimelineSignal&&c.TimelineSignal===e.constructor?(e._param.cancelScheduledValues(0),e._param.value=0,e.overridden=!0):e instanceof AudioParam&&(e.cancelScheduledValues(0),e.value=0),c.prototype.connect.call(this,e,n,a),this},c.SignalBase}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){return o.Time=function(t,e){if(!(this instanceof o.Time))return new o.Time(t,e);this._plusNow=!1,o.TimeBase.call(this,t,e)},o.extend(o.Time,o.TimeBase),o.Time.prototype._unaryExpressions=Object.create(o.TimeBase.prototype._unaryExpressions),o.Time.prototype._unaryExpressions.quantize={regexp:/^@/,method:function(t){return o.Transport.nextSubdivision(t())}},o.Time.prototype._unaryExpressions.now={regexp:/^\+/,method:function(t){return this._plusNow=!0,t()}},o.Time.prototype.quantize=function(t,e){return e=this.defaultArg(e,1),this._expr=function(t,e,o){return t=t(),e=e.toSeconds(),t+(Math.round(t/e)*e-t)*o}.bind(this,this._expr,new this.constructor(t),e),this},o.Time.prototype.addNow=function(){return this._plusNow=!0,this},o.Time.prototype._defaultExpr=function(){return this._plusNow=!0,this._noOp},o.Time.prototype.copy=function(t){return o.TimeBase.prototype.copy.call(this,t),this._plusNow=t._plusNow,this},o.Time.prototype.toNotation=function(){var t=this.toSeconds(),e=this._toNotationHelper(t,["1m","2n","4n","8n","16n","32n","64n","128n"]),o=this._toNotationHelper(t,["1m","2n","2t","4n","4t","8n","8t","16n","16t","32n","32t","64n","64t","128n"]);return o.split("+").length<e.split("+").length?o:e},o.Time.prototype._toNotationHelper=function(t,e){for(var o=this._notationToUnits(e[e.length-1]),n="",i=0;i<e.length;i++){var r=this._notationToUnits(e[i]),s=t/r;if(1-s%1<1e-6&&(s+=1e-6),0<(s=Math.floor(s))){if(n+=1===s?e[i]:s.toString()+"*"+e[i],(t-=s*r)<o)break;n+=" + "}}return""===n&&(n="0"),n},o.Time.prototype._notationToUnits=function(t){for(var e=this._primaryExpressions,o=[e.n,e.t,e.m],n=0;n<o.length;n++){var i=o[n],r=t.match(i.regexp);if(r)return i.method.call(this,r[1])}},o.Time.prototype.toBarsBeatsSixteenths=function(){var t=this._beatsToUnits(1),e=this.toSeconds()/t,o=Math.floor(e/this._timeSignature()),n=e%1*4;return e=Math.floor(e)%this._timeSignature(),3<(n=n.toString()).length&&(n=parseFloat(n).toFixed(3)),[o,e,n].join(":")},o.Time.prototype.toTicks=function(){var t=this._beatsToUnits(1),e=this.valueOf()/t;return Math.floor(e*o.Transport.PPQ)},o.Time.prototype.toSamples=function(){return this.toSeconds()*this.context.sampleRate},o.Time.prototype.toFrequency=function(){return 1/this.toSeconds()},o.Time.prototype.toSeconds=function(){return this.valueOf()},o.Time.prototype.toMilliseconds=function(){return 1e3*this.toSeconds()},o.Time.prototype.valueOf=function(){return this._expr()+(this._plusNow?this.now():0)},o.Time}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(n){return n.TimeBase=function(e,t){if(!(this instanceof n.TimeBase))return new n.TimeBase(e,t);if(this._expr=this._noOp,e instanceof n.TimeBase)this.copy(e);else if(!this.isUndef(t)||this.isNumber(e)){t=this.defaultArg(t,this._defaultUnits);var r=this._primaryExpressions[t].method;this._expr=r.bind(this,e)}else this.isString(e)?this.set(e):this.isUndef(e)&&(this._expr=this._defaultExpr())},n.extend(n.TimeBase),n.TimeBase.prototype.set=function(e){return this._expr=this._parseExprString(e),this},n.TimeBase.prototype.clone=function(){var e=new this.constructor;return e.copy(this),e},n.TimeBase.prototype.copy=function(e){var t=e._expr();return this.set(t)},n.TimeBase.prototype._primaryExpressions={n:{regexp:/^(\d+)n/i,method:function(e){return 1===(e=parseInt(e))?this._beatsToUnits(this._timeSignature()):this._beatsToUnits(4/e)}},t:{regexp:/^(\d+)t/i,method:function(e){return e=parseInt(e),this._beatsToUnits(8/(3*parseInt(e)))}},m:{regexp:/^(\d+)m/i,method:function(e){return this._beatsToUnits(parseInt(e)*this._timeSignature())}},i:{regexp:/^(\d+)i/i,method:function(e){return this._ticksToUnits(parseInt(e))}},hz:{regexp:/^(\d+(?:\.\d+)?)hz/i,method:function(e){return this._frequencyToUnits(parseFloat(e))}},tr:{regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,method:function(e,t,r){var n=0;return e&&"0"!==e&&(n+=this._beatsToUnits(this._timeSignature()*parseFloat(e))),t&&"0"!==t&&(n+=this._beatsToUnits(parseFloat(t))),r&&"0"!==r&&(n+=this._beatsToUnits(parseFloat(r)/4)),n}},s:{regexp:/^(\d+(?:\.\d+)?s)/,method:function(e){return this._secondsToUnits(parseFloat(e))}},samples:{regexp:/^(\d+)samples/,method:function(e){return parseInt(e)/this.context.sampleRate}},default:{regexp:/^(\d+(?:\.\d+)?)/,method:function(e){return this._primaryExpressions[this._defaultUnits].method.call(this,e)}}},n.TimeBase.prototype._binaryExpressions={"+":{regexp:/^\+/,precedence:2,method:function(e,t){return e()+t()}},"-":{regexp:/^\-/,precedence:2,method:function(e,t){return e()-t()}},"*":{regexp:/^\*/,precedence:1,method:function(e,t){return e()*t()}},"/":{regexp:/^\//,precedence:1,method:function(e,t){return e()/t()}}},n.TimeBase.prototype._unaryExpressions={neg:{regexp:/^\-/,method:function(e){return-e()}}},n.TimeBase.prototype._syntaxGlue={"(":{regexp:/^\(/},")":{regexp:/^\)/}},n.TimeBase.prototype._tokenize=function(e){for(var t=-1,r=[];0<e.length;){var n=i(e=e.trim(),this);r.push(n),e=e.substr(n.value.length)}function i(e,t){for(var r=["_binaryExpressions","_unaryExpressions","_primaryExpressions","_syntaxGlue"],n=0;n<r.length;n++){var i=t[r[n]];for(var s in i){var o=i[s],p=o.regexp,a=e.match(p);if(null!==a)return{method:o.method,precedence:o.precedence,regexp:o.regexp,value:a[0]}}}throw new SyntaxError("Tone.TimeBase: Unexpected token "+e)}return{next:function(){return r[++t]},peek:function(){return r[t+1]}}},n.TimeBase.prototype._matchGroup=function(e,t,r){if(!this.isUndef(e))for(var n in t){var i=t[n];if(i.regexp.test(e.value)){if(this.isUndef(r))return i;if(i.precedence===r)return i}}return!1},n.TimeBase.prototype._parseBinary=function(e,t){var r;this.isUndef(t)&&(t=2),r=t<0?this._parseUnary(e):this._parseBinary(e,t-1);for(var n=e.peek();n&&this._matchGroup(n,this._binaryExpressions,t);)r=(n=e.next()).method.bind(this,r,this._parseBinary(e,t-1)),n=e.peek();return r},n.TimeBase.prototype._parseUnary=function(e){var t,r;t=e.peek();var n=this._matchGroup(t,this._unaryExpressions);return n?(t=e.next(),r=this._parseUnary(e),n.method.bind(this,r)):this._parsePrimary(e)},n.TimeBase.prototype._parsePrimary=function(e){var t,r;if(t=e.peek(),this.isUndef(t))throw new SyntaxError("Tone.TimeBase: Unexpected end of expression");if(this._matchGroup(t,this._primaryExpressions)){var n=(t=e.next()).value.match(t.regexp);return t.method.bind(this,n[1],n[2],n[3])}if(t&&"("===t.value){if(e.next(),r=this._parseBinary(e),!(t=e.next())||")"!==t.value)throw new SyntaxError("Expected )");return r}throw new SyntaxError("Tone.TimeBase: Cannot process token "+t.value)},n.TimeBase.prototype._parseExprString=function(e){this.isString(e)||(e=e.toString());var t=this._tokenize(e);return this._parseBinary(t)},n.TimeBase.prototype._noOp=function(){return 0},n.TimeBase.prototype._defaultExpr=function(){return this._noOp},n.TimeBase.prototype._defaultUnits="s",n.TimeBase.prototype._frequencyToUnits=function(e){return 1/e},n.TimeBase.prototype._beatsToUnits=function(e){return 60/n.Transport.bpm.value*e},n.TimeBase.prototype._secondsToUnits=function(e){return e},n.TimeBase.prototype._ticksToUnits=function(e){return e*(this._beatsToUnits(1)/n.Transport.PPQ)},n.TimeBase.prototype._timeSignature=function(){return n.Transport.timeSignature},n.TimeBase.prototype._pushExpr=function(e,t,r){return e instanceof n.TimeBase||(e=new this.constructor(e,r)),this._expr=this._binaryExpressions[t].method.bind(this,this._expr,e._expr),this},n.TimeBase.prototype.add=function(e,t){return this._pushExpr(e,"+",t)},n.TimeBase.prototype.sub=function(e,t){return this._pushExpr(e,"-",t)},n.TimeBase.prototype.mult=function(e,t){return this._pushExpr(e,"*",t)},n.TimeBase.prototype.div=function(e,t){return this._pushExpr(e,"/",t)},n.TimeBase.prototype.valueOf=function(){return this._expr()},n.TimeBase.prototype.dispose=function(){this._expr=null},n.TimeBase}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(a){"use strict";return a.Param=function(){var t=this.optionsObject(arguments,["param","units","convert"],a.Param.defaults);this._param=this.input=t.param,this.units=t.units,this.convert=t.convert,this.overridden=!1,this._lfo=null,this.isObject(t.lfo)?this.value=t.lfo:this.isUndef(t.value)||(this.value=t.value)},a.extend(a.Param),a.Param.defaults={units:a.Type.Default,convert:!0,param:void 0},Object.defineProperty(a.Param.prototype,"value",{get:function(){return this._toUnits(this._param.value)},set:function(t){if(this.isObject(t)){if(this.isUndef(a.LFO))throw new Error("Include 'Tone.LFO' to use an LFO as a Param value.");this._lfo&&this._lfo.dispose(),this._lfo=new a.LFO(t).start(),this._lfo.connect(this.input)}else{var e=this._fromUnits(t);this._param.cancelScheduledValues(0),this._param.value=e}}}),a.Param.prototype._fromUnits=function(t){if(!this.convert&&!this.isUndef(this.convert))return t;switch(this.units){case a.Type.Time:return this.toSeconds(t);case a.Type.Frequency:return this.toFrequency(t);case a.Type.Decibels:return this.dbToGain(t);case a.Type.NormalRange:return Math.min(Math.max(t,0),1);case a.Type.AudioRange:return Math.min(Math.max(t,-1),1);case a.Type.Positive:return Math.max(t,0);default:return t}},a.Param.prototype._toUnits=function(t){if(!this.convert&&!this.isUndef(this.convert))return t;switch(this.units){case a.Type.Decibels:return this.gainToDb(t);default:return t}},a.Param.prototype._minOutput=1e-5,a.Param.prototype.setValueAtTime=function(t,e){return t=this._fromUnits(t),(e=this.toSeconds(e))<=this.now()+this.blockTime?this._param.value=t:this._param.setValueAtTime(t,e),this},a.Param.prototype.setRampPoint=function(t){t=this.defaultArg(t,this.now());var e=this._param.value;return 0===e&&(e=this._minOutput),this._param.setValueAtTime(e,t),this},a.Param.prototype.linearRampToValueAtTime=function(t,e){return t=this._fromUnits(t),this._param.linearRampToValueAtTime(t,this.toSeconds(e)),this},a.Param.prototype.exponentialRampToValueAtTime=function(t,e){return t=this._fromUnits(t),t=Math.max(this._minOutput,t),this._param.exponentialRampToValueAtTime(t,this.toSeconds(e)),this},a.Param.prototype.exponentialRampToValue=function(t,e,i){return i=this.toSeconds(i),this.setRampPoint(i),this.exponentialRampToValueAtTime(t,i+this.toSeconds(e)),this},a.Param.prototype.linearRampToValue=function(t,e,i){return i=this.toSeconds(i),this.setRampPoint(i),this.linearRampToValueAtTime(t,i+this.toSeconds(e)),this},a.Param.prototype.setTargetAtTime=function(t,e,i){return t=this._fromUnits(t),t=Math.max(this._minOutput,t),i=Math.max(this._minOutput,i),this._param.setTargetAtTime(t,this.toSeconds(e),i),this},a.Param.prototype.setValueCurveAtTime=function(t,e,i){for(var a=0;a<t.length;a++)t[a]=this._fromUnits(t[a]);return this._param.setValueCurveAtTime(t,this.toSeconds(e),this.toSeconds(i)),this},a.Param.prototype.cancelScheduledValues=function(t){return this._param.cancelScheduledValues(this.toSeconds(t)),this},a.Param.prototype.rampTo=function(t,e,i){return e=this.defaultArg(e,0),this.units===a.Type.Frequency||this.units===a.Type.BPM||this.units===a.Type.Decibels?this.exponentialRampToValue(t,e,i):this.linearRampToValue(t,e,i),this},Object.defineProperty(a.Param.prototype,"lfo",{get:function(){return this._lfo}}),a.Param.prototype.dispose=function(){return a.prototype.dispose.call(this),this._param=null,this._lfo&&(this._lfo.dispose(),this._lfo=null),this},a.Param}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var Add = __webpack_require__(7);

  var Mult = __webpack_require__(3);

  var Scale = __webpack_require__(13);
  /**
   *  <p>Creates a signal that oscillates between -1.0 and 1.0.
   *  By default, the oscillation takes the form of a sinusoidal
   *  shape ('sine'). Additional types include 'triangle',
   *  'sawtooth' and 'square'. The frequency defaults to
   *  440 oscillations per second (440Hz, equal to the pitch of an
   *  'A' note).</p>
   *
   *  <p>Set the type of oscillation with setType(), or by instantiating a
   *  specific oscillator: <a href="/reference/#/p5.SinOsc">p5.SinOsc</a>, <a
   *  href="/reference/#/p5.TriOsc">p5.TriOsc</a>, <a
   *  href="/reference/#/p5.SqrOsc">p5.SqrOsc</a>, or <a
   *  href="/reference/#/p5.SawOsc">p5.SawOsc</a>.
   *  </p>
   *
   *  @class p5.Oscillator
   *  @constructor
   *  @param {Number} [freq] frequency defaults to 440Hz
   *  @param {String} [type] type of oscillator. Options:
   *                         'sine' (default), 'triangle',
   *                         'sawtooth', 'square'
   *  @example
   *  <div><code>
   *  let osc, playing, freq, amp;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playOscillator);
   *    osc = new p5.Oscillator('sine');
   *  }
   *
   *  function draw() {
   *    background(220)
   *    freq = constrain(map(mouseX, 0, width, 100, 500), 100, 500);
   *    amp = constrain(map(mouseY, height, 0, 0, 1), 0, 1);
   *
   *    text('tap to play', 20, 20);
   *    text('freq: ' + freq, 20, 40);
   *    text('amp: ' + amp, 20, 60);
   *
   *    if (playing) {
   *      // smooth the transitions by 0.1 seconds
   *      osc.freq(freq, 0.1);
   *      osc.amp(amp, 0.1);
   *    }
   *  }
   *
   *  function playOscillator() {
   *    // starting an oscillator on a user gesture will enable audio
   *    // in browsers that have a strict autoplay policy.
   *    // See also: userStartAudio();
   *    osc.start();
   *    playing = true;
   *  }
   *
   *  function mouseReleased() {
   *    // ramp amplitude to 0 over 0.5 seconds
   *    osc.amp(0, 0.5);
   *    playing = false;
   *  }
   *  </code> </div>
   */


  p5.Oscillator = function (freq, type) {
    if (typeof freq === 'string') {
      var f = type;
      type = freq;
      freq = f;
    }

    if (typeof type === 'number') {
      var f = type;
      type = freq;
      freq = f;
    }

    this.started = false; 

    this.phaseAmount = undefined;
    this.oscillator = p5sound.audiocontext.createOscillator();
    this.f = freq || 440.0; 

    this.oscillator.type = type || 'sine';
    this.oscillator.frequency.setValueAtTime(this.f, p5sound.audiocontext.currentTime); 

    this.output = p5sound.audiocontext.createGain();
    this._freqMods = []; 

    this.output.gain.value = 0.5;
    this.output.gain.setValueAtTime(0.5, p5sound.audiocontext.currentTime);
    this.oscillator.connect(this.output); 

    this.panPosition = 0.0;
    this.connection = p5sound.input; 

    this.panner = new p5.Panner(this.output, this.connection, 1); 

    this.mathOps = [this.output]; 

    p5sound.soundArray.push(this);
  };
  /**
   *  Start an oscillator.
   *
   *  Starting an oscillator on a user gesture will enable audio in browsers
   *  that have a strict autoplay policy, including Chrome and most mobile
   *  devices. See also: `userStartAudio()`.
   *
   *  @method  start
   *  @for p5.Oscillator
   *  @param  {Number} [time] startTime in seconds from now.
   *  @param  {Number} [frequency] frequency in Hz.
   */


  p5.Oscillator.prototype.start = function (time, f) {
    if (this.started) {
      var now = p5sound.audiocontext.currentTime;
      this.stop(now);
    }

    if (!this.started) {
      var freq = f || this.f;
      var type = this.oscillator.type; 

      if (this.oscillator) {
        this.oscillator.disconnect();
        delete this.oscillator;
      } 


      this.oscillator = p5sound.audiocontext.createOscillator();
      this.oscillator.frequency.value = Math.abs(freq);
      this.oscillator.type = type; 

      this.oscillator.connect(this.output);
      time = time || 0;
      this.oscillator.start(time + p5sound.audiocontext.currentTime);
      this.freqNode = this.oscillator.frequency; 

      for (var i in this._freqMods) {
        if (typeof this._freqMods[i].connect !== 'undefined') {
          this._freqMods[i].connect(this.oscillator.frequency);
        }
      }

      this.started = true;
    }
  };
  /**
   *  Stop an oscillator. Accepts an optional parameter
   *  to determine how long (in seconds from now) until the
   *  oscillator stops.
   *
   *  @method  stop
   *  @for p5.Oscillator
   *  @param  {Number} secondsFromNow Time, in seconds from now.
   */


  p5.Oscillator.prototype.stop = function (time) {
    if (this.started) {
      var t = time || 0;
      var now = p5sound.audiocontext.currentTime;
      this.oscillator.stop(t + now);
      this.started = false;
    }
  };
  /**
   *  Set the amplitude between 0 and 1.0. Or, pass in an object
   *  such as an oscillator to modulate amplitude with an audio signal.
   *
   *  @method  amp
   *  @for p5.Oscillator
   *  @param  {Number|Object} vol between 0 and 1.0
   *                              or a modulating signal/oscillator
   *  @param {Number} [rampTime] create a fade that lasts rampTime
   *  @param {Number} [timeFromNow] schedule this event to happen
   *                                seconds from now
   *  @return  {AudioParam} gain  If no value is provided,
   *                              returns the Web Audio API
   *                              AudioParam that controls
   *                              this oscillator's
   *                              gain/amplitude/volume)
   */


  p5.Oscillator.prototype.amp = function (vol, rampTime, tFromNow) {
    var self = this;

    if (typeof vol === 'number') {
      var rampTime = rampTime || 0;
      var tFromNow = tFromNow || 0;
      var now = p5sound.audiocontext.currentTime;
      this.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime);
    } else if (vol) {
      vol.connect(self.output.gain);
    } else {
      return this.output.gain;
    }
  }; 


  p5.Oscillator.prototype.fade = p5.Oscillator.prototype.amp;

  p5.Oscillator.prototype.getAmp = function () {
    return this.output.gain.value;
  };
  /**
   *  Set frequency of an oscillator to a value. Or, pass in an object
   *  such as an oscillator to modulate the frequency with an audio signal.
   *
   *  @method  freq
   *  @for p5.Oscillator
   *  @param  {Number|Object} Frequency Frequency in Hz
   *                                        or modulating signal/oscillator
   *  @param  {Number} [rampTime] Ramp time (in seconds)
   *  @param  {Number} [timeFromNow] Schedule this event to happen
   *                                   at x seconds from now
   *  @return  {AudioParam} Frequency If no value is provided,
   *                                  returns the Web Audio API
   *                                  AudioParam that controls
   *                                  this oscillator's frequency
   *  @example
   *  <div><code>
   *  let osc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playOscillator);
   *    osc = new p5.Oscillator(300);
   *    background(220);
   *    text('tap to play', 20, 20);
   *  }
   *
   *  function playOscillator() {
   *    osc.start();
   *    osc.amp(0.5);
   *    // start at 700Hz
   *    osc.freq(700);
   *    // ramp to 60Hz over 0.7 seconds
   *    osc.freq(60, 0.7);
   *    osc.amp(0, 0.1, 0.7);
   *  }
   *  </code></div>
   */


  p5.Oscillator.prototype.freq = function (val, rampTime, tFromNow) {
    if (typeof val === 'number' && !isNaN(val)) {
      this.f = val;
      var now = p5sound.audiocontext.currentTime;
      var rampTime = rampTime || 0;
      var tFromNow = tFromNow || 0;
      var t = now + tFromNow + rampTime; 

      if (rampTime === 0) {
        this.oscillator.frequency.setValueAtTime(val, tFromNow + now);
      } else {
        if (val > 0) {
          this.oscillator.frequency.exponentialRampToValueAtTime(val, tFromNow + rampTime + now);
        } else {
          this.oscillator.frequency.linearRampToValueAtTime(val, tFromNow + rampTime + now);
        }
      } 


      if (this.phaseAmount) {
        this.phase(this.phaseAmount);
      }
    } else if (val) {
      if (val.output) {
        val = val.output;
      }

      val.connect(this.oscillator.frequency); 

      this._freqMods.push(val);
    } else {
      return this.oscillator.frequency;
    }
  };

  p5.Oscillator.prototype.getFreq = function () {
    return this.oscillator.frequency.value;
  };
  /**
   *  Set type to 'sine', 'triangle', 'sawtooth' or 'square'.
   *
   *  @method  setType
   *  @for p5.Oscillator
   *  @param {String} type 'sine', 'triangle', 'sawtooth' or 'square'.
   */


  p5.Oscillator.prototype.setType = function (type) {
    this.oscillator.type = type;
  };

  p5.Oscillator.prototype.getType = function () {
    return this.oscillator.type;
  };
  /**
   *  Connect to a p5.sound / Web Audio object.
   *
   *  @method  connect
   *  @for p5.Oscillator
   *  @param  {Object} unit A p5.sound or Web Audio object
   */


  p5.Oscillator.prototype.connect = function (unit) {
    if (!unit) {
      this.panner.connect(p5sound.input);
    } else if (unit.hasOwnProperty('input')) {
      this.panner.connect(unit.input);
      this.connection = unit.input;
    } else {
      this.panner.connect(unit);
      this.connection = unit;
    }
  };
  /**
   *  Disconnect all outputs
   *
   *  @method  disconnect
   *  @for p5.Oscillator
   */


  p5.Oscillator.prototype.disconnect = function () {
    if (this.output) {
      this.output.disconnect();
    }

    if (this.panner) {
      this.panner.disconnect();

      if (this.output) {
        this.output.connect(this.panner);
      }
    }

    this.oscMods = [];
  };
  /**
   *  Pan between Left (-1) and Right (1)
   *
   *  @method  pan
   *  @for p5.Oscillator
   *  @param  {Number} panning Number between -1 and 1
   *  @param  {Number} timeFromNow schedule this event to happen
   *                                seconds from now
   */


  p5.Oscillator.prototype.pan = function (pval, tFromNow) {
    this.panPosition = pval;
    this.panner.pan(pval, tFromNow);
  };

  p5.Oscillator.prototype.getPan = function () {
    return this.panPosition;
  }; 


  p5.Oscillator.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);

    if (this.oscillator) {
      var now = p5sound.audiocontext.currentTime;
      this.stop(now);
      this.disconnect();
      this.panner = null;
      this.oscillator = null;
    } 


    if (this.osc2) {
      this.osc2.dispose();
    }
  };
  /**
   *  Set the phase of an oscillator between 0.0 and 1.0.
   *  In this implementation, phase is a delay time
   *  based on the oscillator's current frequency.
   *
   *  @method  phase
   *  @for p5.Oscillator
   *  @param  {Number} phase float between 0.0 and 1.0
   */


  p5.Oscillator.prototype.phase = function (p) {
    var delayAmt = p5.prototype.map(p, 0, 1.0, 0, 1 / this.f);
    var now = p5sound.audiocontext.currentTime;
    this.phaseAmount = p;

    if (!this.dNode) {
      this.dNode = p5sound.audiocontext.createDelay(); 

      this.oscillator.disconnect();
      this.oscillator.connect(this.dNode);
      this.dNode.connect(this.output);
    } 


    this.dNode.delayTime.setValueAtTime(delayAmt, now);
  }; 


  var sigChain = function sigChain(o, mathObj, thisChain, nextChain, type) {
    var chainSource = o.oscillator; 

    for (var i in o.mathOps) {
      if (o.mathOps[i] instanceof type) {
        chainSource.disconnect();
        o.mathOps[i].dispose();
        thisChain = i; 

        if (thisChain < o.mathOps.length - 2) {
          nextChain = o.mathOps[i + 1];
        }
      }
    }

    if (thisChain === o.mathOps.length - 1) {
      o.mathOps.push(nextChain);
    } 


    if (i > 0) {
      chainSource = o.mathOps[i - 1];
    }

    chainSource.disconnect();
    chainSource.connect(mathObj);
    mathObj.connect(nextChain);
    o.mathOps[thisChain] = mathObj;
    return o;
  };
  /**
   *  Add a value to the p5.Oscillator's output amplitude,
   *  and return the oscillator. Calling this method again
   *  will override the initial add() with a new value.
   *
   *  @method  add
   *  @for p5.Oscillator
   *  @param {Number} number Constant number to add
   *  @return {p5.Oscillator} Oscillator Returns this oscillator
   *                                     with scaled output
   *
   */


  p5.Oscillator.prototype.add = function (num) {
    var add = new Add(num);
    var thisChain = this.mathOps.length - 1;
    var nextChain = this.output;
    return sigChain(this, add, thisChain, nextChain, Add);
  };
  /**
   *  Multiply the p5.Oscillator's output amplitude
   *  by a fixed value (i.e. turn it up!). Calling this method
   *  again will override the initial mult() with a new value.
   *
   *  @method  mult
   *  @for p5.Oscillator
   *  @param {Number} number Constant number to multiply
   *  @return {p5.Oscillator} Oscillator Returns this oscillator
   *                                     with multiplied output
   */


  p5.Oscillator.prototype.mult = function (num) {
    var mult = new Mult(num);
    var thisChain = this.mathOps.length - 1;
    var nextChain = this.output;
    return sigChain(this, mult, thisChain, nextChain, Mult);
  };
  /**
   *  Scale this oscillator's amplitude values to a given
   *  range, and return the oscillator. Calling this method
   *  again will override the initial scale() with new values.
   *
   *  @method  scale
   *  @for p5.Oscillator
   *  @param  {Number} inMin  input range minumum
   *  @param  {Number} inMax  input range maximum
   *  @param  {Number} outMin input range minumum
   *  @param  {Number} outMax input range maximum
   *  @return {p5.Oscillator} Oscillator Returns this oscillator
   *                                     with scaled output
   */


  p5.Oscillator.prototype.scale = function (inMin, inMax, outMin, outMax) {
    var mapOutMin, mapOutMax;

    if (arguments.length === 4) {
      mapOutMin = p5.prototype.map(outMin, inMin, inMax, 0, 1) - 0.5;
      mapOutMax = p5.prototype.map(outMax, inMin, inMax, 0, 1) - 0.5;
    } else {
      mapOutMin = arguments[0];
      mapOutMax = arguments[1];
    }

    var scale = new Scale(mapOutMin, mapOutMax);
    var thisChain = this.mathOps.length - 1;
    var nextChain = this.output;
    return sigChain(this, scale, thisChain, nextChain, Scale); 
  }; 

  /**
   *  Constructor: <code>new p5.SinOsc()</code>.
   *  This creates a Sine Wave Oscillator and is
   *  equivalent to <code> new p5.Oscillator('sine')
   *  </code> or creating a p5.Oscillator and then calling
   *  its method <code>setType('sine')</code>.
   *  See p5.Oscillator for methods.
   *
   *  @class  p5.SinOsc
   *  @constructor
   *  @extends p5.Oscillator
   *  @param {Number} [freq] Set the frequency
   */


  p5.SinOsc = function (freq) {
    p5.Oscillator.call(this, freq, 'sine');
  };

  p5.SinOsc.prototype = Object.create(p5.Oscillator.prototype);
  /**
   *  Constructor: <code>new p5.TriOsc()</code>.
   *  This creates a Triangle Wave Oscillator and is
   *  equivalent to <code>new p5.Oscillator('triangle')
   *  </code> or creating a p5.Oscillator and then calling
   *  its method <code>setType('triangle')</code>.
   *  See p5.Oscillator for methods.
   *
   *  @class  p5.TriOsc
   *  @constructor
   *  @extends p5.Oscillator
   *  @param {Number} [freq] Set the frequency
   */

  p5.TriOsc = function (freq) {
    p5.Oscillator.call(this, freq, 'triangle');
  };

  p5.TriOsc.prototype = Object.create(p5.Oscillator.prototype);
  /**
   *  Constructor: <code>new p5.SawOsc()</code>.
   *  This creates a SawTooth Wave Oscillator and is
   *  equivalent to <code> new p5.Oscillator('sawtooth')
   *  </code> or creating a p5.Oscillator and then calling
   *  its method <code>setType('sawtooth')</code>.
   *  See p5.Oscillator for methods.
   *
   *  @class  p5.SawOsc
   *  @constructor
   *  @extends p5.Oscillator
   *  @param {Number} [freq] Set the frequency
   */

  p5.SawOsc = function (freq) {
    p5.Oscillator.call(this, freq, 'sawtooth');
  };

  p5.SawOsc.prototype = Object.create(p5.Oscillator.prototype);
  /**
   *  Constructor: <code>new p5.SqrOsc()</code>.
   *  This creates a Square Wave Oscillator and is
   *  equivalent to <code> new p5.Oscillator('square')
   *  </code> or creating a p5.Oscillator and then calling
   *  its method <code>setType('square')</code>.
   *  See p5.Oscillator for methods.
   *
   *  @class  p5.SqrOsc
   *  @constructor
   *  @extends p5.Oscillator
   *  @param {Number} [freq] Set the frequency
   */

  p5.SqrOsc = function (freq) {
    p5.Oscillator.call(this, freq, 'square');
  };

  p5.SqrOsc.prototype = Object.create(p5.Oscillator.prototype);
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){"use strict";return i.Timeline=function(){var e=this.optionsObject(arguments,["memory"],i.Timeline.defaults);this._timeline=[],this._toRemove=[],this._iterating=!1,this.memory=e.memory},i.extend(i.Timeline),i.Timeline.defaults={memory:1/0},Object.defineProperty(i.Timeline.prototype,"length",{get:function(){return this._timeline.length}}),i.Timeline.prototype.add=function(e){if(this.isUndef(e.time))throw new Error("Tone.Timeline: events must have a time attribute");if(this._timeline.length){var i=this._search(e.time);this._timeline.splice(i+1,0,e)}else this._timeline.push(e);if(this.length>this.memory){var t=this.length-this.memory;this._timeline.splice(0,t)}return this},i.Timeline.prototype.remove=function(e){if(this._iterating)this._toRemove.push(e);else{var i=this._timeline.indexOf(e);-1!==i&&this._timeline.splice(i,1)}return this},i.Timeline.prototype.get=function(e){var i=this._search(e);return-1!==i?this._timeline[i]:null},i.Timeline.prototype.peek=function(){return this._timeline[0]},i.Timeline.prototype.shift=function(){return this._timeline.shift()},i.Timeline.prototype.getAfter=function(e){var i=this._search(e);return i+1<this._timeline.length?this._timeline[i+1]:null},i.Timeline.prototype.getBefore=function(e){var i=this._timeline.length;if(0<i&&this._timeline[i-1].time<e)return this._timeline[i-1];var t=this._search(e);return 0<=t-1?this._timeline[t-1]:null},i.Timeline.prototype.cancel=function(e){if(1<this._timeline.length){var i=this._search(e);if(0<=i)if(this._timeline[i].time===e){for(var t=i;0<=t&&this._timeline[t].time===e;t--)i=t;this._timeline=this._timeline.slice(0,i)}else this._timeline=this._timeline.slice(0,i+1);else this._timeline=[]}else 1===this._timeline.length&&this._timeline[0].time>=e&&(this._timeline=[]);return this},i.Timeline.prototype.cancelBefore=function(e){if(this._timeline.length){var i=this._search(e);0<=i&&(this._timeline=this._timeline.slice(i+1))}return this},i.Timeline.prototype._search=function(e){var i=0,t=this._timeline.length,n=t;if(0<t&&this._timeline[t-1].time<=e)return t-1;for(;i<n;){var r=Math.floor(i+(n-i)/2),s=this._timeline[r],h=this._timeline[r+1];if(s.time===e){for(var l=r;l<this._timeline.length;l++){this._timeline[l].time===e&&(r=l)}return r}if(s.time<e&&h.time>e)return r;s.time>e?n=r:s.time<e&&(i=r+1)}return-1},i.Timeline.prototype._iterate=function(e,i,t){this._iterating=!0,i=this.defaultArg(i,0),t=this.defaultArg(t,this._timeline.length-1);for(var n=i;n<=t;n++)e(this._timeline[n]);if(this._iterating=!1,0<this._toRemove.length){for(var r=0;r<this._toRemove.length;r++){var s=this._timeline.indexOf(this._toRemove[r]);-1!==s&&this._timeline.splice(s,1)}this._toRemove=[]}},i.Timeline.prototype.forEach=function(e){return this._iterate(e),this},i.Timeline.prototype.forEachBefore=function(e,i){var t=this._search(e);return-1!==t&&this._iterate(i,0,t),this},i.Timeline.prototype.forEachAfter=function(e,i){var t=this._search(e);return this._iterate(i,t+1),this},i.Timeline.prototype.forEachFrom=function(e,i){for(var t=this._search(e);0<=t&&this._timeline[t].time>=e;)t--;return this._iterate(i,t+1),this},i.Timeline.prototype.forEachAtTime=function(i,t){var e=this._search(i);return-1!==e&&this._iterate(function(e){e.time===i&&t(e)},0,e),this},i.Timeline.prototype.dispose=function(){i.prototype.dispose.call(this),this._timeline=null,this._toRemove=null},i.Timeline}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(3),__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(t){"use strict";return t.Negate=function(){this._multiply=this.input=this.output=new t.Multiply(-1)},t.extend(t.Negate,t.SignalBase),t.Negate.prototype.dispose=function(){return t.prototype.dispose.call(this),this._multiply.dispose(),this._multiply=null,this},t.Negate}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(2),__webpack_require__(3),__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(e){"use strict";return e.GreaterThanZero=function(){this._thresh=this.output=new e.WaveShaper(function(e){return e<=0?0:1},127),this._scale=this.input=new e.Multiply(1e4),this._scale.connect(this._thresh)},e.extend(e.GreaterThanZero,e.SignalBase),e.GreaterThanZero.prototype.dispose=function(){return e.prototype.dispose.call(this),this._scale.dispose(),this._scale=null,this._thresh.dispose(),this._thresh=null,this},e.GreaterThanZero}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(14),__webpack_require__(66),__webpack_require__(18),__webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){"use strict";return o.Clock=function(){o.Emitter.call(this);var t=this.optionsObject(arguments,["callback","frequency"],o.Clock.defaults);this.callback=t.callback,this._nextTick=0,this._lastState=o.State.Stopped,this.frequency=new o.TimelineSignal(t.frequency,o.Type.Frequency),this._readOnly("frequency"),this.ticks=0,this._state=new o.TimelineState(o.State.Stopped),this._boundLoop=this._loop.bind(this),this.context.on("tick",this._boundLoop)},o.extend(o.Clock,o.Emitter),o.Clock.defaults={callback:o.noOp,frequency:1,lookAhead:"auto"},Object.defineProperty(o.Clock.prototype,"state",{get:function(){return this._state.getValueAtTime(this.now())}}),o.Clock.prototype.start=function(t,e){return t=this.toSeconds(t),this._state.getValueAtTime(t)!==o.State.Started&&this._state.add({state:o.State.Started,time:t,offset:e}),this},o.Clock.prototype.stop=function(t){return t=this.toSeconds(t),this._state.cancel(t),this._state.setStateAtTime(o.State.Stopped,t),this},o.Clock.prototype.pause=function(t){return t=this.toSeconds(t),this._state.getValueAtTime(t)===o.State.Started&&this._state.setStateAtTime(o.State.Paused,t),this},o.Clock.prototype._loop=function(){for(var t=this.now()+this.context.lookAhead+this.context.updateInterval+2*this.context.lag;t>this._nextTick&&this._state;){var e=this._state.getValueAtTime(this._nextTick);if(e!==this._lastState){this._lastState=e;var i=this._state.get(this._nextTick);e===o.State.Started?(this._nextTick=i.time,this.isUndef(i.offset)||(this.ticks=i.offset),this.emit("start",i.time,this.ticks)):e===o.State.Stopped?(this.ticks=0,this.emit("stop",i.time)):e===o.State.Paused&&this.emit("pause",i.time)}var s=this._nextTick;this.frequency&&(this._nextTick+=1/this.frequency.getValueAtTime(this._nextTick),e===o.State.Started&&(this.callback(s),this.ticks++))}},o.Clock.prototype.getStateAtTime=function(t){return t=this.toSeconds(t),this._state.getValueAtTime(t)},o.Clock.prototype.dispose=function(){o.Emitter.prototype.dispose.call(this),this.context.off("tick",this._boundLoop),this._writable("frequency"),this.frequency.dispose(),this.frequency=null,this._boundLoop=null,this._nextTick=1/0,this.callback=null,this._state.dispose(),this._state=null},o.Clock}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var AudioVoice = __webpack_require__(29);

  var noteToFreq = __webpack_require__(6).noteToFreq;

  var DEFAULT_SUSTAIN = 0.15;
  /**
    *  A MonoSynth is used as a single voice for sound synthesis.
    *  This is a class to be used in conjunction with the PolySynth
    *  class. Custom synthetisers should be built inheriting from
    *  this class.
    *
    *  @class p5.MonoSynth
    *  @constructor
    *  @example
    *  <div><code>
    *  let monoSynth;
    *
    *  function setup() {
    *    let cnv = createCanvas(100, 100);
    *    cnv.mousePressed(playSynth);
    *    background(220);
    *    textAlign(CENTER);
    *    text('tap to play', width/2, height/2);
    *
    *    monoSynth = new p5.MonoSynth();
    *  }
    *
    *  function playSynth() {
    *    userStartAudio();
    *
    *    let note = random(['Fb4', 'G4']);
    *    // note velocity (volume, from 0 to 1)
    *    let velocity = random();
    *    // time from now (in seconds)
    *    let time = 0;
    *    // note duration (in seconds)
    *    let dur = 1/6;
    *
    *    monoSynth.play(note, velocity, time, dur);
    *  }
    *  </code></div>
    **/

  p5.MonoSynth = function () {
    AudioVoice.call(this);
    this.oscillator = new p5.Oscillator();
    this.env = new p5.Envelope();
    this.env.setRange(1, 0);
    this.env.setExp(true); 

    this.setADSR(0.02, 0.25, 0.05, 0.35); 

    this.oscillator.disconnect();
    this.oscillator.connect(this.output);
    this.env.disconnect();
    this.env.setInput(this.output.gain); 

    this.oscillator.output.gain.value = 1.0;
    this.oscillator.start();
    this.connect();
    p5sound.soundArray.push(this);
  };

  p5.MonoSynth.prototype = Object.create(p5.AudioVoice.prototype);
  /**
    *  Play tells the MonoSynth to start playing a note. This method schedules
    *  the calling of .triggerAttack and .triggerRelease.
    *
    *  @method play
    *  @for p5.MonoSynth
    *  @param {String | Number} note the note you want to play, specified as a
    *                                 frequency in Hertz (Number) or as a midi
    *                                 value in Note/Octave format ("C4", "Eb3"...etc")
    *                                 See <a href = "https://github.com/Tonejs/Tone.js/wiki/Instruments">
    *                                 Tone</a>. Defaults to 440 hz.
    *  @param  {Number} [velocity] velocity of the note to play (ranging from 0 to 1)
    *  @param  {Number} [secondsFromNow]  time from now (in seconds) at which to play
    *  @param  {Number} [sustainTime] time to sustain before releasing the envelope. Defaults to 0.15 seconds.
    *  @example
    *  <div><code>
    *  let monoSynth;
    *
    *  function setup() {
    *    let cnv = createCanvas(100, 100);
    *    cnv.mousePressed(playSynth);
    *    background(220);
    *    textAlign(CENTER);
    *    text('tap to play', width/2, height/2);
    *
    *    monoSynth = new p5.MonoSynth();
    *  }
    *
    *  function playSynth() {
    *    userStartAudio();
    *
    *    let note = random(['Fb4', 'G4']);
    *    // note velocity (volume, from 0 to 1)
    *    let velocity = random();
    *    // time from now (in seconds)
    *    let time = 0;
    *    // note duration (in seconds)
    *    let dur = 1/6;
    *
    *    monoSynth.play(note, velocity, time, dur);
    *  }
    *  </code></div>
    *
    */

  p5.MonoSynth.prototype.play = function (note, velocity, secondsFromNow, susTime) {
    this.triggerAttack(note, velocity, ~~secondsFromNow);
    this.triggerRelease(~~secondsFromNow + (susTime || DEFAULT_SUSTAIN));
  };
  /**
     *  Trigger the Attack, and Decay portion of the Envelope.
     *  Similar to holding down a key on a piano, but it will
     *  hold the sustain level until you let go.
     *
     *  @param {String | Number} note the note you want to play, specified as a
     *                                 frequency in Hertz (Number) or as a midi
     *                                 value in Note/Octave format ("C4", "Eb3"...etc")
     *                                 See <a href = "https://github.com/Tonejs/Tone.js/wiki/Instruments">
     *                                 Tone</a>. Defaults to 440 hz
     *  @param  {Number} [velocity] velocity of the note to play (ranging from 0 to 1)
     *  @param  {Number} [secondsFromNow]  time from now (in seconds) at which to play
     *  @method  triggerAttack
     *  @for p5.MonoSynth
     *  @example
     *  <div><code>
     *  let monoSynth;
     *
     *  function setup() {
     *    let cnv = createCanvas(100, 100);
     *    cnv.mousePressed(triggerAttack);
     *    background(220);
     *    text('tap here for attack, let go to release', 5, 20, width - 20);
     *    monoSynth = new p5.MonoSynth();
     *  }
     *
     *  function triggerAttack() {
     *    userStartAudio();
     *
     *    monoSynth.triggerAttack("E3");
     *  }
     *
     *  function mouseReleased() {
     *    monoSynth.triggerRelease();
     *  }
     *  </code></div>
     */


  p5.MonoSynth.prototype.triggerAttack = function (note, velocity, secondsFromNow) {
    var secondsFromNow = ~~secondsFromNow;
    var freq = noteToFreq(note);
    var vel = velocity || 0.1;
    this.oscillator.freq(freq, 0, secondsFromNow);
    this.env.ramp(this.output.gain, secondsFromNow, vel);
  };
  /**
     *  Trigger the release of the Envelope. This is similar to releasing
     *  the key on a piano and letting the sound fade according to the
     *  release level and release time.
     *
     *  @param  {Number} secondsFromNow time to trigger the release
     *  @method  triggerRelease
     *  @for p5.MonoSynth
     *  @example
     *  <div><code>
     *  let monoSynth;
     *
     *  function setup() {
     *    let cnv = createCanvas(100, 100);
     *    cnv.mousePressed(triggerAttack);
     *    background(220);
     *    text('tap here for attack, let go to release', 5, 20, width - 20);
     *    monoSynth = new p5.MonoSynth();
     *  }
     *
     *  function triggerAttack() {
     *    userStartAudio();
     *
     *    monoSynth.triggerAttack("E3");
     *  }
     *
     *  function mouseReleased() {
     *    monoSynth.triggerRelease();
     *  }
     *  </code></div>
     */


  p5.MonoSynth.prototype.triggerRelease = function (secondsFromNow) {
    var secondsFromNow = secondsFromNow || 0;
    this.env.ramp(this.output.gain, secondsFromNow, 0);
  };
  /**
     *  Set values like a traditional
     *  <a href="https://en.wikipedia.org/wiki/Synthesizer#/media/File:ADSR_parameter.svg">
     *  ADSR envelope
     *  </a>.
     *
     *  @method  setADSR
     *  @for p5.MonoSynth
     *  @param {Number} attackTime    Time (in seconds before envelope
     *                                reaches Attack Level
     *  @param {Number} [decayTime]    Time (in seconds) before envelope
     *                                reaches Decay/Sustain Level
     *  @param {Number} [susRatio]    Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,
     *                                where 1.0 = attackLevel, 0.0 = releaseLevel.
     *                                The susRatio determines the decayLevel and the level at which the
     *                                sustain portion of the envelope will sustain.
     *                                For example, if attackLevel is 0.4, releaseLevel is 0,
     *                                and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is
     *                                increased to 1.0 (using <code>setRange</code>),
     *                                then decayLevel would increase proportionally, to become 0.5.
     *  @param {Number} [releaseTime]   Time in seconds from now (defaults to 0)
     */


  p5.MonoSynth.prototype.setADSR = function (attack, decay, sustain, release) {
    this.env.setADSR(attack, decay, sustain, release);
  };
  /**
   * Getters and Setters
   * @property {Number} attack
   * @for p5.MonoSynth
   */

  /**
   * @property {Number} decay
   * @for p5.MonoSynth
   */

  /**
   * @property {Number} sustain
   * @for p5.MonoSynth
   */

  /**
   * @property {Number} release
   * @for p5.MonoSynth
   */


  Object.defineProperties(p5.MonoSynth.prototype, {
    'attack': {
      get: function get() {
        return this.env.aTime;
      },
      set: function set(attack) {
        this.env.setADSR(attack, this.env.dTime, this.env.sPercent, this.env.rTime);
      }
    },
    'decay': {
      get: function get() {
        return this.env.dTime;
      },
      set: function set(decay) {
        this.env.setADSR(this.env.aTime, decay, this.env.sPercent, this.env.rTime);
      }
    },
    'sustain': {
      get: function get() {
        return this.env.sPercent;
      },
      set: function set(sustain) {
        this.env.setADSR(this.env.aTime, this.env.dTime, sustain, this.env.rTime);
      }
    },
    'release': {
      get: function get() {
        return this.env.rTime;
      },
      set: function set(release) {
        this.env.setADSR(this.env.aTime, this.env.dTime, this.env.sPercent, release);
      }
    }
  });
  /**
   * MonoSynth amp
   * @method  amp
   * @for p5.MonoSynth
   * @param  {Number} vol      desired volume
   * @param  {Number} [rampTime] Time to reach new volume
   * @return {Number}          new volume value
   */

  p5.MonoSynth.prototype.amp = function (vol, rampTime) {
    var t = rampTime || 0;

    if (typeof vol !== 'undefined') {
      this.oscillator.amp(vol, t);
    }

    return this.oscillator.amp().value;
  };
  /**
   *  Connect to a p5.sound / Web Audio object.
   *
   *  @method  connect
   *  @for p5.MonoSynth
   *  @param  {Object} unit A p5.sound or Web Audio object
   */


  p5.MonoSynth.prototype.connect = function (unit) {
    var u = unit || p5sound.input;
    this.output.connect(u.input ? u.input : u);
  };
  /**
   *  Disconnect all outputs
   *
   *  @method  disconnect
   *  @for p5.MonoSynth
   */


  p5.MonoSynth.prototype.disconnect = function () {
    if (this.output) {
      this.output.disconnect();
    }
  };
  /**
   *  Get rid of the MonoSynth and free up its resources / memory.
   *
   *  @method  dispose
   *  @for p5.MonoSynth
   */


  p5.MonoSynth.prototype.dispose = function () {
    AudioVoice.prototype.dispose.apply(this);

    if (this.env) {
      this.env.dispose();
    }

    if (this.oscillator) {
      this.oscillator.dispose();
    }
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  var p5sound = __webpack_require__(1);
  /**
   * Base class for monophonic synthesizers. Any extensions of this class
   * should follow the API and implement the methods below in order to
   * remain compatible with p5.PolySynth();
   *
   * @class p5.AudioVoice
   * @constructor
   */


  p5.AudioVoice = function () {
    this.ac = p5sound.audiocontext;
    this.output = this.ac.createGain();
    this.connect();
    p5sound.soundArray.push(this);
  };

  p5.AudioVoice.prototype.play = function (note, velocity, secondsFromNow, sustime) {};

  p5.AudioVoice.prototype.triggerAttack = function (note, velocity, secondsFromNow) {};

  p5.AudioVoice.prototype.triggerRelease = function (secondsFromNow) {};

  p5.AudioVoice.prototype.amp = function (vol, rampTime) {};
  /**
   * Connect to p5 objects or Web Audio Nodes
   * @method  connect
   * @for p5.AudioVoice
   * @param {Object} unit
   */


  p5.AudioVoice.prototype.connect = function (unit) {
    var u = unit || p5sound.input;
    this.output.connect(u.input ? u.input : u);
  };
  /**
   * Disconnect from soundOut
   * @method  disconnect
   * @for p5.AudioVoice
   */


  p5.AudioVoice.prototype.disconnect = function () {
    this.output.disconnect();
  };

  p5.AudioVoice.prototype.dispose = function () {
    if (this.output) {
      this.output.disconnect();
      delete this.output;
    }
  };

  return p5.AudioVoice;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var TimelineSignal = __webpack_require__(14);

  var noteToFreq = __webpack_require__(6).noteToFreq;
  /**
    *  An AudioVoice is used as a single voice for sound synthesis.
    *  The PolySynth class holds an array of AudioVoice, and deals
    *  with voices allocations, with setting notes to be played, and
    *  parameters to be set.
    *
    *  @class p5.PolySynth
    *  @constructor
    *
    *  @param {Number} [synthVoice]   A monophonic synth voice inheriting
    *                                 the AudioVoice class. Defaults to p5.MonoSynth
    *  @param {Number} [maxVoices] Number of voices, defaults to 8;
    *  @example
    *  <div><code>
    *  let polySynth;
    *
    *  function setup() {
    *    let cnv = createCanvas(100, 100);
    *    cnv.mousePressed(playSynth);
    *    background(220);
    *    text('click to play', 20, 20);
    *
    *    polySynth = new p5.PolySynth();
    *  }
    *
    *  function playSynth() {
    *    userStartAudio();
    *
    *    // note duration (in seconds)
    *    let dur = 1.5;
    *
    *    // time from now (in seconds)
    *    let time = 0;
    *
    *    // velocity (volume, from 0 to 1)
    *    let vel = 0.1;
    *
    *    // notes can overlap with each other
    *    polySynth.play('G2', vel, 0, dur);
    *    polySynth.play('C3', vel, time += 1/3, dur);
    *    polySynth.play('G3', vel, time += 1/3, dur);
    *  }
    *  </code></div>
    **/


  p5.PolySynth = function (audioVoice, maxVoices) {
    this.audiovoices = [];
    /**
     * An object that holds information about which notes have been played and
     * which notes are currently being played. New notes are added as keys
     * on the fly. While a note has been attacked, but not released, the value of the
     * key is the audiovoice which is generating that note. When notes are released,
     * the value of the key becomes undefined.
     * @property notes
     */

    this.notes = {}; 

    this._newest = 0;
    this._oldest = 0;
    /**
     * A PolySynth must have at least 1 voice, defaults to 8
     * @property polyvalue
     */

    this.maxVoices = maxVoices || 8;
    /**
     * Monosynth that generates the sound for each note that is triggered. The
     * p5.PolySynth defaults to using the p5.MonoSynth as its voice.
     * @property AudioVoice
     */

    this.AudioVoice = audioVoice === undefined ? p5.MonoSynth : audioVoice;
    /**
     * This value must only change as a note is attacked or released. Due to delay
     * and sustain times, Tone.TimelineSignal is required to schedule the change in value.
    * @private
     * @property {Tone.TimelineSignal} _voicesInUse
     */

    this._voicesInUse = new TimelineSignal(0);
    this.output = p5sound.audiocontext.createGain();
    this.connect(); 

    this._allocateVoices();

    p5sound.soundArray.push(this);
  };
  /**
   * Construct the appropriate number of audiovoices
   * @private
   * @for p5.PolySynth
   * @method  _allocateVoices
   */


  p5.PolySynth.prototype._allocateVoices = function () {
    for (var i = 0; i < this.maxVoices; i++) {
      this.audiovoices.push(new this.AudioVoice());
      this.audiovoices[i].disconnect();
      this.audiovoices[i].connect(this.output);
    }
  };
  /**
   *  Play a note by triggering noteAttack and noteRelease with sustain time
   *
   *  @method  play
   *  @for p5.PolySynth
   *  @param  {Number} [note] midi note to play (ranging from 0 to 127 - 60 being a middle C)
   *  @param  {Number} [velocity] velocity of the note to play (ranging from 0 to 1)
   *  @param  {Number} [secondsFromNow]  time from now (in seconds) at which to play
   *  @param  {Number} [sustainTime] time to sustain before releasing the envelope
   *  @example
   *  <div><code>
   *  let polySynth;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playSynth);
   *    background(220);
   *    text('click to play', 20, 20);
   *
   *    polySynth = new p5.PolySynth();
   *  }
   *
   *  function playSynth() {
   *    userStartAudio();
   *
   *    // note duration (in seconds)
   *    let dur = 1.5;
   *
   *    // time from now (in seconds)
   *    let time = 0;
   *
   *    // velocity (volume, from 0 to 1)
   *    let vel = 0.1;
   *
   *    // notes can overlap with each other
   *    polySynth.play('G2', vel, 0, dur);
   *    polySynth.play('C3', vel, time += 1/3, dur);
   *    polySynth.play('G3', vel, time += 1/3, dur);
   *  }
   *  </code></div>
   */


  p5.PolySynth.prototype.play = function (note, velocity, secondsFromNow, susTime) {
    var susTime = susTime || 1;
    this.noteAttack(note, velocity, secondsFromNow);
    this.noteRelease(note, secondsFromNow + susTime);
  };
  /**
   *  noteADSR sets the envelope for a specific note that has just been triggered.
   *  Using this method modifies the envelope of whichever audiovoice is being used
   *  to play the desired note. The envelope should be reset before noteRelease is called
   *  in order to prevent the modified envelope from being used on other notes.
   *
   *  @method  noteADSR
   *  @for p5.PolySynth
   *  @param {Number} [note]        Midi note on which ADSR should be set.
   *  @param {Number} [attackTime]  Time (in seconds before envelope
   *                                reaches Attack Level
   *  @param {Number} [decayTime]   Time (in seconds) before envelope
   *                                reaches Decay/Sustain Level
   *  @param {Number} [susRatio]    Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,
   *                                where 1.0 = attackLevel, 0.0 = releaseLevel.
   *                                The susRatio determines the decayLevel and the level at which the
   *                                sustain portion of the envelope will sustain.
   *                                For example, if attackLevel is 0.4, releaseLevel is 0,
   *                                and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is
   *                                increased to 1.0 (using <code>setRange</code>),
   *                                then decayLevel would increase proportionally, to become 0.5.
   *  @param {Number} [releaseTime]   Time in seconds from now (defaults to 0)
   **/


  p5.PolySynth.prototype.noteADSR = function (note, a, d, s, r, timeFromNow) {
    var now = p5sound.audiocontext.currentTime;
    var timeFromNow = timeFromNow || 0;
    var t = now + timeFromNow;
    this.audiovoices[this.notes[note].getValueAtTime(t)].setADSR(a, d, s, r);
  };
  /**
   * Set the PolySynths global envelope. This method modifies the envelopes of each
   * monosynth so that all notes are played with this envelope.
   *
   *  @method  setADSR
   *  @for p5.PolySynth
   *  @param {Number} [attackTime]  Time (in seconds before envelope
   *                                reaches Attack Level
   *  @param {Number} [decayTime]   Time (in seconds) before envelope
   *                                reaches Decay/Sustain Level
   *  @param {Number} [susRatio]    Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,
   *                                where 1.0 = attackLevel, 0.0 = releaseLevel.
   *                                The susRatio determines the decayLevel and the level at which the
   *                                sustain portion of the envelope will sustain.
   *                                For example, if attackLevel is 0.4, releaseLevel is 0,
   *                                and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is
   *                                increased to 1.0 (using <code>setRange</code>),
   *                                then decayLevel would increase proportionally, to become 0.5.
   *  @param {Number} [releaseTime]   Time in seconds from now (defaults to 0)
   **/


  p5.PolySynth.prototype.setADSR = function (a, d, s, r) {
    this.audiovoices.forEach(function (voice) {
      voice.setADSR(a, d, s, r);
    });
  };
  /**
   *  Trigger the Attack, and Decay portion of a MonoSynth.
   *  Similar to holding down a key on a piano, but it will
   *  hold the sustain level until you let go.
   *
   *  @method  noteAttack
   *  @for p5.PolySynth
   *  @param  {Number} [note]           midi note on which attack should be triggered.
   *  @param  {Number} [velocity]       velocity of the note to play (ranging from 0 to 1)/
   *  @param  {Number} [secondsFromNow] time from now (in seconds)
   *  @example
   *  <div><code>
   *  let polySynth = new p5.PolySynth();
   *  let pitches = ['G', 'D', 'G', 'C'];
   *  let octaves = [2, 3, 4];
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playChord);
   *    background(220);
   *    text('tap to play', 20, 20);
   *  }
   *
   *  function playChord() {
   *    userStartAudio();
   *
   *    // play a chord: multiple notes at the same time
   *    for (let i = 0; i < 4; i++) {
   *      let note = random(pitches) + random(octaves);
   *      polySynth.noteAttack(note, 0.1);
   *    }
   *  }
   *
   *  function mouseReleased() {
   *    // release all voices
   *    polySynth.noteRelease();
   *  }
   *  </code></div>
   */


  p5.PolySynth.prototype.noteAttack = function (_note, _velocity, secondsFromNow) {
    var secondsFromNow = ~~secondsFromNow; 

    var acTime = p5sound.audiocontext.currentTime + secondsFromNow; 

    var note = noteToFreq(_note);
    var velocity = _velocity || 0.1;
    var currentVoice; 

    if (this.notes[note] && this.notes[note].getValueAtTime(acTime) !== null) {
      this.noteRelease(note, 0);
    } 


    if (this._voicesInUse.getValueAtTime(acTime) < this.maxVoices) {
      currentVoice = Math.max(~~this._voicesInUse.getValueAtTime(acTime), 0);
    } 
    else {
        currentVoice = this._oldest;
        var oldestNote = p5.prototype.freqToMidi(this.audiovoices[this._oldest].oscillator.freq().value);
        this.noteRelease(oldestNote);
        this._oldest = (this._oldest + 1) % (this.maxVoices - 1);
      } 


    this.notes[note] = new TimelineSignal();
    this.notes[note].setValueAtTime(currentVoice, acTime); 

    var previousVal = this._voicesInUse._searchBefore(acTime) === null ? 0 : this._voicesInUse._searchBefore(acTime).value;

    this._voicesInUse.setValueAtTime(previousVal + 1, acTime); 


    this._updateAfter(acTime, 1);

    this._newest = currentVoice; 

    if (typeof velocity === 'number') {
      var maxRange = 1 / this._voicesInUse.getValueAtTime(acTime) * 2;
      velocity = velocity > maxRange ? maxRange : velocity;
    }

    this.audiovoices[currentVoice].triggerAttack(note, velocity, secondsFromNow);
  };
  /**
   * Private method to ensure accurate values of this._voicesInUse
   * Any time a new value is scheduled, it is necessary to increment all subsequent
   * scheduledValues after attack, and decrement all subsequent
   * scheduledValues after release
   *
   * @private
   * @for p5.PolySynth
   * @param  {[type]} time  [description]
   * @param  {[type]} value [description]
   * @return {[type]}       [description]
   */


  p5.PolySynth.prototype._updateAfter = function (time, value) {
    if (this._voicesInUse._searchAfter(time) === null) {
      return;
    } else {
      this._voicesInUse._searchAfter(time).value += value;

      var nextTime = this._voicesInUse._searchAfter(time).time;

      this._updateAfter(nextTime, value);
    }
  };
  /**
   *  Trigger the Release of an AudioVoice note. This is similar to releasing
   *  the key on a piano and letting the sound fade according to the
   *  release level and release time.
   *
   *  @method  noteRelease
   *  @for p5.PolySynth
   *  @param  {Number} [note]           midi note on which attack should be triggered.
   *                                    If no value is provided, all notes will be released.
   *  @param  {Number} [secondsFromNow] time to trigger the release
   *  @example
   *  <div><code>
   *  let polySynth = new p5.PolySynth();
   *  let pitches = ['G', 'D', 'G', 'C'];
   *  let octaves = [2, 3, 4];
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playChord);
   *    background(220);
   *    text('tap to play', 20, 20);
   *  }
   *
   *  function playChord() {
   *    userStartAudio();
   *
   *    // play a chord: multiple notes at the same time
   *    for (let i = 0; i < 4; i++) {
   *      let note = random(pitches) + random(octaves);
   *      polySynth.noteAttack(note, 0.1);
   *    }
   *  }
   *
   *  function mouseReleased() {
   *    // release all voices
   *    polySynth.noteRelease();
   *  }
   *  </code></div>
   *
   */


  p5.PolySynth.prototype.noteRelease = function (_note, secondsFromNow) {
    var now = p5sound.audiocontext.currentTime;
    var tFromNow = secondsFromNow || 0;
    var t = now + tFromNow; 

    if (!_note) {
      this.audiovoices.forEach(function (voice) {
        voice.triggerRelease(tFromNow);
      });

      this._voicesInUse.setValueAtTime(0, t);

      for (var n in this.notes) {
        this.notes[n].dispose();
        delete this.notes[n];
      }

      return;
    } 


    var note = noteToFreq(_note);

    if (!this.notes[note] || this.notes[note].getValueAtTime(t) === null) {
      console.warn('Cannot release a note that is not already playing');
    } else {
      var previousVal = Math.max(~~this._voicesInUse.getValueAtTime(t).value, 1);

      this._voicesInUse.setValueAtTime(previousVal - 1, t); 


      if (previousVal > 0) {
        this._updateAfter(t, -1);
      }

      this.audiovoices[this.notes[note].getValueAtTime(t)].triggerRelease(tFromNow);
      this.notes[note].dispose();
      delete this.notes[note];
      this._newest = this._newest === 0 ? 0 : (this._newest - 1) % (this.maxVoices - 1);
    }
  };
  /**
    *  Connect to a p5.sound / Web Audio object.
    *
    *  @method  connect
    *  @for p5.PolySynth
    *  @param  {Object} unit A p5.sound or Web Audio object
    */


  p5.PolySynth.prototype.connect = function (unit) {
    var u = unit || p5sound.input;
    this.output.connect(u.input ? u.input : u);
  };
  /**
  *  Disconnect all outputs
  *
  *  @method  disconnect
  *  @for p5.PolySynth
  */


  p5.PolySynth.prototype.disconnect = function () {
    if (this.output) {
      this.output.disconnect();
    }
  };
  /**
    *  Get rid of the MonoSynth and free up its resources / memory.
    *
    *  @method  dispose
    *  @for p5.PolySynth
    */


  p5.PolySynth.prototype.dispose = function () {
    this.audiovoices.forEach(function (voice) {
      voice.dispose();
    });

    if (this.output) {
      this.output.disconnect();
      delete this.output;
    }
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  __webpack_require__(32);

  __webpack_require__(33);

  __webpack_require__(17);

  var p5SOUND = __webpack_require__(1);

  __webpack_require__(6);

  __webpack_require__(11);

  __webpack_require__(36);

  __webpack_require__(40);

  __webpack_require__(41);

  __webpack_require__(42);

  __webpack_require__(43);

  __webpack_require__(44);

  __webpack_require__(23);

  __webpack_require__(47);

  __webpack_require__(48);

  __webpack_require__(49);

  __webpack_require__(50);

  __webpack_require__(15);

  __webpack_require__(59);

  __webpack_require__(61);

  __webpack_require__(62);

  __webpack_require__(63);

  __webpack_require__(64);

  __webpack_require__(65);

  __webpack_require__(67);

  __webpack_require__(68);

  __webpack_require__(69);

  __webpack_require__(70);

  __webpack_require__(71);

  __webpack_require__(72);

  __webpack_require__(28);

  __webpack_require__(30);

  __webpack_require__(73);

  __webpack_require__(29);

  __webpack_require__(28);

  __webpack_require__(30);

  return p5SOUND;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports) {

!function(){var l,s=[];function p(e){var o=this,n={},i=-1;this.parameters.forEach(function(e,t){var r=s[++i]||(s[i]=new Float32Array(o.bufferSize));r.fill(e.value),n[t]=r}),this.processor.realm.exec("self.sampleRate=sampleRate="+this.context.sampleRate+";self.currentTime=currentTime="+this.context.currentTime);var t=a(e.inputBuffer),r=a(e.outputBuffer);this.instance.process([t],[r],n)}function a(e){for(var t=[],r=0;r<e.numberOfChannels;r++)t[r]=e.getChannelData(r);return t}function f(e){return e.$$processors||(e.$$processors={})}function e(e){this.$$context=e}"function"!=typeof AudioWorkletNode&&(self.AudioWorkletNode=function(e,t,r){var o=f(e)[t],n=e.createScriptProcessor(void 0,2,r&&r.outputChannelCount?r.outputChannelCount[0]:2);if(n.parameters=new Map,o.properties)for(var i=0;i<o.properties.length;i++){var s=o.properties[i],a=e.createGain().gain;a.value=s.defaultValue,n.parameters.set(s.name,a)}var u=new MessageChannel;l=u.port2;var c=new o.Processor(r||{});return l=null,n.port=u.port1,n.processor=o,n.instance=c,n.onaudioprocess=p,n},Object.defineProperty((self.AudioContext||self.webkitAudioContext).prototype,"audioWorklet",{get:function(){return this.$$audioWorklet||(this.$$audioWorklet=new self.AudioWorklet(this))}}),self.AudioWorklet=(e.prototype.addModule=function(e,t){var n=this;return fetch(e).then(function(e){if(!e.ok)throw Error(e.status);return e.text()}).then(function(e){var r={sampleRate:0,currentTime:0,AudioWorkletProcessor:function(){this.port=l},registerProcessor:function(e,t){f(n.$$context)[e]={realm:o,context:r,Processor:t,properties:t.parameterDescriptors||[]}}},o=new function(e,t){var r=document.createElement("iframe");r.style.cssText="position:absolute;left:0;top:-999px;width:1px;height:1px;",t.appendChild(r);var o=r.contentWindow,n=o.document,i="var window,$hook";for(var s in o)s in e||"eval"===s||(i+=",",i+=s);for(var a in e)i+=",",i+=a,i+="=self.",i+=a;var u=n.createElement("script");u.appendChild(n.createTextNode('function $hook(self,console) {"use strict";\n        '+i+";return function() {return eval(arguments[0])}}")),n.body.appendChild(u),this.exec=o.$hook(e,console)}(r.self=r,document.documentElement);return o.exec((t&&t.transpile||String)(e)),null})},e))}();

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;
/**
 * This module has shims
 */

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  (function () {
    function fixSetTarget(param) {
      if (!param) 
        return;
      if (!param.setTargetAtTime) param.setTargetAtTime = param.setTargetValueAtTime;
    }

    if (window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext')) {
      window.AudioContext = window.webkitAudioContext;
      if (typeof AudioContext.prototype.createGain !== 'function') AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
      if (typeof AudioContext.prototype.createDelay !== 'function') AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
      if (typeof AudioContext.prototype.createScriptProcessor !== 'function') AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
      if (typeof AudioContext.prototype.createPeriodicWave !== 'function') AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
      AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;

      AudioContext.prototype.createGain = function () {
        var node = this.internal_createGain();
        fixSetTarget(node.gain);
        return node;
      };

      AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;

      AudioContext.prototype.createDelay = function (maxDelayTime) {
        var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
        fixSetTarget(node.delayTime);
        return node;
      };

      AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;

      AudioContext.prototype.createBufferSource = function () {
        var node = this.internal_createBufferSource();

        if (!node.start) {
          node.start = function (when, offset, duration) {
            if (offset || duration) this.noteGrainOn(when || 0, offset, duration);else this.noteOn(when || 0);
          };
        } else {
          node.internal_start = node.start;

          node.start = function (when, offset, duration) {
            if (typeof duration !== 'undefined') node.internal_start(when || 0, offset, duration);else node.internal_start(when || 0, offset || 0);
          };
        }

        if (!node.stop) {
          node.stop = function (when) {
            this.noteOff(when || 0);
          };
        } else {
          node.internal_stop = node.stop;

          node.stop = function (when) {
            node.internal_stop(when || 0);
          };
        }

        fixSetTarget(node.playbackRate);
        return node;
      };

      AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;

      AudioContext.prototype.createDynamicsCompressor = function () {
        var node = this.internal_createDynamicsCompressor();
        fixSetTarget(node.threshold);
        fixSetTarget(node.knee);
        fixSetTarget(node.ratio);
        fixSetTarget(node.reduction);
        fixSetTarget(node.attack);
        fixSetTarget(node.release);
        return node;
      };

      AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;

      AudioContext.prototype.createBiquadFilter = function () {
        var node = this.internal_createBiquadFilter();
        fixSetTarget(node.frequency);
        fixSetTarget(node.detune);
        fixSetTarget(node.Q);
        fixSetTarget(node.gain);
        return node;
      };

      if (typeof AudioContext.prototype.createOscillator !== 'function') {
        AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;

        AudioContext.prototype.createOscillator = function () {
          var node = this.internal_createOscillator();

          if (!node.start) {
            node.start = function (when) {
              this.noteOn(when || 0);
            };
          } else {
            node.internal_start = node.start;

            node.start = function (when) {
              node.internal_start(when || 0);
            };
          }

          if (!node.stop) {
            node.stop = function (when) {
              this.noteOff(when || 0);
            };
          } else {
            node.internal_stop = node.stop;

            node.stop = function (when) {
              node.internal_stop(when || 0);
            };
          }

          if (!node.setPeriodicWave) node.setPeriodicWave = node.setWaveTable;
          fixSetTarget(node.frequency);
          fixSetTarget(node.detune);
          return node;
        };
      }
    }

    if (window.hasOwnProperty('webkitOfflineAudioContext') && !window.hasOwnProperty('OfflineAudioContext')) {
      window.OfflineAudioContext = window.webkitOfflineAudioContext;
    }
  })(window); 


  navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
  /**
   * Determine which filetypes are supported (inspired by buzz.js)
   * The audio element (el) will only be used to test browser support for various audio formats
   */

  var el = document.createElement('audio');

  p5.prototype.isSupported = function () {
    return !!el.canPlayType;
  };

  var isOGGSupported = function isOGGSupported() {
    return !!el.canPlayType && el.canPlayType('audio/ogg; codecs="vorbis"');
  };

  var isMP3Supported = function isMP3Supported() {
    return !!el.canPlayType && el.canPlayType('audio/mpeg;');
  };

  var isWAVSupported = function isWAVSupported() {
    return !!el.canPlayType && el.canPlayType('audio/wav; codecs="1"');
  };

  var isAACSupported = function isAACSupported() {
    return !!el.canPlayType && (el.canPlayType('audio/x-m4a;') || el.canPlayType('audio/aac;'));
  };

  var isAIFSupported = function isAIFSupported() {
    return !!el.canPlayType && el.canPlayType('audio/x-aiff;');
  };

  p5.prototype.isFileSupported = function (extension) {
    switch (extension.toLowerCase()) {
      case 'mp3':
        return isMP3Supported();

      case 'wav':
        return isWAVSupported();

      case 'ogg':
        return isOGGSupported();

      case 'aac':
      case 'm4a':
      case 'mp4':
        return isAACSupported();

      case 'aif':
      case 'aiff':
        return isAIFSupported();

      default:
        return false;
    }
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports) {

var g;g=function(){return this}();try{g=g||new Function("return this")()}catch(t){"object"==typeof window&&(g=window)}module.exports=g;

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(e,t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(this,function(){var r=function(e,t){this._dragged=!1,this._element=e,this._bindedMove=this._moved.bind(this),this._bindedEnd=this._ended.bind(this,t),e.addEventListener("touchstart",this._bindedEnd),e.addEventListener("touchmove",this._bindedMove),e.addEventListener("touchend",this._bindedEnd),e.addEventListener("mouseup",this._bindedEnd)};function o(e){return"running"===e.state}return r.prototype._moved=function(e){this._dragged=!0},r.prototype._ended=function(e){this._dragged||function(e){var t=e.createBuffer(1,1,e.sampleRate),n=e.createBufferSource();n.buffer=t,n.connect(e.destination),n.start(0),e.resume&&e.resume()}(e),this._dragged=!1},r.prototype.dispose=function(){this._element.removeEventListener("touchstart",this._bindedEnd),this._element.removeEventListener("touchmove",this._bindedMove),this._element.removeEventListener("touchend",this._bindedEnd),this._element.removeEventListener("mouseup",this._bindedEnd),this._bindedMove=null,this._bindedEnd=null,this._element=null},function(t,e,n){var i=new Promise(function(e){!function(t,n){o(t)?n():function e(){o(t)?n():(requestAnimationFrame(e),t.resume&&t.resume())}()}(t,e)}),d=[];return function e(t,n,i){if(Array.isArray(t)||NodeList&&t instanceof NodeList)for(var d=0;d<t.length;d++)e(t[d],n,i);else if("string"==typeof t)e(document.querySelectorAll(t),n,i);else if(t.jquery&&"function"==typeof t.toArray)e(t.toArray(),n,i);else if(Element&&t instanceof Element){var o=new r(t,i);n.push(o)}}(e=e||document.body,d,t),i.then(function(){for(var e=0;e<d.length;e++)d[e].dispose();d=null,n&&n()}),i}});

 }),
 (function(module, exports, __webpack_require__) {

var p5sound = __webpack_require__(1);

var moduleSources = [__webpack_require__(37)["default"], __webpack_require__(38)["default"], __webpack_require__(39)["default"]];
var ac = p5sound.audiocontext;
var initializedAudioWorklets = false;

function loadAudioWorkletModules() {
  return Promise.all(moduleSources.map(function (moduleSrc) {
    var blob = new Blob([moduleSrc], {
      type: 'application/javascript'
    });
    var objectURL = URL.createObjectURL(blob);
    return ac.audioWorklet.addModule(objectURL);
  }));
}

p5.prototype.registerMethod('init', function () {
  if (initializedAudioWorklets) return; 

  if (!this.preload && !window.preload) {
    this.preload = function () {};
  } 


  this._incrementPreload();

  var onWorkletModulesLoad = function () {
    initializedAudioWorklets = true;

    this._decrementPreload();
  }.bind(this);

  loadAudioWorkletModules().then(onWorkletModulesLoad);
});

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
 __webpack_exports__["default"] = ("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// import dependencies via preval.require so that they're available as values at compile time\nvar processorNames = {\n  \"recorderProcessor\": \"recorder-processor\",\n  \"soundFileProcessor\": \"sound-file-processor\",\n  \"amplitudeProcessor\": \"amplitude-processor\"\n};\nvar RingBuffer = {\n  \"default\":\n  /*#__PURE__*/\n  function () {\n    /**\n     * @constructor\n     * @param  {number} length Buffer length in frames.\n     * @param  {number} channelCount Buffer channel count.\n     */\n    function RingBuffer(length, channelCount) {\n      _classCallCheck(this, RingBuffer);\n\n      this._readIndex = 0;\n      this._writeIndex = 0;\n      this._framesAvailable = 0;\n      this._channelCount = channelCount;\n      this._length = length;\n      this._channelData = [];\n\n      for (var i = 0; i < this._channelCount; ++i) {\n        this._channelData[i] = new Float32Array(length);\n      }\n    }\n    /**\n     * Getter for Available frames in buffer.\n     *\n     * @return {number} Available frames in buffer.\n     */\n\n\n    _createClass(RingBuffer, [{\n      key: \"push\",\n\n      /**\n       * Push a sequence of Float32Arrays to buffer.\n       *\n       * @param  {array} arraySequence A sequence of Float32Arrays.\n       */\n      value: function push(arraySequence) {\n        // The channel count of arraySequence and the length of each channel must\n        // match with this buffer obejct.\n        // Transfer data from the |arraySequence| storage to the internal buffer.\n        var sourceLength = arraySequence[0].length;\n\n        for (var i = 0; i < sourceLength; ++i) {\n          var writeIndex = (this._writeIndex + i) % this._length;\n\n          for (var channel = 0; channel < this._channelCount; ++channel) {\n            this._channelData[channel][writeIndex] = arraySequence[channel][i];\n          }\n        }\n\n        this._writeIndex += sourceLength;\n\n        if (this._writeIndex >= this._length) {\n          this._writeIndex = 0;\n        } // For excessive frames, the buffer will be overwritten.\n\n\n        this._framesAvailable += sourceLength;\n\n        if (this._framesAvailable > this._length) {\n          this._framesAvailable = this._length;\n        }\n      }\n      /**\n       * Pull data out of buffer and fill a given sequence of Float32Arrays.\n       *\n       * @param  {array} arraySequence An array of Float32Arrays.\n       */\n\n    }, {\n      key: \"pull\",\n      value: function pull(arraySequence) {\n        // The channel count of arraySequence and the length of each channel must\n        // match with this buffer obejct.\n        // If the FIFO is completely empty, do nothing.\n        if (this._framesAvailable === 0) {\n          return;\n        }\n\n        var destinationLength = arraySequence[0].length; // Transfer data from the internal buffer to the |arraySequence| storage.\n\n        for (var i = 0; i < destinationLength; ++i) {\n          var readIndex = (this._readIndex + i) % this._length;\n\n          for (var channel = 0; channel < this._channelCount; ++channel) {\n            arraySequence[channel][i] = this._channelData[channel][readIndex];\n          }\n        }\n\n        this._readIndex += destinationLength;\n\n        if (this._readIndex >= this._length) {\n          this._readIndex = 0;\n        }\n\n        this._framesAvailable -= destinationLength;\n\n        if (this._framesAvailable < 0) {\n          this._framesAvailable = 0;\n        }\n      }\n    }, {\n      key: \"framesAvailable\",\n      get: function get() {\n        return this._framesAvailable;\n      }\n    }]);\n\n    return RingBuffer;\n  }()\n}[\"default\"];\n\nvar RecorderProcessor =\n/*#__PURE__*/\nfunction (_AudioWorkletProcesso) {\n  _inherits(RecorderProcessor, _AudioWorkletProcesso);\n\n  function RecorderProcessor(options) {\n    var _this;\n\n    _classCallCheck(this, RecorderProcessor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RecorderProcessor).call(this));\n    var processorOptions = options.processorOptions || {};\n    _this.numOutputChannels = options.outputChannelCount || 2;\n    _this.numInputChannels = processorOptions.numInputChannels || 2;\n    _this.bufferSize = processorOptions.bufferSize || 1024;\n    _this.recording = false;\n\n    _this.clear();\n\n    _this.port.onmessage = function (event) {\n      var data = event.data;\n\n      if (data.name === 'start') {\n        _this.record(data.duration);\n      } else if (data.name === 'stop') {\n        _this.stop();\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(RecorderProcessor, [{\n    key: \"process\",\n    value: function process(inputs) {\n      if (!this.recording) {\n        return true;\n      } else if (this.sampleLimit && this.recordedSamples >= this.sampleLimit) {\n        this.stop();\n        return true;\n      }\n\n      var input = inputs[0];\n      this.inputRingBuffer.push(input);\n\n      if (this.inputRingBuffer.framesAvailable >= this.bufferSize) {\n        this.inputRingBuffer.pull(this.inputRingBufferArraySequence);\n\n        for (var channel = 0; channel < this.numOutputChannels; ++channel) {\n          var inputChannelCopy = this.inputRingBufferArraySequence[channel].slice();\n\n          if (channel === 0) {\n            this.leftBuffers.push(inputChannelCopy);\n\n            if (this.numInputChannels === 1) {\n              this.rightBuffers.push(inputChannelCopy);\n            }\n          } else if (channel === 1 && this.numInputChannels > 1) {\n            this.rightBuffers.push(inputChannelCopy);\n          }\n        }\n\n        this.recordedSamples += this.bufferSize;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"record\",\n    value: function record(duration) {\n      if (duration) {\n        this.sampleLimit = Math.round(duration * sampleRate);\n      }\n\n      this.recording = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.recording = false;\n      var buffers = this.getBuffers();\n      var leftBuffer = buffers[0].buffer;\n      var rightBuffer = buffers[1].buffer;\n      this.port.postMessage({\n        name: 'buffers',\n        leftBuffer: leftBuffer,\n        rightBuffer: rightBuffer\n      }, [leftBuffer, rightBuffer]);\n      this.clear();\n    }\n  }, {\n    key: \"getBuffers\",\n    value: function getBuffers() {\n      var buffers = [];\n      buffers.push(this.mergeBuffers(this.leftBuffers));\n      buffers.push(this.mergeBuffers(this.rightBuffers));\n      return buffers;\n    }\n  }, {\n    key: \"mergeBuffers\",\n    value: function mergeBuffers(channelBuffer) {\n      var result = new Float32Array(this.recordedSamples);\n      var offset = 0;\n      var lng = channelBuffer.length;\n\n      for (var i = 0; i < lng; i++) {\n        var buffer = channelBuffer[i];\n        result.set(buffer, offset);\n        offset += buffer.length;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n\n      this.leftBuffers = [];\n      this.rightBuffers = [];\n      this.inputRingBuffer = new RingBuffer(this.bufferSize, this.numInputChannels);\n      this.inputRingBufferArraySequence = new Array(this.numInputChannels).fill(null).map(function () {\n        return new Float32Array(_this2.bufferSize);\n      });\n      this.recordedSamples = 0;\n      this.sampleLimit = null;\n    }\n  }]);\n\n  return RecorderProcessor;\n}(_wrapNativeSuper(AudioWorkletProcessor));\n\nregisterProcessor(processorNames.recorderProcessor, RecorderProcessor);");

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
 __webpack_exports__["default"] = ("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// import dependencies via preval.require so that they're available as values at compile time\nvar processorNames = {\n  \"recorderProcessor\": \"recorder-processor\",\n  \"soundFileProcessor\": \"sound-file-processor\",\n  \"amplitudeProcessor\": \"amplitude-processor\"\n};\nvar RingBuffer = {\n  \"default\":\n  /*#__PURE__*/\n  function () {\n    /**\n     * @constructor\n     * @param  {number} length Buffer length in frames.\n     * @param  {number} channelCount Buffer channel count.\n     */\n    function RingBuffer(length, channelCount) {\n      _classCallCheck(this, RingBuffer);\n\n      this._readIndex = 0;\n      this._writeIndex = 0;\n      this._framesAvailable = 0;\n      this._channelCount = channelCount;\n      this._length = length;\n      this._channelData = [];\n\n      for (var i = 0; i < this._channelCount; ++i) {\n        this._channelData[i] = new Float32Array(length);\n      }\n    }\n    /**\n     * Getter for Available frames in buffer.\n     *\n     * @return {number} Available frames in buffer.\n     */\n\n\n    _createClass(RingBuffer, [{\n      key: \"push\",\n\n      /**\n       * Push a sequence of Float32Arrays to buffer.\n       *\n       * @param  {array} arraySequence A sequence of Float32Arrays.\n       */\n      value: function push(arraySequence) {\n        // The channel count of arraySequence and the length of each channel must\n        // match with this buffer obejct.\n        // Transfer data from the |arraySequence| storage to the internal buffer.\n        var sourceLength = arraySequence[0].length;\n\n        for (var i = 0; i < sourceLength; ++i) {\n          var writeIndex = (this._writeIndex + i) % this._length;\n\n          for (var channel = 0; channel < this._channelCount; ++channel) {\n            this._channelData[channel][writeIndex] = arraySequence[channel][i];\n          }\n        }\n\n        this._writeIndex += sourceLength;\n\n        if (this._writeIndex >= this._length) {\n          this._writeIndex = 0;\n        } // For excessive frames, the buffer will be overwritten.\n\n\n        this._framesAvailable += sourceLength;\n\n        if (this._framesAvailable > this._length) {\n          this._framesAvailable = this._length;\n        }\n      }\n      /**\n       * Pull data out of buffer and fill a given sequence of Float32Arrays.\n       *\n       * @param  {array} arraySequence An array of Float32Arrays.\n       */\n\n    }, {\n      key: \"pull\",\n      value: function pull(arraySequence) {\n        // The channel count of arraySequence and the length of each channel must\n        // match with this buffer obejct.\n        // If the FIFO is completely empty, do nothing.\n        if (this._framesAvailable === 0) {\n          return;\n        }\n\n        var destinationLength = arraySequence[0].length; // Transfer data from the internal buffer to the |arraySequence| storage.\n\n        for (var i = 0; i < destinationLength; ++i) {\n          var readIndex = (this._readIndex + i) % this._length;\n\n          for (var channel = 0; channel < this._channelCount; ++channel) {\n            arraySequence[channel][i] = this._channelData[channel][readIndex];\n          }\n        }\n\n        this._readIndex += destinationLength;\n\n        if (this._readIndex >= this._length) {\n          this._readIndex = 0;\n        }\n\n        this._framesAvailable -= destinationLength;\n\n        if (this._framesAvailable < 0) {\n          this._framesAvailable = 0;\n        }\n      }\n    }, {\n      key: \"framesAvailable\",\n      get: function get() {\n        return this._framesAvailable;\n      }\n    }]);\n\n    return RingBuffer;\n  }()\n}[\"default\"];\n\nvar SoundFileProcessor =\n/*#__PURE__*/\nfunction (_AudioWorkletProcesso) {\n  _inherits(SoundFileProcessor, _AudioWorkletProcesso);\n\n  function SoundFileProcessor(options) {\n    var _this;\n\n    _classCallCheck(this, SoundFileProcessor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SoundFileProcessor).call(this));\n    var processorOptions = options.processorOptions || {};\n    _this.bufferSize = processorOptions.bufferSize || 256;\n    _this.inputRingBuffer = new RingBuffer(_this.bufferSize, 1);\n    _this.inputRingBufferArraySequence = [new Float32Array(_this.bufferSize)];\n    return _this;\n  }\n\n  _createClass(SoundFileProcessor, [{\n    key: \"process\",\n    value: function process(inputs) {\n      var input = inputs[0]; // we only care about the first input channel, because that contains the position data\n\n      this.inputRingBuffer.push([input[0]]);\n\n      if (this.inputRingBuffer.framesAvailable >= this.bufferSize) {\n        this.inputRingBuffer.pull(this.inputRingBufferArraySequence);\n        var inputChannel = this.inputRingBufferArraySequence[0];\n        var position = inputChannel[inputChannel.length - 1] || 0;\n        this.port.postMessage({\n          name: 'position',\n          position: position\n        });\n      }\n\n      return true;\n    }\n  }]);\n\n  return SoundFileProcessor;\n}(_wrapNativeSuper(AudioWorkletProcessor));\n\nregisterProcessor(processorNames.soundFileProcessor, SoundFileProcessor);");

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
 __webpack_exports__["default"] = ("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// import dependencies via preval.require so that they're available as values at compile time\nvar processorNames = {\n  \"recorderProcessor\": \"recorder-processor\",\n  \"soundFileProcessor\": \"sound-file-processor\",\n  \"amplitudeProcessor\": \"amplitude-processor\"\n};\nvar RingBuffer = {\n  \"default\":\n  /*#__PURE__*/\n  function () {\n    /**\n     * @constructor\n     * @param  {number} length Buffer length in frames.\n     * @param  {number} channelCount Buffer channel count.\n     */\n    function RingBuffer(length, channelCount) {\n      _classCallCheck(this, RingBuffer);\n\n      this._readIndex = 0;\n      this._writeIndex = 0;\n      this._framesAvailable = 0;\n      this._channelCount = channelCount;\n      this._length = length;\n      this._channelData = [];\n\n      for (var i = 0; i < this._channelCount; ++i) {\n        this._channelData[i] = new Float32Array(length);\n      }\n    }\n    /**\n     * Getter for Available frames in buffer.\n     *\n     * @return {number} Available frames in buffer.\n     */\n\n\n    _createClass(RingBuffer, [{\n      key: \"push\",\n\n      /**\n       * Push a sequence of Float32Arrays to buffer.\n       *\n       * @param  {array} arraySequence A sequence of Float32Arrays.\n       */\n      value: function push(arraySequence) {\n        // The channel count of arraySequence and the length of each channel must\n        // match with this buffer obejct.\n        // Transfer data from the |arraySequence| storage to the internal buffer.\n        var sourceLength = arraySequence[0].length;\n\n        for (var i = 0; i < sourceLength; ++i) {\n          var writeIndex = (this._writeIndex + i) % this._length;\n\n          for (var channel = 0; channel < this._channelCount; ++channel) {\n            this._channelData[channel][writeIndex] = arraySequence[channel][i];\n          }\n        }\n\n        this._writeIndex += sourceLength;\n\n        if (this._writeIndex >= this._length) {\n          this._writeIndex = 0;\n        } // For excessive frames, the buffer will be overwritten.\n\n\n        this._framesAvailable += sourceLength;\n\n        if (this._framesAvailable > this._length) {\n          this._framesAvailable = this._length;\n        }\n      }\n      /**\n       * Pull data out of buffer and fill a given sequence of Float32Arrays.\n       *\n       * @param  {array} arraySequence An array of Float32Arrays.\n       */\n\n    }, {\n      key: \"pull\",\n      value: function pull(arraySequence) {\n        // The channel count of arraySequence and the length of each channel must\n        // match with this buffer obejct.\n        // If the FIFO is completely empty, do nothing.\n        if (this._framesAvailable === 0) {\n          return;\n        }\n\n        var destinationLength = arraySequence[0].length; // Transfer data from the internal buffer to the |arraySequence| storage.\n\n        for (var i = 0; i < destinationLength; ++i) {\n          var readIndex = (this._readIndex + i) % this._length;\n\n          for (var channel = 0; channel < this._channelCount; ++channel) {\n            arraySequence[channel][i] = this._channelData[channel][readIndex];\n          }\n        }\n\n        this._readIndex += destinationLength;\n\n        if (this._readIndex >= this._length) {\n          this._readIndex = 0;\n        }\n\n        this._framesAvailable -= destinationLength;\n\n        if (this._framesAvailable < 0) {\n          this._framesAvailable = 0;\n        }\n      }\n    }, {\n      key: \"framesAvailable\",\n      get: function get() {\n        return this._framesAvailable;\n      }\n    }]);\n\n    return RingBuffer;\n  }()\n}[\"default\"];\n\nvar AmplitudeProcessor =\n/*#__PURE__*/\nfunction (_AudioWorkletProcesso) {\n  _inherits(AmplitudeProcessor, _AudioWorkletProcesso);\n\n  function AmplitudeProcessor(options) {\n    var _this;\n\n    _classCallCheck(this, AmplitudeProcessor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AmplitudeProcessor).call(this));\n    var processorOptions = options.processorOptions || {};\n    _this.numOutputChannels = options.outputChannelCount || 1;\n    _this.numInputChannels = processorOptions.numInputChannels || 2;\n    _this.normalize = processorOptions.normalize || false;\n    _this.smoothing = processorOptions.smoothing || 0;\n    _this.bufferSize = processorOptions.bufferSize || 2048;\n    _this.inputRingBuffer = new RingBuffer(_this.bufferSize, _this.numInputChannels);\n    _this.outputRingBuffer = new RingBuffer(_this.bufferSize, _this.numOutputChannels);\n    _this.inputRingBufferArraySequence = new Array(_this.numInputChannels).fill(null).map(function () {\n      return new Float32Array(_this.bufferSize);\n    });\n    _this.stereoVol = [0, 0];\n    _this.stereoVolNorm = [0, 0];\n    _this.volMax = 0.001;\n\n    _this.port.onmessage = function (event) {\n      var data = event.data;\n\n      if (data.name === 'toggleNormalize') {\n        _this.normalize = data.normalize;\n      } else if (data.name === 'smoothing') {\n        _this.smoothing = Math.max(0, Math.min(1, data.smoothing));\n      }\n    };\n\n    return _this;\n  } // TO DO make this stereo / dependent on # of audio channels\n\n\n  _createClass(AmplitudeProcessor, [{\n    key: \"process\",\n    value: function process(inputs, outputs) {\n      var input = inputs[0];\n      var output = outputs[0];\n      var smoothing = this.smoothing;\n      this.inputRingBuffer.push(input);\n\n      if (this.inputRingBuffer.framesAvailable >= this.bufferSize) {\n        this.inputRingBuffer.pull(this.inputRingBufferArraySequence);\n\n        for (var channel = 0; channel < this.numInputChannels; ++channel) {\n          var inputBuffer = this.inputRingBufferArraySequence[channel];\n          var bufLength = inputBuffer.length;\n          var sum = 0;\n\n          for (var i = 0; i < bufLength; i++) {\n            var x = inputBuffer[i];\n\n            if (this.normalize) {\n              sum += Math.max(Math.min(x / this.volMax, 1), -1) * Math.max(Math.min(x / this.volMax, 1), -1);\n            } else {\n              sum += x * x;\n            }\n          } // ... then take the square root of the sum.\n\n\n          var rms = Math.sqrt(sum / bufLength);\n          this.stereoVol[channel] = Math.max(rms, this.stereoVol[channel] * smoothing);\n          this.volMax = Math.max(this.stereoVol[channel], this.volMax);\n        } // calculate stero normalized volume and add volume from all channels together\n\n\n        var volSum = 0;\n\n        for (var index = 0; index < this.stereoVol.length; index++) {\n          this.stereoVolNorm[index] = Math.max(Math.min(this.stereoVol[index] / this.volMax, 1), 0);\n          volSum += this.stereoVol[index];\n        } // volume is average of channels\n\n\n        var volume = volSum / this.stereoVol.length; // normalized value\n\n        var volNorm = Math.max(Math.min(volume / this.volMax, 1), 0);\n        this.port.postMessage({\n          name: 'amplitude',\n          volume: volume,\n          volNorm: volNorm,\n          stereoVol: this.stereoVol,\n          stereoVolNorm: this.stereoVolNorm\n        }); // pass input through to output\n\n        this.outputRingBuffer.push(this.inputRingBufferArraySequence);\n      } // pull 128 frames out of the ring buffer\n      // if the ring buffer does not have enough frames, the output will be silent\n\n\n      this.outputRingBuffer.pull(output);\n      return true;\n    }\n  }]);\n\n  return AmplitudeProcessor;\n}(_wrapNativeSuper(AudioWorkletProcessor));\n\nregisterProcessor(processorNames.amplitudeProcessor, AmplitudeProcessor);");

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var ac = p5sound.audiocontext; 

  if (typeof ac.createStereoPanner !== 'undefined') {
    p5.Panner = function (input, output) {
      this.stereoPanner = this.input = ac.createStereoPanner();
      input.connect(this.stereoPanner);
      this.stereoPanner.connect(output);
    };

    p5.Panner.prototype.pan = function (val, tFromNow) {
      var time = tFromNow || 0;
      var t = ac.currentTime + time;
      this.stereoPanner.pan.linearRampToValueAtTime(val, t);
    }; 


    p5.Panner.prototype.inputChannels = function () {};

    p5.Panner.prototype.connect = function (obj) {
      this.stereoPanner.connect(obj);
    };

    p5.Panner.prototype.disconnect = function () {
      if (this.stereoPanner) {
        this.stereoPanner.disconnect();
      }
    };
  } else {
    p5.Panner = function (input, output, numInputChannels) {
      this.input = ac.createGain();
      input.connect(this.input);
      this.left = ac.createGain();
      this.right = ac.createGain();
      this.left.channelInterpretation = 'discrete';
      this.right.channelInterpretation = 'discrete'; 

      if (numInputChannels > 1) {
        this.splitter = ac.createChannelSplitter(2);
        this.input.connect(this.splitter);
        this.splitter.connect(this.left, 1);
        this.splitter.connect(this.right, 0);
      } else {
        this.input.connect(this.left);
        this.input.connect(this.right);
      }

      this.output = ac.createChannelMerger(2);
      this.left.connect(this.output, 0, 1);
      this.right.connect(this.output, 0, 0);
      this.output.connect(output);
    }; 


    p5.Panner.prototype.pan = function (val, tFromNow) {
      var time = tFromNow || 0;
      var t = ac.currentTime + time;
      var v = (val + 1) / 2;
      var rightVal = Math.cos(v * Math.PI / 2);
      var leftVal = Math.sin(v * Math.PI / 2);
      this.left.gain.linearRampToValueAtTime(leftVal, t);
      this.right.gain.linearRampToValueAtTime(rightVal, t);
    };

    p5.Panner.prototype.inputChannels = function (numChannels) {
      if (numChannels === 1) {
        this.input.disconnect();
        this.input.connect(this.left);
        this.input.connect(this.right);
      } else if (numChannels === 2) {
        if (_typeof(this.splitter === 'undefined')) {
          this.splitter = ac.createChannelSplitter(2);
        }

        this.input.disconnect();
        this.input.connect(this.splitter);
        this.splitter.connect(this.left, 1);
        this.splitter.connect(this.right, 0);
      }
    };

    p5.Panner.prototype.connect = function (obj) {
      this.output.connect(obj);
    };

    p5.Panner.prototype.disconnect = function () {
      if (this.output) {
        this.output.disconnect();
      }
    };
  }
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var CustomError = __webpack_require__(11);

  var p5sound = __webpack_require__(1);

  var ac = p5sound.audiocontext;

  var _require = __webpack_require__(6),
      midiToFreq = _require.midiToFreq,
      convertToWav = _require.convertToWav,
      safeBufferSize = _require.safeBufferSize;

  var processorNames = __webpack_require__(10);
  /**
   *  <p>SoundFile object with a path to a file.</p>
   *
   *  <p>The p5.SoundFile may not be available immediately because
   *  it loads the file information asynchronously.</p>
   *
   *  <p>To do something with the sound as soon as it loads
   *  pass the name of a function as the second parameter.</p>
   *
   *  <p>Only one file path is required. However, audio file formats
   *  (i.e. mp3, ogg, wav and m4a/aac) are not supported by all
   *  web browsers. If you want to ensure compatability, instead of a single
   *  file path, you may include an Array of filepaths, and the browser will
   *  choose a format that works.</p>
   *
   *  @class p5.SoundFile
   *  @constructor
   *  @param {String|Array} path   path to a sound file (String). Optionally,
   *                               you may include multiple file formats in
   *                               an array. Alternately, accepts an object
   *                               from the HTML5 File API, or a p5.File.
   *  @param {Function} [successCallback]   Name of a function to call once file loads
   *  @param {Function} [errorCallback]   Name of a function to call if file fails to
   *                                      load. This function will receive an error or
   *                                     XMLHttpRequest object with information
   *                                     about what went wrong.
   *  @param {Function} [whileLoadingCallback]   Name of a function to call while file
   *                                             is loading. That function will
   *                                             receive progress of the request to
   *                                             load the sound file
   *                                             (between 0 and 1) as its first
   *                                             parameter. This progress
   *                                             does not account for the additional
   *                                             time needed to decode the audio data.
   *
   *  @example
   *  <div><code>
   *  let mySound;
   *  function preload() {
   *    soundFormats('mp3', 'ogg');
   *    mySound = loadSound('assets/doorbell');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    text('tap here to play', 10, 20);
   *  }
   *
   *  function canvasPressed() {
   *    // playing a sound file on a user gesture
   *    // is equivalent to `userStartAudio()`
   *    mySound.play();
   *  }
   * </code></div>
   */


  p5.SoundFile = function (paths, onload, onerror, whileLoading) {
    if (typeof paths !== 'undefined') {
      if (typeof paths === 'string' || typeof paths[0] === 'string') {
        var path = p5.prototype._checkFileFormats(paths);

        this.url = path;
      } else if (_typeof(paths) === 'object') {
        if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
          throw 'Unable to load file because the File API is not supported';
        }
      } 


      if (paths.file) {
        paths = paths.file;
      }

      this.file = paths;
    } 


    this._onended = function () {};

    this._looping = false;
    this._playing = false;
    this._paused = false;
    this._pauseTime = 0; 

    this._cues = [];
    this._cueIDCounter = 0; 

    this._lastPos = 0;
    this._counterNode = null;
    this._workletNode = null; 

    this.bufferSourceNodes = []; 

    this.bufferSourceNode = null;
    this.buffer = null;
    this.playbackRate = 1;
    this.input = p5sound.audiocontext.createGain();
    this.output = p5sound.audiocontext.createGain();
    this.reversed = false; 

    this.startTime = 0;
    this.endTime = null;
    this.pauseTime = 0; 

    this.mode = 'sustain'; 

    this.startMillis = null; 

    this.panPosition = 0.0;
    this.panner = new p5.Panner(this.output, p5sound.input, 2); 

    if (this.url || this.file) {
      this.load(onload, onerror);
    } 


    p5sound.soundArray.push(this);

    if (typeof whileLoading === 'function') {
      this._whileLoading = whileLoading;
    } else {
      this._whileLoading = function () {};
    }

    this._clearOnEnd = _clearOnEnd.bind(this);
  }; 


  p5.prototype.registerPreloadMethod('loadSound', p5.prototype);
  /**
   *  loadSound() returns a new p5.SoundFile from a specified
   *  path. If called during preload(), the p5.SoundFile will be ready
   *  to play in time for setup() and draw(). If called outside of
   *  preload, the p5.SoundFile will not be ready immediately, so
   *  loadSound accepts a callback as the second parameter. Using a
   *  <a href="https://github.com/processing/p5.js/wiki/Local-server">
   *  local server</a> is recommended when loading external files.
   *
   *  @method loadSound
   *  @for p5
   *  @param  {String|Array}   path     Path to the sound file, or an array with
   *                                    paths to soundfiles in multiple formats
   *                                    i.e. ['sound.ogg', 'sound.mp3'].
   *                                    Alternately, accepts an object: either
   *                                    from the HTML5 File API, or a p5.File.
   *  @param {Function} [successCallback]   Name of a function to call once file loads
   *  @param {Function} [errorCallback]   Name of a function to call if there is
   *                                      an error loading the file.
   *  @param {Function} [whileLoading] Name of a function to call while file is loading.
   *                                 This function will receive the percentage loaded
   *                                 so far, from 0.0 to 1.0.
   *  @return {SoundFile}            Returns a p5.SoundFile
   *  @example
   *  <div><code>
   *  let mySound;
   *  function preload() {
   *    soundFormats('mp3', 'ogg');
   *    mySound = loadSound('assets/doorbell');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    text('tap here to play', 10, 20);
   *  }
   *
   *  function canvasPressed() {
   *    // playing a sound file on a user gesture
   *    // is equivalent to `userStartAudio()`
   *    mySound.play();
   *  }
   *  </code></div>
   */

  p5.prototype.loadSound = function (path, callback, onerror, whileLoading) {
    if (window.location.origin.indexOf('file://') > -1 && window.cordova === 'undefined') {
      window.alert('This sketch may require a server to load external files. Please see http://bit.ly/1qcInwS');
    }

    var self = this;
    var s = new p5.SoundFile(path, function () {
      if (typeof callback === 'function') {
        callback.apply(self, arguments);
      }

      if (typeof self._decrementPreload === 'function') {
        self._decrementPreload();
      }
    }, onerror, whileLoading);
    return s;
  };
  /**
   * This is a helper function that the p5.SoundFile calls to load
   * itself. Accepts a callback (the name of another function)
   * as an optional parameter.
   *
   * @private
   * @for p5.SoundFile
   * @param {Function} [successCallback]   Name of a function to call once file loads
   * @param {Function} [errorCallback]   Name of a function to call if there is an error
   */


  p5.SoundFile.prototype.load = function (callback, errorCallback) {
    var self = this;
    var errorTrace = new Error().stack;

    if (this.url !== undefined && this.url !== '') {
      var request = new XMLHttpRequest();
      request.addEventListener('progress', function (evt) {
        self._updateProgress(evt);
      }, false);
      request.open('GET', this.url, true);
      request.responseType = 'arraybuffer';

      request.onload = function () {
        if (request.status === 200) {
          if (!self.panner) return;
          ac.decodeAudioData(request.response, 
          function (buff) {
            if (!self.panner) return;
            self.buffer = buff;
            self.panner.inputChannels(buff.numberOfChannels);

            if (callback) {
              callback(self);
            }
          }, 
          function () {
            if (!self.panner) return;
            var err = new CustomError('decodeAudioData', errorTrace, self.url);
            var msg = 'AudioContext error at decodeAudioData for ' + self.url;

            if (errorCallback) {
              err.msg = msg;
              errorCallback(err);
            } else {
              console.error(msg + '\n The error stack trace includes: \n' + err.stack);
            }
          });
        } 
        else {
            if (!self.panner) return;
            var err = new CustomError('loadSound', errorTrace, self.url);
            var msg = 'Unable to load ' + self.url + '. The request status was: ' + request.status + ' (' + request.statusText + ')';

            if (errorCallback) {
              err.message = msg;
              errorCallback(err);
            } else {
              console.error(msg + '\n The error stack trace includes: \n' + err.stack);
            }
          }
      }; 


      request.onerror = function () {
        var err = new CustomError('loadSound', errorTrace, self.url);
        var msg = 'There was no response from the server at ' + self.url + '. Check the url and internet connectivity.';

        if (errorCallback) {
          err.message = msg;
          errorCallback(err);
        } else {
          console.error(msg + '\n The error stack trace includes: \n' + err.stack);
        }
      };

      request.send();
    } else if (this.file !== undefined) {
      var reader = new FileReader();

      reader.onload = function () {
        if (!self.panner) return;
        ac.decodeAudioData(reader.result, function (buff) {
          if (!self.panner) return;
          self.buffer = buff;
          self.panner.inputChannels(buff.numberOfChannels);

          if (callback) {
            callback(self);
          }
        });
      };

      reader.onerror = function (e) {
        if (!self.panner) return;

        if (onerror) {
          onerror(e);
        }
      };

      reader.readAsArrayBuffer(this.file);
    }
  }; 


  p5.SoundFile.prototype._updateProgress = function (evt) {
    if (evt.lengthComputable) {
      var percentComplete = evt.loaded / evt.total * 0.99;

      this._whileLoading(percentComplete, evt); 

    } else {
      this._whileLoading('size unknown');
    }
  };
  /**
   *  Returns true if the sound file finished loading successfully.
   *
   *  @method  isLoaded
   *  @for p5.SoundFile
   *  @return {Boolean}
   */


  p5.SoundFile.prototype.isLoaded = function () {
    if (this.buffer) {
      return true;
    } else {
      return false;
    }
  };
  /**
   * Play the p5.SoundFile
   *
   * @method play
   * @for p5.SoundFile
   * @param {Number} [startTime]            (optional) schedule playback to start (in seconds from now).
   * @param {Number} [rate]             (optional) playback rate
   * @param {Number} [amp]              (optional) amplitude (volume)
   *                                     of playback
   * @param {Number} [cueStart]        (optional) cue start time in seconds
   * @param {Number} [duration]          (optional) duration of playback in seconds
   */


  p5.SoundFile.prototype.play = function (startTime, rate, amp, _cueStart, duration) {
    if (!this.output) {
      console.warn('SoundFile.play() called after dispose');
      return;
    }

    var now = p5sound.audiocontext.currentTime;
    var cueStart, cueEnd;
    var time = startTime || 0;

    if (time < 0) {
      time = 0;
    }

    time = time + now;

    if (typeof rate !== 'undefined') {
      this.rate(rate);
    }

    if (typeof amp !== 'undefined') {
      this.setVolume(amp);
    } 


    if (this.buffer) {
      this._pauseTime = 0; 

      if (this.mode === 'restart' && this.buffer && this.bufferSourceNode) {
        this.bufferSourceNode.stop(time);

        this._counterNode.stop(time);
      } 


      if (this.mode === 'untildone' && this.isPlaying()) {
        return;
      } 


      this.bufferSourceNode = this._initSourceNode(); 

      delete this._counterNode;
      this._counterNode = this._initCounterNode();

      if (_cueStart) {
        if (_cueStart >= 0 && _cueStart < this.buffer.duration) {
          cueStart = _cueStart;
        } else {
          throw 'start time out of range';
        }
      } else {
        cueStart = 0;
      }

      if (duration) {
        duration = duration <= this.buffer.duration - cueStart ? duration : this.buffer.duration;
      } 


      if (this._paused) {
        this.bufferSourceNode.start(time, this.pauseTime, duration);

        this._counterNode.start(time, this.pauseTime, duration);
      } else {
        this.bufferSourceNode.start(time, cueStart, duration);

        this._counterNode.start(time, cueStart, duration);
      }

      this._playing = true;
      this._paused = false; 

      this.bufferSourceNodes.push(this.bufferSourceNode);
      this.bufferSourceNode._arrayIndex = this.bufferSourceNodes.length - 1;
      this.bufferSourceNode.addEventListener('ended', this._clearOnEnd);
    } 
    else {
        throw 'not ready to play file, buffer has yet to load. Try preload()';
      } 


    this.bufferSourceNode.loop = this._looping;
    this._counterNode.loop = this._looping;

    if (this._looping === true) {
      cueEnd = duration ? duration : cueStart - 0.000000000000001;
      this.bufferSourceNode.loopStart = cueStart;
      this.bufferSourceNode.loopEnd = cueEnd;
      this._counterNode.loopStart = cueStart;
      this._counterNode.loopEnd = cueEnd;
    }
  };
  /**
   *  p5.SoundFile has two play modes: <code>restart</code> and
   *  <code>sustain</code>. Play Mode determines what happens to a
   *  p5.SoundFile if it is triggered while in the middle of playback.
   *  In sustain mode, playback will continue simultaneous to the
   *  new playback. In restart mode, play() will stop playback
   *  and start over. With untilDone, a sound will play only if it's
   *  not already playing. Sustain is the default mode.
   *
   *  @method  playMode
   *  @for p5.SoundFile
   *  @param  {String} str 'restart' or 'sustain' or 'untilDone'
   *  @example
   *  <div><code>
   *  let mySound;
   *  function preload(){
   *    mySound = loadSound('assets/Damscray_DancingTiger.mp3');
   *  }
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    noFill();
   *    rect(0, height/2, width - 1, height/2 - 1);
   *    rect(0, 0, width - 1, height/2);
   *    textAlign(CENTER, CENTER);
   *    fill(20);
   *    text('restart', width/2, 1 * height/4);
   *    text('sustain', width/2, 3 * height/4);
   *  }
   *  function canvasPressed() {
   *    if (mouseX < height/2) {
   *      mySound.playMode('restart');
   *    } else {
   *      mySound.playMode('sustain');
   *    }
   *    mySound.play();
   *  }
   *
   * </code></div>
   */


  p5.SoundFile.prototype.playMode = function (str) {
    var s = str.toLowerCase(); 

    if (s === 'restart' && this.buffer && this.bufferSourceNode) {
      for (var i = 0; i < this.bufferSourceNodes.length - 1; i++) {
        var now = p5sound.audiocontext.currentTime;
        this.bufferSourceNodes[i].stop(now);
      }
    } 


    if (s === 'restart' || s === 'sustain' || s === 'untildone') {
      this.mode = s;
    } else {
      throw 'Invalid play mode. Must be either "restart" or "sustain"';
    }
  };
  /**
   *  Pauses a file that is currently playing. If the file is not
   *  playing, then nothing will happen.
   *
   *  After pausing, .play() will resume from the paused
   *  position.
   *  If p5.SoundFile had been set to loop before it was paused,
   *  it will continue to loop after it is unpaused with .play().
   *
   *  @method pause
   *  @for p5.SoundFile
   *  @param {Number} [startTime] (optional) schedule event to occur
   *                               seconds from now
   *  @example
   *  <div><code>
   *  let soundFile;
   *  function preload() {
   *    soundFormats('ogg', 'mp3');
   *    soundFile = loadSound('assets/Damscray_-_Dancing_Tiger_02.mp3');
   *  }
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    text('tap to play, release to pause', 10, 20, width - 20);
   *  }
   *  function canvasPressed() {
   *    soundFile.loop();
   *    background(0, 200, 50);
   *  }
   *  function mouseReleased() {
   *    soundFile.pause();
   *    background(220);
   *  }
   *  </code>
   *  </div>
   */


  p5.SoundFile.prototype.pause = function (startTime) {
    var now = p5sound.audiocontext.currentTime;
    var time = startTime || 0;
    var pTime = time + now;

    if (this.isPlaying() && this.buffer && this.bufferSourceNode) {
      this._paused = true;
      this._playing = false;
      this.pauseTime = this.currentTime();
      this.bufferSourceNode.stop(pTime);

      this._counterNode.stop(pTime);

      this._pauseTime = this.currentTime(); 
    } else {
      this._pauseTime = 0;
    }
  };
  /**
   * Loop the p5.SoundFile. Accepts optional parameters to set the
   * playback rate, playback volume, loopStart, loopEnd.
   *
   * @method loop
   * @for p5.SoundFile
   * @param {Number} [startTime] (optional) schedule event to occur
   *                             seconds from now
   * @param {Number} [rate]        (optional) playback rate
   * @param {Number} [amp]         (optional) playback volume
   * @param {Number} [cueLoopStart] (optional) startTime in seconds
   * @param {Number} [duration]  (optional) loop duration in seconds
   * @example
   *  <div><code>
   *  let soundFile;
   *  let loopStart = 0.5;
   *  let loopDuration = 0.2;
   *  function preload() {
   *    soundFormats('ogg', 'mp3');
   *    soundFile = loadSound('assets/Damscray_-_Dancing_Tiger_02.mp3');
   *  }
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    text('tap to play, release to pause', 10, 20, width - 20);
   *  }
   *  function canvasPressed() {
   *    soundFile.loop();
   *    background(0, 200, 50);
   *  }
   *  function mouseReleased() {
   *    soundFile.pause();
   *    background(220);
   *  }
   *  </code>
   *  </div>
   */


  p5.SoundFile.prototype.loop = function (startTime, rate, amp, loopStart, duration) {
    this._looping = true;
    this.play(startTime, rate, amp, loopStart, duration);
  };
  /**
   * Set a p5.SoundFile's looping flag to true or false. If the sound
   * is currently playing, this change will take effect when it
   * reaches the end of the current playback.
   *
   * @method setLoop
   * @for p5.SoundFile
   * @param {Boolean} Boolean   set looping to true or false
   */


  p5.SoundFile.prototype.setLoop = function (bool) {
    if (bool === true) {
      this._looping = true;
    } else if (bool === false) {
      this._looping = false;
    } else {
      throw 'Error: setLoop accepts either true or false';
    }

    if (this.bufferSourceNode) {
      this.bufferSourceNode.loop = this._looping;
      this._counterNode.loop = this._looping;
    }
  };
  /**
   * Returns 'true' if a p5.SoundFile is currently looping and playing, 'false' if not.
   *
   * @method isLooping
   * @for p5.SoundFile
   * @return {Boolean}
   */


  p5.SoundFile.prototype.isLooping = function () {
    if (!this.bufferSourceNode) {
      return false;
    }

    if (this._looping === true && this.isPlaying() === true) {
      return true;
    }

    return false;
  };
  /**
   *  Returns true if a p5.SoundFile is playing, false if not (i.e.
   *  paused or stopped).
   *
   *  @method isPlaying
   *  @for p5.SoundFile
   *  @return {Boolean}
   */


  p5.SoundFile.prototype.isPlaying = function () {
    return this._playing;
  };
  /**
   *  Returns true if a p5.SoundFile is paused, false if not (i.e.
   *  playing or stopped).
   *
   *  @method  isPaused
   *  @for p5.SoundFile
   *  @return {Boolean}
   */


  p5.SoundFile.prototype.isPaused = function () {
    return this._paused;
  };
  /**
   * Stop soundfile playback.
   *
   * @method stop
   * @for p5.SoundFile
   * @param {Number} [startTime] (optional) schedule event to occur
   *                             in seconds from now
   */


  p5.SoundFile.prototype.stop = function (timeFromNow) {
    var time = timeFromNow || 0;

    if (this.mode === 'sustain' || this.mode === 'untildone') {
      this.stopAll(time);
      this._playing = false;
      this.pauseTime = 0;
      this._paused = false;
    } else if (this.buffer && this.bufferSourceNode) {
      var now = p5sound.audiocontext.currentTime;
      var t = time || 0;
      this.pauseTime = 0;
      this.bufferSourceNode.stop(now + t);

      this._counterNode.stop(now + t);

      this._playing = false;
      this._paused = false;
    }
  };
  /**
   *  Stop playback on all of this soundfile's sources.
   *  @private
   */


  p5.SoundFile.prototype.stopAll = function (_time) {
    var now = p5sound.audiocontext.currentTime;
    var time = _time || 0;

    if (this.buffer && this.bufferSourceNode) {
      for (var i in this.bufferSourceNodes) {
        var bufferSourceNode = this.bufferSourceNodes[i];

        if (!!bufferSourceNode) {
          try {
            bufferSourceNode.stop(now + time);
          } catch (e) {
          }
        }
      }

      this._counterNode.stop(now + time);

      this._onended(this);
    }
  };
  /**
   *  Multiply the output volume (amplitude) of a sound file
   *  between 0.0 (silence) and 1.0 (full volume).
   *  1.0 is the maximum amplitude of a digital sound, so multiplying
   *  by greater than 1.0 may cause digital distortion. To
   *  fade, provide a <code>rampTime</code> parameter. For more
   *  complex fades, see the Envelope class.
   *
   *  Alternately, you can pass in a signal source such as an
   *  oscillator to modulate the amplitude with an audio signal.
   *
   *  @method  setVolume
   *  @for p5.SoundFile
   *  @param {Number|Object} volume  Volume (amplitude) between 0.0
   *                                     and 1.0 or modulating signal/oscillator
   *  @param {Number} [rampTime]  Fade for t seconds
   *  @param {Number} [timeFromNow]  Schedule this event to happen at
   *                                 t seconds in the future
   */


  p5.SoundFile.prototype.setVolume = function (vol, _rampTime, _tFromNow) {
    if (typeof vol === 'number') {
      var rampTime = _rampTime || 0;
      var tFromNow = _tFromNow || 0;
      var now = p5sound.audiocontext.currentTime;
      var currentVol = this.output.gain.value;
      this.output.gain.cancelScheduledValues(now + tFromNow);
      this.output.gain.linearRampToValueAtTime(currentVol, now + tFromNow);
      this.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime);
    } else if (vol) {
      vol.connect(this.output.gain);
    } else {
      return this.output.gain;
    }
  }; 


  p5.SoundFile.prototype.amp = p5.SoundFile.prototype.setVolume; 

  p5.SoundFile.prototype.fade = p5.SoundFile.prototype.setVolume;

  p5.SoundFile.prototype.getVolume = function () {
    return this.output.gain.value;
  };
  /**
   * Set the stereo panning of a p5.sound object to
   * a floating point number between -1.0 (left) and 1.0 (right).
   * Default is 0.0 (center).
   *
   * @method pan
   * @for p5.SoundFile
   * @param {Number} [panValue]     Set the stereo panner
   * @param {Number} [timeFromNow]  schedule this event to happen
   *                                 seconds from now
   * @example
   * <div><code>
   *  let ballX = 0;
   *  let soundFile;
   *
   *  function preload() {
   *    soundFormats('ogg', 'mp3');
   *    soundFile = loadSound('assets/beatbox.mp3');
   *  }
   *
   *  function draw() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    ballX = constrain(mouseX, 0, width);
   *    ellipse(ballX, height/2, 20, 20);
   *  }
   *
   *  function canvasPressed(){
   *    // map the ball's x location to a panning degree
   *    // between -1.0 (left) and 1.0 (right)
   *    let panning = map(ballX, 0., width,-1.0, 1.0);
   *    soundFile.pan(panning);
   *    soundFile.play();
   *  }
   *  </div></code>
   */


  p5.SoundFile.prototype.pan = function (pval, tFromNow) {
    this.panPosition = pval;
    this.panner.pan(pval, tFromNow);
  };
  /**
   * Returns the current stereo pan position (-1.0 to 1.0)
   *
   * @method getPan
   * @for p5.SoundFile
   * @return {Number} Returns the stereo pan setting of the Oscillator
   *                          as a number between -1.0 (left) and 1.0 (right).
   *                          0.0 is center and default.
   */


  p5.SoundFile.prototype.getPan = function () {
    return this.panPosition;
  };
  /**
   *  Set the playback rate of a sound file. Will change the speed and the pitch.
   *  Values less than zero will reverse the audio buffer.
   *
   *  @method rate
   *  @for p5.SoundFile
   *  @param {Number} [playbackRate]     Set the playback rate. 1.0 is normal,
   *                                     .5 is half-speed, 2.0 is twice as fast.
   *                                     Values less than zero play backwards.
   *  @example
   *  <div><code>
   *  let mySound;
   *
   *  function preload() {
   *    mySound = loadSound('assets/Damscray_DancingTiger.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *  }
   *  function canvasPressed() {
   *    mySound.loop();
   *  }
   *  function mouseReleased() {
   *    mySound.pause();
   *  }
   *  function draw() {
   *    background(220);
   *
   *    // Set the rate to a range between 0.1 and 4
   *    // Changing the rate also alters the pitch
   *    let playbackRate = map(mouseY, 0.1, height, 2, 0);
   *    playbackRate = constrain(playbackRate, 0.01, 4);
   *    mySound.rate(playbackRate);
   *
   *    line(0, mouseY, width, mouseY);
   *    text('rate: ' + round(playbackRate * 100) + '%', 10, 20);
   *  }
   *
   * </code>
   * </div>
   *
   */


  p5.SoundFile.prototype.rate = function (playbackRate) {
    var reverse = false;

    if (typeof playbackRate === 'undefined') {
      return this.playbackRate;
    }

    this.playbackRate = playbackRate;

    if (playbackRate === 0) {
      playbackRate = 0.0000000000001;
    } else if (playbackRate < 0 && !this.reversed) {
      playbackRate = Math.abs(playbackRate);
      reverse = true;
    } else if (playbackRate > 0 && this.reversed) {
      reverse = true;
    }

    if (this.bufferSourceNode) {
      var now = p5sound.audiocontext.currentTime;
      this.bufferSourceNode.playbackRate.cancelScheduledValues(now);
      this.bufferSourceNode.playbackRate.linearRampToValueAtTime(Math.abs(playbackRate), now);

      this._counterNode.playbackRate.cancelScheduledValues(now);

      this._counterNode.playbackRate.linearRampToValueAtTime(Math.abs(playbackRate), now);
    }

    if (reverse) {
      this.reverseBuffer();
    }

    return this.playbackRate;
  }; 


  p5.SoundFile.prototype.setPitch = function (num) {
    var newPlaybackRate = midiToFreq(num) / midiToFreq(60);
    this.rate(newPlaybackRate);
  };

  p5.SoundFile.prototype.getPlaybackRate = function () {
    return this.playbackRate;
  };
  /**
   * Returns the duration of a sound file in seconds.
   *
   * @method duration
   * @for p5.SoundFile
   * @return {Number} The duration of the soundFile in seconds.
   */


  p5.SoundFile.prototype.duration = function () {
    if (this.buffer) {
      return this.buffer.duration;
    } else {
      return 0;
    }
  };
  /**
   * Return the current position of the p5.SoundFile playhead, in seconds.
   * Time is relative to the normal buffer direction, so if `reverseBuffer`
   * has been called, currentTime will count backwards.
   *
   * @method currentTime
   * @for p5.SoundFile
   * @return {Number}   currentTime of the soundFile in seconds.
   */


  p5.SoundFile.prototype.currentTime = function () {
    return this.reversed ? Math.abs(this._lastPos - this.buffer.length) / ac.sampleRate : this._lastPos / ac.sampleRate;
  };
  /**
   * Move the playhead of a soundfile that is currently playing to a
   * new position and a new duration, in seconds.
   * If none are given, will reset the file to play entire duration
   * from start to finish. To set the position of a soundfile that is
   * not currently playing, use the `play` or `loop` methods.
   *
   * @method jump
   * @for p5.SoundFile
   * @param {Number} cueTime    cueTime of the soundFile in seconds.
   * @param {Number} duration    duration in seconds.
   */


  p5.SoundFile.prototype.jump = function (cueTime, duration) {
    if (cueTime < 0 || cueTime > this.buffer.duration) {
      throw 'jump time out of range';
    }

    if (duration > this.buffer.duration - cueTime) {
      throw 'end time out of range';
    }

    var cTime = cueTime || 0;
    var dur = duration || undefined;

    if (this.isPlaying()) {
      this.stop(0);
      this.play(0, this.playbackRate, this.output.gain.value, cTime, dur);
    }
  };
  /**
    * Return the number of channels in a sound file.
    * For example, Mono = 1, Stereo = 2.
    *
    * @method channels
    * @for p5.SoundFile
    * @return {Number} [channels]
    */


  p5.SoundFile.prototype.channels = function () {
    return this.buffer.numberOfChannels;
  };
  /**
    * Return the sample rate of the sound file.
    *
    * @method sampleRate
    * @for p5.SoundFile
    * @return {Number} [sampleRate]
    */


  p5.SoundFile.prototype.sampleRate = function () {
    return this.buffer.sampleRate;
  };
  /**
    * Return the number of samples in a sound file.
    * Equal to sampleRate * duration.
    *
    * @method frames
    * @for p5.SoundFile
    * @return {Number} [sampleCount]
    */


  p5.SoundFile.prototype.frames = function () {
    return this.buffer.length;
  };
  /**
   * Returns an array of amplitude peaks in a p5.SoundFile that can be
   * used to draw a static waveform. Scans through the p5.SoundFile's
   * audio buffer to find the greatest amplitudes. Accepts one
   * parameter, 'length', which determines size of the array.
   * Larger arrays result in more precise waveform visualizations.
   *
   * Inspired by Wavesurfer.js.
   *
   * @method  getPeaks
   * @for p5.SoundFile
   * @params {Number} [length] length is the size of the returned array.
   *                          Larger length results in more precision.
   *                          Defaults to 5*width of the browser window.
   * @returns {Float32Array} Array of peaks.
   */


  p5.SoundFile.prototype.getPeaks = function (length) {
    if (this.buffer) {
      if (!length) {
        length = window.width * 5;
      }

      if (this.buffer) {
        var buffer = this.buffer;
        var sampleSize = buffer.length / length;
        var sampleStep = ~~(sampleSize / 10) || 1;
        var channels = buffer.numberOfChannels;
        var peaks = new Float32Array(Math.round(length));

        for (var c = 0; c < channels; c++) {
          var chan = buffer.getChannelData(c);

          for (var i = 0; i < length; i++) {
            var start = ~~(i * sampleSize);
            var end = ~~(start + sampleSize);
            var max = 0;

            for (var j = start; j < end; j += sampleStep) {
              var value = chan[j];

              if (value > max) {
                max = value; 
              } else if (-value > max) {
                max = value;
              }
            }

            if (c === 0 || Math.abs(max) > peaks[i]) {
              peaks[i] = max;
            }
          }
        }

        return peaks;
      }
    } else {
      throw 'Cannot load peaks yet, buffer is not loaded';
    }
  };
  /**
   *  Reverses the p5.SoundFile's buffer source.
   *  Playback must be handled separately (see example).
   *
   *  @method  reverseBuffer
   *  @for p5.SoundFile
   *  @example
   *  <div><code>
   *  let drum;
   *  function preload() {
   *    drum = loadSound('assets/drum.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    text('tap to play', 20, 20);
   *  }
   *
   *  function canvasPressed() {
   *    drum.stop();
   *    drum.reverseBuffer();
   *    drum.play();
   *  }
   * </code>
   * </div>
   */


  p5.SoundFile.prototype.reverseBuffer = function () {
    if (this.buffer) {
      var currentPos = this._lastPos / ac.sampleRate;
      var curVol = this.getVolume();
      this.setVolume(0, 0.001);
      var numChannels = this.buffer.numberOfChannels;

      for (var i = 0; i < numChannels; i++) {
        this.buffer.getChannelData(i).reverse();
      } 


      this.reversed = !this.reversed;

      if (this.isPlaying() && currentPos) {
        this.jump(this.duration() - currentPos);
      }

      this.setVolume(curVol, 0.001);
    } else {
      throw 'SoundFile is not done loading';
    }
  };
  /**
   *  Schedule an event to be called when the soundfile
   *  reaches the end of a buffer. If the soundfile is
   *  playing through once, this will be called when it
   *  ends. If it is looping, it will be called when
   *  stop is called.
   *
   *  @method  onended
   *  @for p5.SoundFile
   *  @param  {Function} callback function to call when the
   *                              soundfile has ended.
   */


  p5.SoundFile.prototype.onended = function (callback) {
    this._onended = callback;
    return this;
  };

  p5.SoundFile.prototype.add = function () {
  };

  p5.SoundFile.prototype.dispose = function () {
    var now = p5sound.audiocontext.currentTime; 

    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);
    this.stop(now);

    if (this.buffer && this.bufferSourceNode) {
      for (var i = 0; i < this.bufferSourceNodes.length - 1; i++) {
        if (this.bufferSourceNodes[i] !== null) {
          this.bufferSourceNodes[i].disconnect();

          try {
            this.bufferSourceNodes[i].stop(now);
          } catch (e) {
            console.warn('no buffer source node to dispose');
          }

          this.bufferSourceNodes[i] = null;
        }
      }

      if (this.isPlaying()) {
        try {
          this._counterNode.stop(now);
        } catch (e) {
          console.log(e);
        }

        this._counterNode = null;
      }
    }

    if (this.output) {
      this.output.disconnect();
      this.output = null;
    }

    if (this.panner) {
      this.panner.disconnect();
      this.panner = null;
    }
  };
  /**
   * Connects the output of a p5sound object to input of another
   * p5.sound object. For example, you may connect a p5.SoundFile to an
   * FFT or an Effect. If no parameter is given, it will connect to
   * the master output. Most p5sound objects connect to the master
   * output when they are created.
   *
   * @method connect
   * @for p5.SoundFile
   * @param {Object} [object] Audio object that accepts an input
   */


  p5.SoundFile.prototype.connect = function (unit) {
    if (!unit) {
      this.panner.connect(p5sound.input);
    } else {
      if (unit.hasOwnProperty('input')) {
        this.panner.connect(unit.input);
      } else {
        this.panner.connect(unit);
      }
    }
  };
  /**
   * Disconnects the output of this p5sound object.
   *
   * @method disconnect
   * @for p5.SoundFile
   */


  p5.SoundFile.prototype.disconnect = function () {
    if (this.panner) {
      this.panner.disconnect();
    }
  };
  /**
   */


  p5.SoundFile.prototype.getLevel = function () {
    console.warn('p5.SoundFile.getLevel has been removed from the library. Use p5.Amplitude instead');
  };
  /**
   *  Reset the source for this SoundFile to a
   *  new path (URL).
   *
   *  @method  setPath
   *  @for p5.SoundFile
   *  @param {String}   path     path to audio file
   *  @param {Function} callback Callback
   */


  p5.SoundFile.prototype.setPath = function (p, callback) {
    var path = p5.prototype._checkFileFormats(p);

    this.url = path;
    this.load(callback);
  };
  /**
   *  Replace the current Audio Buffer with a new Buffer.
   *
   *  @method setBuffer
   *  @for p5.SoundFile
   *  @param {Array} buf Array of Float32 Array(s). 2 Float32 Arrays
   *                     will create a stereo source. 1 will create
   *                     a mono source.
   */


  p5.SoundFile.prototype.setBuffer = function (buf) {
    var numChannels = buf.length;
    var size = buf[0].length;
    var newBuffer = ac.createBuffer(numChannels, size, ac.sampleRate);

    if (!(buf[0] instanceof Float32Array)) {
      buf[0] = new Float32Array(buf[0]);
    }

    for (var channelNum = 0; channelNum < numChannels; channelNum++) {
      var channel = newBuffer.getChannelData(channelNum);
      channel.set(buf[channelNum]);
    }

    this.buffer = newBuffer; 

    this.panner.inputChannels(numChannels);
  }; 


  var _createCounterBuffer = function _createCounterBuffer(buffer) {
    var len = buffer.length;
    var audioBuf = ac.createBuffer(1, buffer.length, ac.sampleRate);
    var arrayBuffer = audioBuf.getChannelData(0);

    for (var index = 0; index < len; index++) {
      arrayBuffer[index] = index;
    }

    return audioBuf;
  }; 


  p5.SoundFile.prototype._initCounterNode = function () {
    var _this = this;

    var self = this;
    var now = ac.currentTime;
    var cNode = ac.createBufferSource();
    var workletBufferSize = safeBufferSize(256); 

    if (self._workletNode) {
      self._workletNode.disconnect();

      delete self._workletNode;
    }

    self._workletNode = new AudioWorkletNode(ac, processorNames.soundFileProcessor, {
      processorOptions: {
        bufferSize: workletBufferSize
      }
    });

    self._workletNode.port.onmessage = function (event) {
      if (event.data.name === 'position') {
        if (event.data.position === 0) {
          return;
        }

        _this._lastPos = event.data.position; 

        _this._onTimeUpdate(self._lastPos);
      }
    }; 


    cNode.buffer = _createCounterBuffer(self.buffer);
    cNode.playbackRate.setValueAtTime(self.playbackRate, now);
    cNode.connect(self._workletNode);

    self._workletNode.connect(p5.soundOut._silentNode);

    return cNode;
  }; 


  p5.SoundFile.prototype._initSourceNode = function () {
    var bufferSourceNode = ac.createBufferSource();
    bufferSourceNode.buffer = this.buffer;
    bufferSourceNode.playbackRate.value = this.playbackRate;
    bufferSourceNode.connect(this.output);
    return bufferSourceNode;
  };
  /**
   *  processPeaks returns an array of timestamps where it thinks there is a beat.
   *
   *  This is an asynchronous function that processes the soundfile in an offline audio context,
   *  and sends the results to your callback function.
   *
   *  The process involves running the soundfile through a lowpass filter, and finding all of the
   *  peaks above the initial threshold. If the total number of peaks are below the minimum number of peaks,
   *  it decreases the threshold and re-runs the analysis until either minPeaks or minThreshold are reached.
   *
   *  @method  processPeaks
   *  @for p5.SoundFile
   *  @param  {Function} callback       a function to call once this data is returned
   *  @param  {Number}   [initThreshold] initial threshold defaults to 0.9
   *  @param  {Number}   [minThreshold]   minimum threshold defaults to 0.22
   *  @param  {Number}   [minPeaks]       minimum number of peaks defaults to 200
   *  @return {Array}                  Array of timestamped peaks
   */


  p5.SoundFile.prototype.processPeaks = function (callback, _initThreshold, _minThreshold, _minPeaks) {
    var bufLen = this.buffer.length;
    var sampleRate = this.buffer.sampleRate;
    var buffer = this.buffer;
    var allPeaks = [];
    var initialThreshold = _initThreshold || 0.9,
        threshold = initialThreshold,
        minThreshold = _minThreshold || 0.22,
        minPeaks = _minPeaks || 200; 

    var offlineContext = new window.OfflineAudioContext(1, bufLen, sampleRate); 

    var source = offlineContext.createBufferSource();
    source.buffer = buffer; 

    var filter = offlineContext.createBiquadFilter();
    filter.type = 'lowpass';
    source.connect(filter);
    filter.connect(offlineContext.destination); 

    source.start(0);
    offlineContext.startRendering(); 

    offlineContext.oncomplete = function (e) {
      if (!self.panner) return;
      var filteredBuffer = e.renderedBuffer;
      var bufferData = filteredBuffer.getChannelData(0); 

      do {
        allPeaks = getPeaksAtThreshold(bufferData, threshold);
        threshold -= 0.005;
      } while (Object.keys(allPeaks).length < minPeaks && threshold >= minThreshold); 


      var intervalCounts = countIntervalsBetweenNearbyPeaks(allPeaks); 

      var groups = groupNeighborsByTempo(intervalCounts, filteredBuffer.sampleRate); 

      var topTempos = groups.sort(function (intA, intB) {
        return intB.count - intA.count;
      }).splice(0, 5); 

      this.tempo = topTempos[0].tempo; 

      var bpmVariance = 5;
      var tempoPeaks = getPeaksAtTopTempo(allPeaks, topTempos[0].tempo, filteredBuffer.sampleRate, bpmVariance);
      callback(tempoPeaks);
    };
  }; 


  var Peak = function Peak(amp, i) {
    this.sampleIndex = i;
    this.amplitude = amp;
    this.tempos = [];
    this.intervals = [];
  }; 


  function getPeaksAtThreshold(data, threshold) {
    var peaksObj = {};
    var length = data.length;

    for (var i = 0; i < length; i++) {
      if (data[i] > threshold) {
        var amp = data[i];
        var peak = new Peak(amp, i);
        peaksObj[i] = peak; 

        i += 6000;
      }

      i++;
    }

    return peaksObj;
  } 


  function countIntervalsBetweenNearbyPeaks(peaksObj) {
    var intervalCounts = [];
    var peaksArray = Object.keys(peaksObj).sort();

    for (var index = 0; index < peaksArray.length; index++) {
      for (var i = 0; i < 10; i++) {
        var startPeak = peaksObj[peaksArray[index]];
        var endPeak = peaksObj[peaksArray[index + i]];

        if (startPeak && endPeak) {
          var startPos = startPeak.sampleIndex;
          var endPos = endPeak.sampleIndex;
          var interval = endPos - startPos; 

          if (interval > 0) {
            startPeak.intervals.push(interval);
          } 


          var foundInterval = intervalCounts.some(function (intervalCount) {
            if (intervalCount.interval === interval) {
              intervalCount.count++;
              return intervalCount;
            }
          }); 

          if (!foundInterval) {
            intervalCounts.push({
              interval: interval,
              count: 1
            });
          }
        }
      }
    }

    return intervalCounts;
  } 


  function groupNeighborsByTempo(intervalCounts, sampleRate) {
    var tempoCounts = [];
    intervalCounts.forEach(function (intervalCount) {
      try {
        var theoreticalTempo = Math.abs(60 / (intervalCount.interval / sampleRate));
        theoreticalTempo = mapTempo(theoreticalTempo);
        var foundTempo = tempoCounts.some(function (tempoCount) {
          if (tempoCount.tempo === theoreticalTempo) return tempoCount.count += intervalCount.count;
        });

        if (!foundTempo) {
          if (isNaN(theoreticalTempo)) {
            return;
          }

          tempoCounts.push({
            tempo: Math.round(theoreticalTempo),
            count: intervalCount.count
          });
        }
      } catch (e) {
        throw e;
      }
    });
    return tempoCounts;
  } 


  function getPeaksAtTopTempo(peaksObj, tempo, sampleRate, bpmVariance) {
    var peaksAtTopTempo = [];
    var peaksArray = Object.keys(peaksObj).sort(); 

    for (var i = 0; i < peaksArray.length; i++) {
      var key = peaksArray[i];
      var peak = peaksObj[key];

      for (var j = 0; j < peak.intervals.length; j++) {
        var intervalBPM = Math.round(Math.abs(60 / (peak.intervals[j] / sampleRate)));
        intervalBPM = mapTempo(intervalBPM);

        if (Math.abs(intervalBPM - tempo) < bpmVariance) {
          peaksAtTopTempo.push(peak.sampleIndex / sampleRate);
        }
      }
    } 


    peaksAtTopTempo = peaksAtTopTempo.filter(function (peakTime, index, arr) {
      var dif = arr[index + 1] - peakTime;

      if (dif > 0.01) {
        return true;
      }
    });
    return peaksAtTopTempo;
  } 


  function mapTempo(theoreticalTempo) {
    if (!isFinite(theoreticalTempo) || theoreticalTempo === 0) {
      return;
    } 


    while (theoreticalTempo < 90) {
      theoreticalTempo *= 2;
    }

    while (theoreticalTempo > 180 && theoreticalTempo > 90) {
      theoreticalTempo /= 2;
    }

    return theoreticalTempo;
  }


  var Cue = function Cue(callback, time, id, val) {
    this.callback = callback;
    this.time = time;
    this.id = id;
    this.val = val;
  };
  /**
   *  Schedule events to trigger every time a MediaElement
   *  (audio/video) reaches a playback cue point.
   *
   *  Accepts a callback function, a time (in seconds) at which to trigger
   *  the callback, and an optional parameter for the callback.
   *
   *  Time will be passed as the first parameter to the callback function,
   *  and param will be the second parameter.
   *
   *
   *  @method  addCue
   *  @for p5.SoundFile
   *  @param {Number}   time     Time in seconds, relative to this media
   *                             element's playback. For example, to trigger
   *                             an event every time playback reaches two
   *                             seconds, pass in the number 2. This will be
   *                             passed as the first parameter to
   *                             the callback function.
   *  @param {Function} callback Name of a function that will be
   *                             called at the given time. The callback will
   *                             receive time and (optionally) param as its
   *                             two parameters.
   *  @param {Object} [value]    An object to be passed as the
   *                             second parameter to the
   *                             callback function.
   *  @return {Number} id ID of this cue,
   *                      useful for removeCue(id)
   *  @example
   *  <div><code>
   *  let mySound;
   *  function preload() {
   *    mySound = loadSound('assets/Damscray_DancingTiger.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    text('tap to play', 10, 20);
   *
   *    // schedule calls to changeText
   *    mySound.addCue(0, changeText, "hello" );
   *    mySound.addCue(0.5, changeText, "hello," );
   *    mySound.addCue(1, changeText, "hello, p5!");
   *    mySound.addCue(1.5, changeText, "hello, p5!!");
   *    mySound.addCue(2, changeText, "hello, p5!!!!!");
   *  }
   *
   *  function changeText(val) {
   *    background(220);
   *    text(val, 10, 20);
   *  }
   *
   *  function canvasPressed() {
   *    mySound.play();
   *  }
   *  </code></div>
   */


  p5.SoundFile.prototype.addCue = function (time, callback, val) {
    var id = this._cueIDCounter++;
    var cue = new Cue(callback, time, id, val);

    this._cues.push(cue); 


    return id;
  };
  /**
   *  Remove a callback based on its ID. The ID is returned by the
   *  addCue method.
   *
   *  @method removeCue
   *  @for p5.SoundFile
   *  @param  {Number} id ID of the cue, as returned by addCue
   */


  p5.SoundFile.prototype.removeCue = function (id) {
    var cueLength = this._cues.length;

    for (var i = 0; i < cueLength; i++) {
      var cue = this._cues[i];

      if (cue.id === id) {
        this._cues.splice(i, 1);

        break;
      }
    }

    if (this._cues.length === 0) {
    }
  };
  /**
   *  Remove all of the callbacks that had originally been scheduled
   *  via the addCue method.
   *
   *  @method  clearCues
   */


  p5.SoundFile.prototype.clearCues = function () {
    this._cues = []; 
  }; 


  p5.SoundFile.prototype._onTimeUpdate = function (position) {
    var playbackTime = position / this.buffer.sampleRate;
    var cueLength = this._cues.length;

    for (var i = 0; i < cueLength; i++) {
      var cue = this._cues[i];
      var callbackTime = cue.time;
      var val = cue.val;

      if (~~this._prevUpdateTime <= callbackTime && callbackTime <= playbackTime) {
        cue.callback(val);
      }
    }

    this._prevUpdateTime = playbackTime;
  };
  /**
   * Save a p5.SoundFile as a .wav file. The browser will prompt the user
   * to download the file to their device. To upload a file to a server, see
   * <a href="/docs/reference/#/p5.SoundFile/getBlob">getBlob</a>
   *
   * @method save
   * @for p5.SoundFile
   * @param  {String} [fileName]      name of the resulting .wav file.
   * @example
   *  <div><code>
   *  let mySound;
   *  function preload() {
   *    mySound = loadSound('assets/doorbell.mp3');
   *  }
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    text('tap to download', 10, 20);
   *  }
   *
   *  function canvasPressed() {
   *    mySound.save('my cool filename');
   *  }
   * </code></div>
   */


  p5.SoundFile.prototype.save = function (fileName) {
    p5.prototype.saveSound(this, fileName, 'wav');
  };
  /**
   * This method is useful for sending a SoundFile to a server. It returns the
   * .wav-encoded audio data as a "<a target="_blank" title="Blob reference at
   * MDN" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">Blob</a>".
   * A Blob is a file-like data object that can be uploaded to a server
   * with an <a href="/docs/reference/#/p5/httpDo">http</a> request. We'll
   * use the `httpDo` options object to send a POST request with some
   * specific options: we encode the request as `multipart/form-data`,
   * and attach the blob as one of the form values using `FormData`.
   *
   *
   * @method getBlob
   * @for p5.SoundFile
   * @returns {Blob} A file-like data object
   * @example
   *  <div><code>
   *  function preload() {
   *    mySound = loadSound('assets/doorbell.mp3');
   *  }
   *
   *  function setup() {
   *    noCanvas();
   *    let soundBlob = mySound.getBlob();
   *
   *    // Now we can send the blob to a server...
   *    let serverUrl = 'https://jsonplaceholder.typicode.com/posts';
   *    let httpRequestOptions = {
   *      method: 'POST',
   *      body: new FormData().append('soundBlob', soundBlob),
   *      headers: new Headers({
   *        'Content-Type': 'multipart/form-data'
   *      })
   *    };
   *    httpDo(serverUrl, httpRequestOptions);
   *
   *    // We can also create an `ObjectURL` pointing to the Blob
   *    let blobUrl = URL.createObjectURL(soundBlob);
   *
   *    // The `<Audio>` Element accepts Object URL's
   *    createAudio(blobUrl).showControls();
   *
   *    createDiv();
   *
   *    // The ObjectURL exists as long as this tab is open
   *    let input = createInput(blobUrl);
   *    input.attribute('readonly', true);
   *    input.mouseClicked(function() { input.elt.select() });
   *  }
   *
   * </code></div>
   */


  p5.SoundFile.prototype.getBlob = function () {
    var dataView = convertToWav(this.buffer);
    return new Blob([dataView], {
      type: 'audio/wav'
    });
  }; 


  function _clearOnEnd(e) {
    var thisBufferSourceNode = e.target;
    var soundFile = this; 

    thisBufferSourceNode._playing = false;
    thisBufferSourceNode.removeEventListener('ended', soundFile._clearOnEnd); 

    soundFile._onended(soundFile); 


    soundFile.bufferSourceNodes.map(function (_, i) {
      return i;
    }).reverse().forEach(function (i) {
      var n = soundFile.bufferSourceNodes[i];

      if (n._playing === false) {
        soundFile.bufferSourceNodes.splice(i, 1);
      }
    });

    if (soundFile.bufferSourceNodes.length === 0) {
      soundFile._playing = false;
    }
  }
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var _require = __webpack_require__(6),
      safeBufferSize = _require.safeBufferSize;

  var processorNames = __webpack_require__(10);
  /**
   *  Amplitude measures volume between 0.0 and 1.0.
   *  Listens to all p5sound by default, or use setInput()
   *  to listen to a specific sound source. Accepts an optional
   *  smoothing value, which defaults to 0.
   *
   *  @class p5.Amplitude
   *  @constructor
   *  @param {Number} [smoothing] between 0.0 and .999 to smooth
   *                             amplitude readings (defaults to 0)
   *  @example
   *  <div><code>
   *  let sound, amplitude;
   *
   *  function preload(){
   *    sound = loadSound('assets/beat.mp3');
   *  }
   *  function setup() {
   *    let cnv = createCanvas(100,100);
   *    cnv.mouseClicked(toggleSound);
   *    amplitude = new p5.Amplitude();
   *  }
   *
   *  function draw() {
   *    background(220);
   *    text('tap to play', 20, 20);
   *
   *    let level = amplitude.getLevel();
   *    let size = map(level, 0, 1, 0, 200);
   *    ellipse(width/2, height/2, size, size);
   *  }
   *
   *  function toggleSound() {
   *    if (sound.isPlaying() ){
   *      sound.stop();
   *    } else {
   *      sound.play();
   *    }
   *  }
   *
   *  </code></div>
   */


  p5.Amplitude = function (smoothing) {
    this.bufferSize = safeBufferSize(2048); 

    this.audiocontext = p5sound.audiocontext;
    this._workletNode = new AudioWorkletNode(this.audiocontext, processorNames.amplitudeProcessor, {
      outputChannelCount: [1],
      parameterData: {
        smoothing: smoothing || 0
      },
      processorOptions: {
        normalize: false,
        smoothing: smoothing || 0,
        numInputChannels: 2,
        bufferSize: this.bufferSize
      }
    });

    this._workletNode.port.onmessage = function (event) {
      if (event.data.name === 'amplitude') {
        this.volume = event.data.volume;
        this.volNorm = event.data.volNorm;
        this.stereoVol = event.data.stereoVol;
        this.stereoVolNorm = event.data.stereoVolNorm;
      }
    }.bind(this); 


    this.input = this._workletNode;
    this.output = this.audiocontext.createGain(); 

    this.volume = 0;
    this.volNorm = 0;
    this.stereoVol = [0, 0];
    this.stereoVolNorm = [0, 0];
    this.normalize = false;

    this._workletNode.connect(this.output);

    this.output.gain.value = 0; 

    this.output.connect(this.audiocontext.destination); 

    p5sound.meter.connect(this._workletNode); 

    p5sound.soundArray.push(this);
  };
  /**
   *  Connects to the p5sound instance (master output) by default.
   *  Optionally, you can pass in a specific source (i.e. a soundfile).
   *
   *  @method setInput
   *  @for p5.Amplitude
   *  @param {soundObject|undefined} [snd] set the sound source
   *                                       (optional, defaults to
   *                                       master output)
   *  @param {Number|undefined} [smoothing] a range between 0.0 and 1.0
   *                                        to smooth amplitude readings
   *  @example
   *  <div><code>
   *  function preload(){
   *    sound1 = loadSound('assets/beat.mp3');
   *    sound2 = loadSound('assets/drum.mp3');
   *  }
   *  function setup(){
   *    cnv = createCanvas(100, 100);
   *    cnv.mouseClicked(toggleSound);
   *
   *    amplitude = new p5.Amplitude();
   *    amplitude.setInput(sound2);
   *  }
   *
   *  function draw() {
   *    background(220);
   *    text('tap to play', 20, 20);
   *
   *    let level = amplitude.getLevel();
   *    let size = map(level, 0, 1, 0, 200);
   *    ellipse(width/2, height/2, size, size);
   *  }
   *
   *  function toggleSound(){
   *    if (sound1.isPlaying() && sound2.isPlaying()) {
   *      sound1.stop();
   *      sound2.stop();
   *    } else {
   *      sound1.play();
   *      sound2.play();
   *    }
   *  }
   *  </code></div>
   */


  p5.Amplitude.prototype.setInput = function (source, smoothing) {
    p5sound.meter.disconnect();

    if (smoothing) {
      this._workletNode.parameters.get('smoothing').value = smoothing;
    } 


    if (source == null) {
      console.log('Amplitude input source is not ready! Connecting to master output instead');
      p5sound.meter.connect(this._workletNode);
    } 
    else if (source instanceof p5.Signal) {
        source.output.connect(this._workletNode);
      } 
      else if (source) {
          source.connect(this._workletNode);

          this._workletNode.disconnect();

          this._workletNode.connect(this.output);
        } 
        else {
            p5sound.meter.connect(this._workletNode);
          }
  };

  p5.Amplitude.prototype.connect = function (unit) {
    if (unit) {
      if (unit.hasOwnProperty('input')) {
        this.output.connect(unit.input);
      } else {
        this.output.connect(unit);
      }
    } else {
      this.output.connect(this.panner.connect(p5sound.input));
    }
  };

  p5.Amplitude.prototype.disconnect = function () {
    if (this.output) {
      this.output.disconnect();
    }
  };
  /**
   *  Returns a single Amplitude reading at the moment it is called.
   *  For continuous readings, run in the draw loop.
   *
   *  @method getLevel
   *  @for p5.Amplitude
   *  @param {Number} [channel] Optionally return only channel 0 (left) or 1 (right)
   *  @return {Number}       Amplitude as a number between 0.0 and 1.0
   *  @example
   *  <div><code>
   *  function preload(){
   *    sound = loadSound('assets/beat.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mouseClicked(toggleSound);
   *    amplitude = new p5.Amplitude();
   *  }
   *
   *  function draw() {
   *    background(220, 150);
   *    textAlign(CENTER);
   *    text('tap to play', width/2, 20);
   *
   *    let level = amplitude.getLevel();
   *    let size = map(level, 0, 1, 0, 200);
   *    ellipse(width/2, height/2, size, size);
   *  }
   *
   *  function toggleSound(){
   *    if (sound.isPlaying()) {
   *      sound.stop();
   *    } else {
   *      sound.play();
   *    }
   *  }
   *  </code></div>
   */


  p5.Amplitude.prototype.getLevel = function (channel) {
    if (typeof channel !== 'undefined') {
      if (this.normalize) {
        return this.stereoVolNorm[channel];
      } else {
        return this.stereoVol[channel];
      }
    } else if (this.normalize) {
      return this.volNorm;
    } else {
      return this.volume;
    }
  };
  /**
   * Determines whether the results of Amplitude.process() will be
   * Normalized. To normalize, Amplitude finds the difference the
   * loudest reading it has processed and the maximum amplitude of
   * 1.0. Amplitude adds this difference to all values to produce
   * results that will reliably map between 0.0 and 1.0. However,
   * if a louder moment occurs, the amount that Normalize adds to
   * all the values will change. Accepts an optional boolean parameter
   * (true or false). Normalizing is off by default.
   *
   * @method toggleNormalize
   * @for p5.Amplitude
   * @param {boolean} [boolean] set normalize to true (1) or false (0)
   */


  p5.Amplitude.prototype.toggleNormalize = function (bool) {
    if (typeof bool === 'boolean') {
      this.normalize = bool;
    } else {
      this.normalize = !this.normalize;
    }

    this._workletNode.port.postMessage({
      name: 'toggleNormalize',
      normalize: this.normalize
    });
  };
  /**
   *  Smooth Amplitude analysis by averaging with the last analysis
   *  frame. Off by default.
   *
   *  @method smooth
   *  @for p5.Amplitude
   *  @param {Number} set smoothing from 0.0 <= 1
   */


  p5.Amplitude.prototype.smooth = function (s) {
    if (s >= 0 && s < 1) {
      this._workletNode.port.postMessage({
        name: 'smoothing',
        smoothing: s
      });
    } else {
      console.log('Error: smoothing must be between 0 and 1');
    }
  };

  p5.Amplitude.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);

    if (this.input) {
      this.input.disconnect();
      delete this.input;
    }

    if (this.output) {
      this.output.disconnect();
      delete this.output;
    }

    this._workletNode.disconnect();

    delete this._workletNode;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);
  /**
   *  <p>FFT (Fast Fourier Transform) is an analysis algorithm that
   *  isolates individual
   *  <a href="https://en.wikipedia.org/wiki/Audio_frequency">
   *  audio frequencies</a> within a waveform.</p>
   *
   *  <p>Once instantiated, a p5.FFT object can return an array based on
   *  two types of analyses: <br>  <code>FFT.waveform()</code> computes
   *  amplitude values along the time domain. The array indices correspond
   *  to samples across a brief moment in time. Each value represents
   *  amplitude of the waveform at that sample of time.<br>
   *   <code>FFT.analyze() </code> computes amplitude values along the
   *  frequency domain. The array indices correspond to frequencies (i.e.
   *  pitches), from the lowest to the highest that humans can hear. Each
   *  value represents amplitude at that slice of the frequency spectrum.
   *  Use with <code>getEnergy()</code> to measure amplitude at specific
   *  frequencies, or within a range of frequencies. </p>
   *
   *  <p>FFT analyzes a very short snapshot of sound called a sample
   *  buffer. It returns an array of amplitude measurements, referred
   *  to as <code>bins</code>. The array is 1024 bins long by default.
   *  You can change the bin array length, but it must be a power of 2
   *  between 16 and 1024 in order for the FFT algorithm to function
   *  correctly. The actual size of the FFT buffer is twice the
   *  number of bins, so given a standard sample rate, the buffer is
   *  2048/44100 seconds long.</p>
   *
   *
   *  @class p5.FFT
   *  @constructor
   *  @param {Number} [smoothing]   Smooth results of Freq Spectrum.
   *                                0.0 < smoothing < 1.0.
   *                                Defaults to 0.8.
   *  @param {Number} [bins]    Length of resulting array.
   *                            Must be a power of two between
   *                            16 and 1024. Defaults to 1024.
   *  @example
   *  <div><code>
   *  function preload(){
   *    sound = loadSound('assets/Damscray_DancingTiger.mp3');
   *  }
   *
   *  function setup(){
   *    let cnv = createCanvas(100,100);
   *    cnv.mouseClicked(togglePlay);
   *    fft = new p5.FFT();
   *    sound.amp(0.2);
   *  }
   *
   *  function draw(){
   *    background(220);
   *
   *    let spectrum = fft.analyze();
   *    noStroke();
   *    fill(255, 0, 255);
   *    for (let i = 0; i< spectrum.length; i++){
   *      let x = map(i, 0, spectrum.length, 0, width);
   *      let h = -height + map(spectrum[i], 0, 255, height, 0);
   *      rect(x, height, width / spectrum.length, h )
   *    }
   *
   *    let waveform = fft.waveform();
   *    noFill();
   *    beginShape();
   *    stroke(20);
   *    for (let i = 0; i < waveform.length; i++){
   *      let x = map(i, 0, waveform.length, 0, width);
   *      let y = map( waveform[i], -1, 1, 0, height);
   *      vertex(x,y);
   *    }
   *    endShape();
   *
   *    text('tap to play', 20, 20);
   *  }
   *
   *  function togglePlay() {
   *    if (sound.isPlaying()) {
   *      sound.pause();
   *    } else {
   *      sound.loop();
   *    }
   *  }
   *  </code></div>
   */


  p5.FFT = function (smoothing, bins) {
    this.input = this.analyser = p5sound.audiocontext.createAnalyser();
    Object.defineProperties(this, {
      bins: {
        get: function get() {
          return this.analyser.fftSize / 2;
        },
        set: function set(b) {
          this.analyser.fftSize = b * 2;
        },
        configurable: true,
        enumerable: true
      },
      smoothing: {
        get: function get() {
          return this.analyser.smoothingTimeConstant;
        },
        set: function set(s) {
          this.analyser.smoothingTimeConstant = s;
        },
        configurable: true,
        enumerable: true
      }
    }); 

    this.smooth(smoothing);
    this.bins = bins || 1024; 

    p5sound.fftMeter.connect(this.analyser);
    this.freqDomain = new Uint8Array(this.analyser.frequencyBinCount);
    this.timeDomain = new Uint8Array(this.analyser.frequencyBinCount); 

    this.bass = [20, 140];
    this.lowMid = [140, 400];
    this.mid = [400, 2600];
    this.highMid = [2600, 5200];
    this.treble = [5200, 14000]; 

    p5sound.soundArray.push(this);
  };
  /**
   *  Set the input source for the FFT analysis. If no source is
   *  provided, FFT will analyze all sound in the sketch.
   *
   *  @method  setInput
   *  @for p5.FFT
   *  @param {Object} [source] p5.sound object (or web audio API source node)
   */


  p5.FFT.prototype.setInput = function (source) {
    if (!source) {
      p5sound.fftMeter.connect(this.analyser);
    } else {
      if (source.output) {
        source.output.connect(this.analyser);
      } else if (source.connect) {
        source.connect(this.analyser);
      }

      p5sound.fftMeter.disconnect();
    }
  };
  /**
   *  Returns an array of amplitude values (between -1.0 and +1.0) that represent
   *  a snapshot of amplitude readings in a single buffer. Length will be
   *  equal to bins (defaults to 1024). Can be used to draw the waveform
   *  of a sound.
   *
   *  @method waveform
   *  @for p5.FFT
   *  @param {Number} [bins]    Must be a power of two between
   *                            16 and 1024. Defaults to 1024.
   *  @param {String} [precision] If any value is provided, will return results
   *                              in a Float32 Array which is more precise
   *                              than a regular array.
   *  @return {Array}  Array    Array of amplitude values (-1 to 1)
   *                            over time. Array length = bins.
   *
   */


  p5.FFT.prototype.waveform = function () {
    var bins, mode, normalArray;

    for (var i = 0; i < arguments.length; i++) {
      if (typeof arguments[i] === 'number') {
        bins = arguments[i];
        this.analyser.fftSize = bins * 2;
      }

      if (typeof arguments[i] === 'string') {
        mode = arguments[i];
      }
    } 


    if (mode && !p5.prototype._isSafari()) {
      timeToFloat(this, this.timeDomain);
      this.analyser.getFloatTimeDomainData(this.timeDomain);
      return this.timeDomain;
    } else {
      timeToInt(this, this.timeDomain);
      this.analyser.getByteTimeDomainData(this.timeDomain);
      var normalArray = new Array();

      for (var j = 0; j < this.timeDomain.length; j++) {
        var scaled = p5.prototype.map(this.timeDomain[j], 0, 255, -1, 1);
        normalArray.push(scaled);
      }

      return normalArray;
    }
  };
  /**
   *  Returns an array of amplitude values (between 0 and 255)
   *  across the frequency spectrum. Length is equal to FFT bins
   *  (1024 by default). The array indices correspond to frequencies
   *  (i.e. pitches), from the lowest to the highest that humans can
   *  hear. Each value represents amplitude at that slice of the
   *  frequency spectrum. Must be called prior to using
   *  <code>getEnergy()</code>.
   *
   *  @method analyze
   *  @for p5.FFT
   *  @param {Number} [bins]    Must be a power of two between
   *                             16 and 1024. Defaults to 1024.
   *  @param {Number} [scale]    If "dB," returns decibel
   *                             float measurements between
   *                             -140 and 0 (max).
   *                             Otherwise returns integers from 0-255.
   *  @return {Array} spectrum    Array of energy (amplitude/volume)
   *                              values across the frequency spectrum.
   *                              Lowest energy (silence) = 0, highest
   *                              possible is 255.
   *  @example
   *  <div><code>
   *  let osc, fft;
   *
   *  function setup(){
   *    let cnv = createCanvas(100,100);
   *    cnv.mousePressed(startSound);
   *    osc = new p5.Oscillator();
   *    osc.amp(0);
   *    fft = new p5.FFT();
   *  }
   *
   *  function draw(){
   *    background(220);
   *
   *    let freq = map(mouseX, 0, windowWidth, 20, 10000);
   *    freq = constrain(freq, 1, 20000);
   *    osc.freq(freq);
   *
   *    let spectrum = fft.analyze();
   *    noStroke();
   *    fill(255, 0, 255);
   *    for (let i = 0; i< spectrum.length; i++){
   *      let x = map(i, 0, spectrum.length, 0, width);
   *      let h = -height + map(spectrum[i], 0, 255, height, 0);
   *      rect(x, height, width / spectrum.length, h );
   *    }
   *
   *    stroke(255);
   *    if (!osc.started) {
   *      text('tap here and drag to change frequency', 10, 20, width - 20);
   *    } else {
   *      text(round(freq)+'Hz', 10, 20);
   *    }
   *  }
   *
   *  function startSound() {
   *    osc.start();
   *    osc.amp(0.5, 0.2);
   *  }
   *
   *  function mouseReleased() {
   *    osc.amp(0, 0.2);
   *  }
   *  </code></div>
   *
   *
   */


  p5.FFT.prototype.analyze = function () {
    var mode;

    for (var i = 0; i < arguments.length; i++) {
      if (typeof arguments[i] === 'number') {
        this.bins = arguments[i];
        this.analyser.fftSize = this.bins * 2;
      }

      if (typeof arguments[i] === 'string') {
        mode = arguments[i];
      }
    }

    if (mode && mode.toLowerCase() === 'db') {
      freqToFloat(this);
      this.analyser.getFloatFrequencyData(this.freqDomain);
      return this.freqDomain;
    } else {
      freqToInt(this, this.freqDomain);
      this.analyser.getByteFrequencyData(this.freqDomain);
      var normalArray = Array.apply([], this.freqDomain);
      return normalArray;
    }
  };
  /**
   *  Returns the amount of energy (volume) at a specific
   *  <a href="https://en.wikipedia.org/wiki/Audio_frequency" target="_blank">
   *  frequency</a>, or the average amount of energy between two
   *  frequencies. Accepts Number(s) corresponding
   *  to frequency (in Hz), or a String corresponding to predefined
   *  frequency ranges ("bass", "lowMid", "mid", "highMid", "treble").
   *  Returns a range between 0 (no energy/volume at that frequency) and
   *  255 (maximum energy).
   *  <em>NOTE: analyze() must be called prior to getEnergy(). Analyze()
   *  tells the FFT to analyze frequency data, and getEnergy() uses
   *  the results determine the value at a specific frequency or
   *  range of frequencies.</em></p>
   *
   *  @method  getEnergy
   *  @for p5.FFT
   *  @param  {Number|String} frequency1   Will return a value representing
   *                                energy at this frequency. Alternately,
   *                                the strings "bass", "lowMid" "mid",
   *                                "highMid", and "treble" will return
   *                                predefined frequency ranges.
   *  @param  {Number} [frequency2] If a second frequency is given,
   *                                will return average amount of
   *                                energy that exists between the
   *                                two frequencies.
   *  @return {Number}   Energy   Energy (volume/amplitude) from
   *                              0 and 255.
   *
   */


  p5.FFT.prototype.getEnergy = function (frequency1, frequency2) {
    var nyquist = p5sound.audiocontext.sampleRate / 2;

    if (frequency1 === 'bass') {
      frequency1 = this.bass[0];
      frequency2 = this.bass[1];
    } else if (frequency1 === 'lowMid') {
      frequency1 = this.lowMid[0];
      frequency2 = this.lowMid[1];
    } else if (frequency1 === 'mid') {
      frequency1 = this.mid[0];
      frequency2 = this.mid[1];
    } else if (frequency1 === 'highMid') {
      frequency1 = this.highMid[0];
      frequency2 = this.highMid[1];
    } else if (frequency1 === 'treble') {
      frequency1 = this.treble[0];
      frequency2 = this.treble[1];
    }

    if (typeof frequency1 !== 'number') {
      throw 'invalid input for getEnergy()';
    } else if (!frequency2) {
      var index = Math.round(frequency1 / nyquist * this.freqDomain.length);
      return this.freqDomain[index];
    } else if (frequency1 && frequency2) {
      if (frequency1 > frequency2) {
        var swap = frequency2;
        frequency2 = frequency1;
        frequency1 = swap;
      }

      var lowIndex = Math.round(frequency1 / nyquist * this.freqDomain.length);
      var highIndex = Math.round(frequency2 / nyquist * this.freqDomain.length);
      var total = 0;
      var numFrequencies = 0; 

      for (var i = lowIndex; i <= highIndex; i++) {
        total += this.freqDomain[i];
        numFrequencies += 1;
      } 


      var toReturn = total / numFrequencies;
      return toReturn;
    } else {
      throw 'invalid input for getEnergy()';
    }
  }; 


  p5.FFT.prototype.getFreq = function (freq1, freq2) {
    console.log('getFreq() is deprecated. Please use getEnergy() instead.');
    var x = this.getEnergy(freq1, freq2);
    return x;
  };
  /**
   *  Returns the
   *  <a href="http://en.wikipedia.org/wiki/Spectral_centroid" target="_blank">
   *  spectral centroid</a> of the input signal.
   *  <em>NOTE: analyze() must be called prior to getCentroid(). Analyze()
   *  tells the FFT to analyze frequency data, and getCentroid() uses
   *  the results determine the spectral centroid.</em></p>
   *
   *  @method  getCentroid
   *  @for p5.FFT
   *  @return {Number}   Spectral Centroid Frequency   Frequency of the spectral centroid in Hz.
   *
   *
   * @example
   *  <div><code>
   * function setup(){
   *  cnv = createCanvas(100,100);
   *  cnv.mousePressed(userStartAudio);
   *  sound = new p5.AudioIn();
   *  sound.start();
   *  fft = new p5.FFT();
   *  sound.connect(fft);
   *}
   *
   *function draw() {
   *  if (getAudioContext().state !== 'running') {
   *    background(220);
   *    text('tap here and enable mic to begin', 10, 20, width - 20);
   *    return;
   *  }
   *  let centroidplot = 0.0;
   *  let spectralCentroid = 0;
   *
   *  background(0);
   *  stroke(0,255,0);
   *  let spectrum = fft.analyze();
   *  fill(0,255,0); // spectrum is green
   *
   *  //draw the spectrum
   *  for (let i = 0; i < spectrum.length; i++){
   *    let x = map(log(i), 0, log(spectrum.length), 0, width);
   *    let h = map(spectrum[i], 0, 255, 0, height);
   *    let rectangle_width = (log(i+1)-log(i))*(width/log(spectrum.length));
   *    rect(x, height, rectangle_width, -h )
   *  }
   *  let nyquist = 22050;
   *
   *  // get the centroid
   *  spectralCentroid = fft.getCentroid();
   *
   *  // the mean_freq_index calculation is for the display.
   *  let mean_freq_index = spectralCentroid/(nyquist/spectrum.length);
   *
   *  centroidplot = map(log(mean_freq_index), 0, log(spectrum.length), 0, width);
   *
   *  stroke(255,0,0); // the line showing where the centroid is will be red
   *
   *  rect(centroidplot, 0, width / spectrum.length, height)
   *  noStroke();
   *  fill(255,255,255);  // text is white
   *  text('centroid: ', 10, 20);
   *  text(round(spectralCentroid)+' Hz', 10, 40);
   *}
   * </code></div>
   */


  p5.FFT.prototype.getCentroid = function () {
    var nyquist = p5sound.audiocontext.sampleRate / 2;
    var cumulative_sum = 0;
    var centroid_normalization = 0;

    for (var i = 0; i < this.freqDomain.length; i++) {
      cumulative_sum += i * this.freqDomain[i];
      centroid_normalization += this.freqDomain[i];
    }

    var mean_freq_index = 0;

    if (centroid_normalization !== 0) {
      mean_freq_index = cumulative_sum / centroid_normalization;
    }

    var spec_centroid_freq = mean_freq_index * (nyquist / this.freqDomain.length);
    return spec_centroid_freq;
  };
  /**
   *  Smooth FFT analysis by averaging with the last analysis frame.
   *
   *  @method smooth
   *  @param {Number} smoothing    0.0 < smoothing < 1.0.
   *                               Defaults to 0.8.
   */


  p5.FFT.prototype.smooth = function (s) {
    if (typeof s !== 'undefined') {
      this.smoothing = s;
    }

    return this.smoothing;
  };

  p5.FFT.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);

    if (this.analyser) {
      this.analyser.disconnect();
      delete this.analyser;
    }
  };
  /**
   *  Returns an array of average amplitude values for a given number
   *  of frequency bands split equally. N defaults to 16.
   *  <em>NOTE: analyze() must be called prior to linAverages(). Analyze()
   *  tells the FFT to analyze frequency data, and linAverages() uses
   *  the results to group them into a smaller set of averages.</em></p>
   *
   *  @method  linAverages
   *  @for p5.FFT
   *  @param  {Number}  N                Number of returned frequency groups
   *  @return {Array}   linearAverages   Array of average amplitude values for each group
   */


  p5.FFT.prototype.linAverages = function (N) {
    var N = N || 16; 

    var spectrum = this.freqDomain;
    var spectrumLength = spectrum.length;
    var spectrumStep = Math.floor(spectrumLength / N);
    var linearAverages = new Array(N); 

    var groupIndex = 0;

    for (var specIndex = 0; specIndex < spectrumLength; specIndex++) {
      linearAverages[groupIndex] = linearAverages[groupIndex] !== undefined ? (linearAverages[groupIndex] + spectrum[specIndex]) / 2 : spectrum[specIndex]; 

      if (specIndex % spectrumStep === spectrumStep - 1) {
        groupIndex++;
      }
    }

    return linearAverages;
  };
  /**
   *  Returns an array of average amplitude values of the spectrum, for a given
   *  set of <a href="https://en.wikipedia.org/wiki/Octave_band" target="_blank">
   *  Octave Bands</a>
   *  <em>NOTE: analyze() must be called prior to logAverages(). Analyze()
   *  tells the FFT to analyze frequency data, and logAverages() uses
   *  the results to group them into a smaller set of averages.</em></p>
   *
   *  @method  logAverages
   *  @for p5.FFT
   *  @param  {Array}   octaveBands    Array of Octave Bands objects for grouping
   *  @return {Array}   logAverages    Array of average amplitude values for each group
   */


  p5.FFT.prototype.logAverages = function (octaveBands) {
    var nyquist = p5sound.audiocontext.sampleRate / 2;
    var spectrum = this.freqDomain;
    var spectrumLength = spectrum.length;
    var logAverages = new Array(octaveBands.length); 

    var octaveIndex = 0;

    for (var specIndex = 0; specIndex < spectrumLength; specIndex++) {
      var specIndexFrequency = Math.round(specIndex * nyquist / this.freqDomain.length); 

      if (specIndexFrequency > octaveBands[octaveIndex].hi) {
        octaveIndex++;
      }

      logAverages[octaveIndex] = logAverages[octaveIndex] !== undefined ? (logAverages[octaveIndex] + spectrum[specIndex]) / 2 : spectrum[specIndex];
    }

    return logAverages;
  };
  /**
   *  Calculates and Returns the 1/N
   *  <a href="https://en.wikipedia.org/wiki/Octave_band" target="_blank">Octave Bands</a>
   *  N defaults to 3 and minimum central frequency to 15.625Hz.
   *  (1/3 Octave Bands ~= 31 Frequency Bands)
   *  Setting fCtr0 to a central value of a higher octave will ignore the lower bands
   *  and produce less frequency groups.
   *
   *  @method   getOctaveBands
   *  @for p5.FFT
   *  @param  {Number}  N             Specifies the 1/N type of generated octave bands
   *  @param  {Number}  fCtr0         Minimum central frequency for the lowest band
   *  @return {Array}   octaveBands   Array of octave band objects with their bounds
   */


  p5.FFT.prototype.getOctaveBands = function (N, fCtr0) {
    var N = N || 3; 

    var fCtr0 = fCtr0 || 15.625; 

    var octaveBands = [];
    var lastFrequencyBand = {
      lo: fCtr0 / Math.pow(2, 1 / (2 * N)),
      ctr: fCtr0,
      hi: fCtr0 * Math.pow(2, 1 / (2 * N))
    };
    octaveBands.push(lastFrequencyBand);
    var nyquist = p5sound.audiocontext.sampleRate / 2;

    while (lastFrequencyBand.hi < nyquist) {
      var newFrequencyBand = {};
      newFrequencyBand.lo = lastFrequencyBand.hi;
      newFrequencyBand.ctr = lastFrequencyBand.ctr * Math.pow(2, 1 / N);
      newFrequencyBand.hi = newFrequencyBand.ctr * Math.pow(2, 1 / (2 * N));
      octaveBands.push(newFrequencyBand);
      lastFrequencyBand = newFrequencyBand;
    }

    return octaveBands;
  }; 


  var freqToFloat = function freqToFloat(fft) {
    if (fft.freqDomain instanceof Float32Array === false) {
      fft.freqDomain = new Float32Array(fft.analyser.frequencyBinCount);
    }
  };

  var freqToInt = function freqToInt(fft) {
    if (fft.freqDomain instanceof Uint8Array === false) {
      fft.freqDomain = new Uint8Array(fft.analyser.frequencyBinCount);
    }
  };

  var timeToFloat = function timeToFloat(fft) {
    if (fft.timeDomain instanceof Float32Array === false) {
      fft.timeDomain = new Float32Array(fft.analyser.frequencyBinCount);
    }
  };

  var timeToInt = function timeToInt(fft) {
    if (fft.timeDomain instanceof Uint8Array === false) {
      fft.timeDomain = new Uint8Array(fft.analyser.frequencyBinCount);
    }
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var Signal = __webpack_require__(2);

  var Add = __webpack_require__(7);

  var Mult = __webpack_require__(3);

  var Scale = __webpack_require__(13);
  /**
   *  <p>p5.Signal is a constant audio-rate signal used by p5.Oscillator
   *  and p5.Envelope for modulation math.</p>
   *
   *  <p>This is necessary because Web Audio is processed on a seprate clock.
   *  For example, the p5 draw loop runs about 60 times per second. But
   *  the audio clock must process samples 44100 times per second. If we
   *  want to add a value to each of those samples, we can't do it in the
   *  draw loop, but we can do it by adding a constant-rate audio signal.</p.
   *
   *  <p>This class mostly functions behind the scenes in p5.sound, and returns
   *  a Tone.Signal from the Tone.js library by Yotam Mann.
   *  If you want to work directly with audio signals for modular
   *  synthesis, check out
   *  <a href='http://bit.ly/1oIoEng' target=_'blank'>tone.js.</a></p>
   *
   *  @class  p5.Signal
   *  @constructor
   *  @return {Tone.Signal} A Signal object from the Tone.js library
   *  @example
   *  <div><code>
   *  let carrier, modulator;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    text('tap to play', 20, 20);
   *
   *    carrier = new p5.Oscillator('sine');
   *    carrier.start();
   *    carrier.amp(1); // set amplitude
   *    carrier.freq(220); // set frequency
   *
   *    modulator = new p5.Oscillator('sawtooth');
   *    modulator.disconnect();
   *    modulator.start();
   *    modulator.amp(1);
   *    modulator.freq(4);
   *
   *    // Modulator's default amplitude range is -1 to 1.
   *    // Multiply it by -200, so the range is -200 to 200
   *    // then add 220 so the range is 20 to 420
   *    carrier.freq( modulator.mult(-400).add(220) );
   *  }
   *
   *  function canvasPressed() {
   *    userStartAudio();
   *    carrier.amp(1.0);
   *  }
   *
   *  function mouseReleased() {
   *    carrier.amp(0);
   *  }
   *  </code></div>
   */


  p5.Signal = function (value) {
    var s = new Signal(value); 

    return s; 
  };
  /**
   *  Fade to value, for smooth transitions
   *
   *  @method  fade
   *  @for p5.Signal
   *  @param  {Number} value          Value to set this signal
   *  @param  {Number} [secondsFromNow] Length of fade, in seconds from now
   */


  Signal.prototype.fade = Signal.prototype.linearRampToValueAtTime;
  Mult.prototype.fade = Signal.prototype.fade;
  Add.prototype.fade = Signal.prototype.fade;
  Scale.prototype.fade = Signal.prototype.fade;
  /**
   *  Connect a p5.sound object or Web Audio node to this
   *  p5.Signal so that its amplitude values can be scaled.
   *
   *  @method setInput
   *  @for p5.Signal
   *  @param {Object} input
   */

  Signal.prototype.setInput = function (_input) {
    _input.connect(this);
  };

  Mult.prototype.setInput = Signal.prototype.setInput;
  Add.prototype.setInput = Signal.prototype.setInput;
  Scale.prototype.setInput = Signal.prototype.setInput; 

  /**
   *  Add a constant value to this audio signal,
   *  and return the resulting audio signal. Does
   *  not change the value of the original signal,
   *  instead it returns a new p5.SignalAdd.
   *
   *  @method  add
   *  @for p5.Signal
   *  @param {Number} number
   *  @return {p5.Signal} object
   */

  Signal.prototype.add = function (num) {
    var add = new Add(num); 

    this.connect(add);
    return add;
  };

  Mult.prototype.add = Signal.prototype.add;
  Add.prototype.add = Signal.prototype.add;
  Scale.prototype.add = Signal.prototype.add;
  /**
   *  Multiply this signal by a constant value,
   *  and return the resulting audio signal. Does
   *  not change the value of the original signal,
   *  instead it returns a new p5.SignalMult.
   *
   *  @method  mult
   *  @for p5.Signal
   *  @param {Number} number to multiply
   *  @return {p5.Signal} object
   */

  Signal.prototype.mult = function (num) {
    var mult = new Mult(num); 

    this.connect(mult);
    return mult;
  };

  Mult.prototype.mult = Signal.prototype.mult;
  Add.prototype.mult = Signal.prototype.mult;
  Scale.prototype.mult = Signal.prototype.mult;
  /**
   *  Scale this signal value to a given range,
   *  and return the result as an audio signal. Does
   *  not change the value of the original signal,
   *  instead it returns a new p5.SignalScale.
   *
   *  @method  scale
   *  @for p5.Signal
   *  @param {Number} number to multiply
   *  @param  {Number} inMin  input range minumum
   *  @param  {Number} inMax  input range maximum
   *  @param  {Number} outMin input range minumum
   *  @param  {Number} outMax input range maximum
   *  @return {p5.Signal} object
   */

  Signal.prototype.scale = function (inMin, inMax, outMin, outMax) {
    var mapOutMin, mapOutMax;

    if (arguments.length === 4) {
      mapOutMin = p5.prototype.map(outMin, inMin, inMax, 0, 1) - 0.5;
      mapOutMax = p5.prototype.map(outMax, inMin, inMax, 0, 1) - 0.5;
    } else {
      mapOutMin = arguments[0];
      mapOutMax = arguments[1];
    }

    var scale = new Scale(mapOutMin, mapOutMax);
    this.connect(scale);
    return scale;
  };

  Mult.prototype.scale = Signal.prototype.scale;
  Add.prototype.scale = Signal.prototype.scale;
  Scale.prototype.scale = Signal.prototype.scale;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){o.Frequency=function(e,t){if(!(this instanceof o.Frequency))return new o.Frequency(e,t);o.TimeBase.call(this,e,t)},o.extend(o.Frequency,o.TimeBase),o.Frequency.prototype._primaryExpressions=Object.create(o.TimeBase.prototype._primaryExpressions),o.Frequency.prototype._primaryExpressions.midi={regexp:/^(\d+(?:\.\d+)?midi)/,method:function(e){return this.midiToFrequency(e)}},o.Frequency.prototype._primaryExpressions.note={regexp:/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,method:function(e,t){var r=n[e.toLowerCase()]+12*(parseInt(t)+1);return this.midiToFrequency(r)}},o.Frequency.prototype._primaryExpressions.tr={regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,method:function(e,t,r){var n=1;return e&&"0"!==e&&(n*=this._beatsToUnits(this._timeSignature()*parseFloat(e))),t&&"0"!==t&&(n*=this._beatsToUnits(parseFloat(t))),r&&"0"!==r&&(n*=this._beatsToUnits(parseFloat(r)/4)),n}},o.Frequency.prototype.transpose=function(e){return this._expr=function(e,t){return e()*this.intervalToFrequencyRatio(t)}.bind(this,this._expr,e),this},o.Frequency.prototype.harmonize=function(e){return this._expr=function(e,t){for(var r=e(),n=[],o=0;o<t.length;o++)n[o]=r*this.intervalToFrequencyRatio(t[o]);return n}.bind(this,this._expr,e),this},o.Frequency.prototype.toMidi=function(){return this.frequencyToMidi(this.valueOf())},o.Frequency.prototype.toNote=function(){var e=this.valueOf(),t=Math.log(e/o.Frequency.A4)/Math.LN2,r=Math.round(12*t)+57,n=Math.floor(r/12);return n<0&&(r+=-12*n),i[r%12]+n.toString()},o.Frequency.prototype.toSeconds=function(){return 1/this.valueOf()},o.Frequency.prototype.toFrequency=function(){return this.valueOf()},o.Frequency.prototype.toTicks=function(){var e=this._beatsToUnits(1),t=this.valueOf()/e;return Math.floor(t*o.Transport.PPQ)},o.Frequency.prototype._frequencyToUnits=function(e){return e},o.Frequency.prototype._ticksToUnits=function(e){return 1/(60*e/(o.Transport.bpm.value*o.Transport.PPQ))},o.Frequency.prototype._beatsToUnits=function(e){return 1/o.TimeBase.prototype._beatsToUnits.call(this,e)},o.Frequency.prototype._secondsToUnits=function(e){return 1/e},o.Frequency.prototype._defaultUnits="hz";var n={cbb:-2,cb:-1,c:0,"c#":1,cx:2,dbb:0,db:1,d:2,"d#":3,dx:4,ebb:2,eb:3,e:4,"e#":5,ex:6,fbb:3,fb:4,f:5,"f#":6,fx:7,gbb:5,gb:6,g:7,"g#":8,gx:9,abb:7,ab:8,a:9,"a#":10,ax:11,bbb:9,bb:10,b:11,"b#":12,bx:13},i=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];return o.Frequency.A4=440,o.Frequency.prototype.midiToFrequency=function(e){return o.Frequency.A4*Math.pow(2,(e-69)/12)},o.Frequency.prototype.frequencyToMidi=function(e){return 69+12*Math.log(e/o.Frequency.A4)/Math.LN2},o.Frequency}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(20)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){return o.TransportTime=function(t,r){if(!(this instanceof o.TransportTime))return new o.TransportTime(t,r);o.Time.call(this,t,r)},o.extend(o.TransportTime,o.Time),o.TransportTime.prototype._unaryExpressions=Object.create(o.Time.prototype._unaryExpressions),o.TransportTime.prototype._unaryExpressions.quantize={regexp:/^@/,method:function(t){var r=this._secondsToTicks(t()),e=Math.ceil(o.Transport.ticks/r);return this._ticksToUnits(e*r)}},o.TransportTime.prototype._secondsToTicks=function(t){var r=t/this._beatsToUnits(1);return Math.round(r*o.Transport.PPQ)},o.TransportTime.prototype.valueOf=function(){return this._secondsToTicks(this._expr())+(this._plusNow?o.Transport.ticks:0)},o.TransportTime.prototype.toTicks=function(){return this.valueOf()},o.TransportTime.prototype.toSeconds=function(){return this._expr()+(this._plusNow?o.Transport.seconds:0)},o.TransportTime.prototype.toFrequency=function(){return 1/this.toSeconds()},o.TransportTime}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var Add = __webpack_require__(7);

  var Mult = __webpack_require__(3);

  var Scale = __webpack_require__(13);

  var TimelineSignal = __webpack_require__(14);
  /**
   *  <p>Envelopes are pre-defined amplitude distribution over time.
   *  Typically, envelopes are used to control the output volume
   *  of an object, a series of fades referred to as Attack, Decay,
   *  Sustain and Release (
   *  <a href="https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg">ADSR</a>
   *  ). Envelopes can also control other Web Audio Parametersfor example, a p5.Envelope can
   *  control an Oscillator's frequency like this: <code>osc.freq(env)</code>.</p>
   *  <p>Use <code><a href="#/p5.Envelope/setRange">setRange</a></code> to change the attack/release level.
   *  Use <code><a href="#/p5.Envelope/setADSR">setADSR</a></code> to change attackTime, decayTime, sustainPercent and releaseTime.</p>
   *  <p>Use the <code><a href="#/p5.Envelope/play">play</a></code> method to play the entire envelope,
   *  the <code><a href="#/p5.Envelope/ramp">ramp</a></code> method for a pingable trigger,
   *  or <code><a href="#/p5.Envelope/triggerAttack">triggerAttack</a></code>/
   *  <code><a href="#/p5.Envelope/triggerRelease">triggerRelease</a></code> to trigger noteOn/noteOff.</p>
   *
   *  @class p5.Envelope
   *  @constructor
   *  @example
   *  <div><code>
   *  let t1 = 0.1; // attack time in seconds
   *  let l1 = 0.7; // attack level 0.0 to 1.0
   *  let t2 = 0.3; // decay time in seconds
   *  let l2 = 0.1; // decay level  0.0 to 1.0
   *
   *  let env;
   *  let triOsc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    background(220);
   *    text('tap to play', 20, 20);
   *    cnv.mousePressed(playSound);
   *
   *    env = new p5.Envelope(t1, l1, t2, l2);
   *    triOsc = new p5.Oscillator('triangle');
   *  }
   *
   *  function playSound() {
   *    // starting the oscillator ensures that audio is enabled.
   *    triOsc.start();
   *    env.play(triOsc);
   *  }
   *  </code></div>
   */


  p5.Envelope = function (t1, l1, t2, l2, t3, l3) {
    /**
     * Time until envelope reaches attackLevel
     * @property attackTime
     */
    this.aTime = t1 || 0.1;
    /**
     * Level once attack is complete.
     * @property attackLevel
     */

    this.aLevel = l1 || 1;
    /**
     * Time until envelope reaches decayLevel.
     * @property decayTime
     */

    this.dTime = t2 || 0.5;
    /**
     * Level after decay. The envelope will sustain here until it is released.
     * @property decayLevel
     */

    this.dLevel = l2 || 0;
    /**
     * Duration of the release portion of the envelope.
     * @property releaseTime
     */

    this.rTime = t3 || 0;
    /**
     * Level at the end of the release.
     * @property releaseLevel
     */

    this.rLevel = l3 || 0;
    this._rampHighPercentage = 0.98;
    this._rampLowPercentage = 0.02;
    this.output = p5sound.audiocontext.createGain();
    this.control = new TimelineSignal();

    this._init(); 


    this.control.connect(this.output); 

    this.connection = null; 

    this.mathOps = [this.control]; 

    this.isExponential = false; 

    this.sourceToClear = null; 

    this.wasTriggered = false; 

    p5sound.soundArray.push(this);
  }; 


  p5.Envelope.prototype._init = function () {
    var now = p5sound.audiocontext.currentTime;
    var t = now;
    this.control.setTargetAtTime(0.00001, t, .001); 

    this._setRampAD(this.aTime, this.dTime);
  };
  /**
   *  Reset the envelope with a series of time/value pairs.
   *
   *  @method  set
   *  @for p5.Envelope
   *  @param {Number} attackTime     Time (in seconds) before level
   *                                 reaches attackLevel
   *  @param {Number} attackLevel    Typically an amplitude between
   *                                 0.0 and 1.0
   *  @param {Number} decayTime      Time
   *  @param {Number} decayLevel   Amplitude (In a standard ADSR envelope,
   *                                 decayLevel = sustainLevel)
   *  @param {Number} releaseTime   Release Time (in seconds)
   *  @param {Number} releaseLevel  Amplitude
   *  @example
   *  <div><code>
   *  let attackTime;
   *  let l1 = 0.7; // attack level 0.0 to 1.0
   *  let t2 = 0.3; // decay time in seconds
   *  let l2 = 0.1; // decay level  0.0 to 1.0
   *  let l3 = 0.2; // release time in seconds
   *
   *  let env, triOsc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playSound);
   *
   *    env = new p5.Envelope();
   *    triOsc = new p5.Oscillator('triangle');
   *  }
   *
   *  function draw() {
   *    background(220);
   *    text('tap here to play', 5, 20);
   *
   *    attackTime = map(mouseX, 0, width, 0.0, 1.0);
   *    text('attack time: ' + attackTime, 5, height - 20);
   *  }
   *
   *  // mouseClick triggers envelope if over canvas
   *  function playSound() {
   *    env.set(attackTime, l1, t2, l2, l3);
   *
   *    triOsc.start();
   *    env.play(triOsc);
   *  }
   *  </code></div>
   *
   */


  p5.Envelope.prototype.set = function (t1, l1, t2, l2, t3, l3) {
    this.aTime = t1;
    this.aLevel = l1;
    this.dTime = t2 || 0;
    this.dLevel = l2 || 0;
    this.rTime = t3 || 0;
    this.rLevel = l3 || 0; 

    this._setRampAD(t1, t2);
  };
  /**
   *  Set values like a traditional
   *  <a href="https://en.wikipedia.org/wiki/Synthesizer#/media/File:ADSR_parameter.svg">
   *  ADSR envelope
   *  </a>.
   *
   *  @method  setADSR
   *  @for p5.Envelope
   *  @param {Number} attackTime    Time (in seconds before envelope
   *                                reaches Attack Level
   *  @param {Number} [decayTime]    Time (in seconds) before envelope
   *                                reaches Decay/Sustain Level
   *  @param {Number} [susRatio]    Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,
   *                                where 1.0 = attackLevel, 0.0 = releaseLevel.
   *                                The susRatio determines the decayLevel and the level at which the
   *                                sustain portion of the envelope will sustain.
   *                                For example, if attackLevel is 0.4, releaseLevel is 0,
   *                                and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is
   *                                increased to 1.0 (using <code>setRange</code>),
   *                                then decayLevel would increase proportionally, to become 0.5.
   *  @param {Number} [releaseTime]   Time in seconds from now (defaults to 0)
   *  @example
   *  <div><code>
   *  let attackLevel = 1.0;
   *  let releaseLevel = 0;
   *
   *  let attackTime = 0.001;
   *  let decayTime = 0.2;
   *  let susPercent = 0.2;
   *  let releaseTime = 0.5;
   *
   *  let env, triOsc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playEnv);
   *
   *    env = new p5.Envelope();
   *    triOsc = new p5.Oscillator('triangle');
   *    triOsc.amp(env);
   *    triOsc.freq(220);
   *  }
   *
   *  function draw() {
   *    background(220);
   *    text('tap here to play', 5, 20);
   *    attackTime = map(mouseX, 0, width, 0, 1.0);
   *    text('attack time: ' + attackTime, 5, height - 40);
   *  }
   *
   *  function playEnv() {
   *    triOsc.start();
   *    env.setADSR(attackTime, decayTime, susPercent, releaseTime);
   *    env.play();
   *  }
   *  </code></div>
   */


  p5.Envelope.prototype.setADSR = function (aTime, dTime, sPercent, rTime) {
    this.aTime = aTime;
    this.dTime = dTime || 0; 

    this.sPercent = sPercent || 0;
    this.dLevel = typeof sPercent !== 'undefined' ? sPercent * (this.aLevel - this.rLevel) + this.rLevel : 0;
    this.rTime = rTime || 0; 

    this._setRampAD(aTime, dTime);
  };
  /**
   *  Set max (attackLevel) and min (releaseLevel) of envelope.
   *
   *  @method  setRange
   *  @for p5.Envelope
   *  @param {Number} aLevel attack level (defaults to 1)
   *  @param {Number} rLevel release level (defaults to 0)
   *  @example
   *  <div><code>
   *  let attackLevel = 1.0;
   *  let releaseLevel = 0;
   *
   *  let attackTime = 0.001;
   *  let decayTime = 0.2;
   *  let susPercent = 0.2;
   *  let releaseTime = 0.5;
   *
   *  let env, triOsc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playEnv);
   *
   *    env = new p5.Envelope();
   *    triOsc = new p5.Oscillator('triangle');
   *    triOsc.amp(env);
   *    triOsc.freq(220);
   *  }
   *
   *  function draw() {
   *    background(220);
   *    text('tap here to play', 5, 20);
   *    attackLevel = map(mouseY, height, 0, 0, 1.0);
   *    text('attack level: ' + attackLevel, 5, height - 20);
   *  }
   *
   *  function playEnv() {
   *    triOsc.start();
   *    env.setRange(attackLevel, releaseLevel);
   *    env.play();
   *  }
   *  </code></div>
   */


  p5.Envelope.prototype.setRange = function (aLevel, rLevel) {
    this.aLevel = aLevel || 1;
    this.rLevel = rLevel || 0; 
  }; 


  p5.Envelope.prototype._setRampAD = function (t1, t2) {
    this._rampAttackTime = this.checkExpInput(t1);
    this._rampDecayTime = this.checkExpInput(t2);
    var TCDenominator = 1.0; 

    TCDenominator = Math.log(1.0 / this.checkExpInput(1.0 - this._rampHighPercentage));
    this._rampAttackTC = t1 / this.checkExpInput(TCDenominator);
    TCDenominator = Math.log(1.0 / this._rampLowPercentage);
    this._rampDecayTC = t2 / this.checkExpInput(TCDenominator);
  }; 


  p5.Envelope.prototype.setRampPercentages = function (p1, p2) {
    this._rampHighPercentage = this.checkExpInput(p1);
    this._rampLowPercentage = this.checkExpInput(p2);
    var TCDenominator = 1.0; 

    TCDenominator = Math.log(1.0 / this.checkExpInput(1.0 - this._rampHighPercentage));
    this._rampAttackTC = this._rampAttackTime / this.checkExpInput(TCDenominator);
    TCDenominator = Math.log(1.0 / this._rampLowPercentage);
    this._rampDecayTC = this._rampDecayTime / this.checkExpInput(TCDenominator);
  };
  /**
   *  Assign a parameter to be controlled by this envelope.
   *  If a p5.Sound object is given, then the p5.Envelope will control its
   *  output gain. If multiple inputs are provided, the env will
   *  control all of them.
   *
   *  @method  setInput
   *  @for p5.Envelope
   *  @param  {Object} [...inputs]         A p5.sound object or
   *                                Web Audio Param.
   */


  p5.Envelope.prototype.setInput = function () {
    for (var i = 0; i < arguments.length; i++) {
      this.connect(arguments[i]);
    }
  };
  /**
   *  Set whether the envelope ramp is linear (default) or exponential.
   *  Exponential ramps can be useful because we perceive amplitude
   *  and frequency logarithmically.
   *
   *  @method  setExp
   *  @for p5.Envelope
   *  @param {Boolean} isExp true is exponential, false is linear
   */


  p5.Envelope.prototype.setExp = function (isExp) {
    this.isExponential = isExp;
  }; 


  p5.Envelope.prototype.checkExpInput = function (value) {
    if (value <= 0) {
      value = 0.00000001;
    }

    return value;
  };
  /**
   *  <p>Play tells the envelope to start acting on a given input.
   *  If the input is a p5.sound object (i.e. AudioIn, Oscillator,
   *  SoundFile), then Envelope will control its output volume.
   *  Envelopes can also be used to control any <a href="
   *  http://docs.webplatform.org/wiki/apis/webaudio/AudioParam">
   *  Web Audio Audio Param.</a></p>
   *
   *  @method  play
   *  @for p5.Envelope
   *  @param  {Object} unit         A p5.sound object or
   *                                Web Audio Param.
   *  @param  {Number} [startTime]  time from now (in seconds) at which to play
   *  @param  {Number} [sustainTime] time to sustain before releasing the envelope
   *  @example
   *  <div><code>
   *  let attackLevel = 1.0;
   *  let releaseLevel = 0;
   *
   *  let attackTime = 0.001;
   *  let decayTime = 0.2;
   *  let susPercent = 0.2;
   *  let releaseTime = 0.5;
   *
   *  let env, triOsc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playEnv);
   *
   *    env = new p5.Envelope();
   *    triOsc = new p5.Oscillator('triangle');
   *    triOsc.amp(env);
   *    triOsc.freq(220);
   *    triOsc.start();
   *  }
   *
   *  function draw() {
   *    background(220);
   *    text('tap here to play', 5, 20);
   *    attackTime = map(mouseX, 0, width, 0, 1.0);
   *    attackLevel = map(mouseY, height, 0, 0, 1.0);
   *    text('attack time: ' + attackTime, 5, height - 40);
   *    text('attack level: ' + attackLevel, 5, height - 20);
   *  }
   *
   *  function playEnv() {
   *    // ensure that audio is enabled
   *    userStartAudio();
   *
   *    env.setADSR(attackTime, decayTime, susPercent, releaseTime);
   *    env.setRange(attackLevel, releaseLevel);
   *    env.play();
   *  }
   *  </code></div>
   */


  p5.Envelope.prototype.play = function (unit, secondsFromNow, susTime) {
    var tFromNow = secondsFromNow || 0;
    var susTime = susTime || 0;

    if (unit) {
      if (this.connection !== unit) {
        this.connect(unit);
      }
    }

    this.triggerAttack(unit, tFromNow);
    this.triggerRelease(unit, tFromNow + this.aTime + this.dTime + susTime);
  };
  /**
   *  Trigger the Attack, and Decay portion of the Envelope.
   *  Similar to holding down a key on a piano, but it will
   *  hold the sustain level until you let go. Input can be
   *  any p5.sound object, or a <a href="
   *  http://docs.webplatform.org/wiki/apis/webaudio/AudioParam">
   *  Web Audio Param</a>.
   *
   *  @method  triggerAttack
   *  @for p5.Envelope
   *  @param  {Object} unit p5.sound Object or Web Audio Param
   *  @param  {Number} secondsFromNow time from now (in seconds)
   *  @example
   *  <div><code>
   *  let attackTime = 0.001;
   *  let decayTime = 0.2;
   *  let susPercent = 0.3;
   *  let releaseTime = 0.4;
   *  let env, triOsc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    background(220);
   *    textAlign(CENTER);
   *    textSize(10);
   *    text('tap to triggerAttack', width/2, height/2);
   *
   *    env = new p5.Envelope();
   *    env.setADSR(attackTime, decayTime, susPercent, releaseTime);
   *    env.setRange(1.0, 0.0);
   *    triOsc = new p5.Oscillator('triangle');
   *    triOsc.freq(220);
   *
   *    cnv.mousePressed(envAttack);
   *  }
   *
   *  function envAttack()  {
   *    background(0, 255, 255);
   *    text('release to release', width/2, height/2);
   *
   *    // ensures audio is enabled. See also: `userStartAudio`
   *    triOsc.start();
   *
   *    env.triggerAttack(triOsc);
   *  }
   *
   *  function mouseReleased() {
   *    background(220);
   *    text('tap to triggerAttack', width/2, height/2);
   *
   *    env.triggerRelease(triOsc);
   *  }
   *  </code></div>
   */


  p5.Envelope.prototype.triggerAttack = function (unit, secondsFromNow) {
    var now = p5sound.audiocontext.currentTime;
    var tFromNow = secondsFromNow || 0;
    var t = now + tFromNow;
    this.lastAttack = t;
    this.wasTriggered = true;

    if (unit) {
      if (this.connection !== unit) {
        this.connect(unit);
      }
    } 


    var valToSet = this.control.getValueAtTime(t);

    if (this.isExponential === true) {
      this.control.exponentialRampToValueAtTime(this.checkExpInput(valToSet), t);
    } else {
      this.control.linearRampToValueAtTime(valToSet, t);
    } 


    t += this.aTime;

    if (this.isExponential === true) {
      this.control.exponentialRampToValueAtTime(this.checkExpInput(this.aLevel), t);
      valToSet = this.checkExpInput(this.control.getValueAtTime(t));
      this.control.cancelScheduledValues(t);
      this.control.exponentialRampToValueAtTime(valToSet, t);
    } else {
      this.control.linearRampToValueAtTime(this.aLevel, t);
      valToSet = this.control.getValueAtTime(t);
      this.control.cancelScheduledValues(t);
      this.control.linearRampToValueAtTime(valToSet, t);
    } 


    t += this.dTime;

    if (this.isExponential === true) {
      this.control.exponentialRampToValueAtTime(this.checkExpInput(this.dLevel), t);
      valToSet = this.checkExpInput(this.control.getValueAtTime(t));
      this.control.cancelScheduledValues(t);
      this.control.exponentialRampToValueAtTime(valToSet, t);
    } else {
      this.control.linearRampToValueAtTime(this.dLevel, t);
      valToSet = this.control.getValueAtTime(t);
      this.control.cancelScheduledValues(t);
      this.control.linearRampToValueAtTime(valToSet, t);
    }
  };
  /**
   *  Trigger the Release of the Envelope. This is similar to releasing
   *  the key on a piano and letting the sound fade according to the
   *  release level and release time.
   *
   *  @method  triggerRelease
   *  @for p5.Envelope
   *  @param  {Object} unit p5.sound Object or Web Audio Param
   *  @param  {Number} secondsFromNow time to trigger the release
   *  @example
   *  <div><code>
   *  let attackTime = 0.001;
   *  let decayTime = 0.2;
   *  let susPercent = 0.3;
   *  let releaseTime = 0.4;
   *  let env, triOsc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    background(220);
   *    textAlign(CENTER);
   *    textSize(10);
   *    text('tap to triggerAttack', width/2, height/2);
   *
   *    env = new p5.Envelope();
   *    env.setADSR(attackTime, decayTime, susPercent, releaseTime);
   *    env.setRange(1.0, 0.0);
   *    triOsc = new p5.Oscillator('triangle');
   *    triOsc.freq(220);
   *
   *    cnv.mousePressed(envAttack);
   *  }
   *
   *  function envAttack()  {
   *    background(0, 255, 255);
   *    text('release to release', width/2, height/2);
   *
   *    // ensures audio is enabled. See also: `userStartAudio`
   *    triOsc.start();
   *
   *    env.triggerAttack(triOsc);
   *  }
   *
   *  function mouseReleased() {
   *    background(220);
   *    text('tap to triggerAttack', width/2, height/2);
   *
   *    env.triggerRelease(triOsc);
   *  }
   *  </code></div>
   */


  p5.Envelope.prototype.triggerRelease = function (unit, secondsFromNow) {
    if (!this.wasTriggered) {
      return;
    }

    var now = p5sound.audiocontext.currentTime;
    var tFromNow = secondsFromNow || 0;
    var t = now + tFromNow;

    if (unit) {
      if (this.connection !== unit) {
        this.connect(unit);
      }
    } 


    var valToSet = this.control.getValueAtTime(t);

    if (this.isExponential === true) {
      this.control.exponentialRampToValueAtTime(this.checkExpInput(valToSet), t);
    } else {
      this.control.linearRampToValueAtTime(valToSet, t);
    } 


    t += this.rTime;

    if (this.isExponential === true) {
      this.control.exponentialRampToValueAtTime(this.checkExpInput(this.rLevel), t);
      valToSet = this.checkExpInput(this.control.getValueAtTime(t));
      this.control.cancelScheduledValues(t);
      this.control.exponentialRampToValueAtTime(valToSet, t);
    } else {
      this.control.linearRampToValueAtTime(this.rLevel, t);
      valToSet = this.control.getValueAtTime(t);
      this.control.cancelScheduledValues(t);
      this.control.linearRampToValueAtTime(valToSet, t);
    }

    this.wasTriggered = false;
  };
  /**
   *  Exponentially ramp to a value using the first two
   *  values from <code><a href="#/p5.Envelope/setADSR">setADSR(attackTime, decayTime)</a></code>
   *  as <a href="https://en.wikipedia.org/wiki/RC_time_constant">
   *  time constants</a> for simple exponential ramps.
   *  If the value is higher than current value, it uses attackTime,
   *  while a decrease uses decayTime.
   *
   *  @method  ramp
   *  @for p5.Envelope
   *  @param  {Object} unit           p5.sound Object or Web Audio Param
   *  @param  {Number} secondsFromNow When to trigger the ramp
   *  @param  {Number} v              Target value
   *  @param  {Number} [v2]           Second target value (optional)
   *  @example
   *  <div><code>
   *  let env, osc, amp;
   *
   *  let attackTime = 0.001;
   *  let decayTime = 0.2;
   *  let attackLevel = 1;
   *  let decayLevel = 0;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    fill(0,255,0);
   *    noStroke();
   *
   *    env = new p5.Envelope();
   *    env.setADSR(attackTime, decayTime);
   *    osc = new p5.Oscillator();
   *    osc.amp(env);
   *    amp = new p5.Amplitude();
   *
   *    cnv.mousePressed(triggerRamp);
   *  }
   *
   *  function triggerRamp() {
   *    // ensures audio is enabled. See also: `userStartAudio`
   *    osc.start();
   *
   *    env.ramp(osc, 0, attackLevel, decayLevel);
   *  }
   *
   *  function draw() {
   *    background(20);
   *    text('tap to play', 10, 20);
   *    let h = map(amp.getLevel(), 0, 0.4, 0, height);;
   *    rect(0, height, width, -h);
   *  }
   *  </code></div>
   */


  p5.Envelope.prototype.ramp = function (unit, secondsFromNow, v1, v2) {
    var now = p5sound.audiocontext.currentTime;
    var tFromNow = secondsFromNow || 0;
    var t = now + tFromNow;
    var destination1 = this.checkExpInput(v1);
    var destination2 = typeof v2 !== 'undefined' ? this.checkExpInput(v2) : undefined; 

    if (unit) {
      if (this.connection !== unit) {
        this.connect(unit);
      }
    } 


    var currentVal = this.checkExpInput(this.control.getValueAtTime(t)); 

    if (destination1 > currentVal) {
      this.control.setTargetAtTime(destination1, t, this._rampAttackTC);
      t += this._rampAttackTime;
    } 
    else if (destination1 < currentVal) {
        this.control.setTargetAtTime(destination1, t, this._rampDecayTC);
        t += this._rampDecayTime;
      } 


    if (destination2 === undefined) return; 

    if (destination2 > destination1) {
      this.control.setTargetAtTime(destination2, t, this._rampAttackTC);
    } 
    else if (destination2 < destination1) {
        this.control.setTargetAtTime(destination2, t, this._rampDecayTC);
      }
  };

  p5.Envelope.prototype.connect = function (unit) {
    this.connection = unit; 

    if (unit instanceof p5.Oscillator || unit instanceof p5.SoundFile || unit instanceof p5.AudioIn || unit instanceof p5.Reverb || unit instanceof p5.Noise || unit instanceof p5.Filter || unit instanceof p5.Delay) {
      unit = unit.output.gain;
    }

    if (unit instanceof AudioParam) {
      unit.setValueAtTime(0, p5sound.audiocontext.currentTime);
    }

    if (unit instanceof p5.Signal) {
      unit.setValue(0);
    }

    this.output.connect(unit);
  };

  p5.Envelope.prototype.disconnect = function () {
    if (this.output) {
      this.output.disconnect();
    }
  }; 

  /**
   *  Add a value to the p5.Oscillator's output amplitude,
   *  and return the oscillator. Calling this method
   *  again will override the initial add() with new values.
   *
   *  @method  add
   *  @for p5.Envelope
   *  @param {Number} number Constant number to add
   *  @return {p5.Envelope} Envelope Returns this envelope
   *                                     with scaled output
   */


  p5.Envelope.prototype.add = function (num) {
    var add = new Add(num);
    var thisChain = this.mathOps.length;
    var nextChain = this.output;
    return p5.prototype._mathChain(this, add, thisChain, nextChain, Add);
  };
  /**
   *  Multiply the p5.Envelope's output amplitude
   *  by a fixed value. Calling this method
   *  again will override the initial mult() with new values.
   *
   *  @method  mult
   *  @for p5.Envelope
   *  @param {Number} number Constant number to multiply
   *  @return {p5.Envelope} Envelope Returns this envelope
   *                                     with scaled output
   */


  p5.Envelope.prototype.mult = function (num) {
    var mult = new Mult(num);
    var thisChain = this.mathOps.length;
    var nextChain = this.output;
    return p5.prototype._mathChain(this, mult, thisChain, nextChain, Mult);
  };
  /**
   *  Scale this envelope's amplitude values to a given
   *  range, and return the envelope. Calling this method
   *  again will override the initial scale() with new values.
   *
   *  @method  scale
   *  @for p5.Envelope
   *  @param  {Number} inMin  input range minumum
   *  @param  {Number} inMax  input range maximum
   *  @param  {Number} outMin input range minumum
   *  @param  {Number} outMax input range maximum
   *  @return {p5.Envelope} Envelope Returns this envelope
   *                                     with scaled output
   */


  p5.Envelope.prototype.scale = function (inMin, inMax, outMin, outMax) {
    var scale = new Scale(inMin, inMax, outMin, outMax);
    var thisChain = this.mathOps.length;
    var nextChain = this.output;
    return p5.prototype._mathChain(this, scale, thisChain, nextChain, Scale);
  }; 


  p5.Envelope.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);
    this.disconnect();

    if (this.control) {
      this.control.dispose();
      this.control = null;
    }

    for (var i = 1; i < this.mathOps.length; i++) {
      this.mathOps[i].dispose();
    }
  }; 


  p5.Env = function (t1, l1, t2, l2, t3, l3) {
    console.warn('WARNING: p5.Env is now deprecated and may be removed in future versions. ' + 'Please use the new p5.Envelope instead.');
    p5.Envelope.call(this, t1, l1, t2, l2, t3, l3);
  };

  p5.Env.prototype = Object.create(p5.Envelope.prototype);
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  __webpack_require__(23);
  /**
   *  Creates a Pulse object, an oscillator that implements
   *  Pulse Width Modulation.
   *  The pulse is created with two oscillators.
   *  Accepts a parameter for frequency, and to set the
   *  width between the pulses. See <a href="
   *  http://p5js.org/reference/#/p5.Oscillator">
   *  <code>p5.Oscillator</code> for a full list of methods.
   *
   *  @class p5.Pulse
   *  @extends p5.Oscillator
   *  @constructor
   *  @param {Number} [freq] Frequency in oscillations per second (Hz)
   *  @param {Number} [w]    Width between the pulses (0 to 1.0,
   *                         defaults to 0)
   *  @example
   *  <div><code>
   *  let pulse;
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(startPulse);
   *    background(220);
   *
   *    pulse = new p5.Pulse();
   *    pulse.amp(0.5);
   *    pulse.freq(220);
   *  }
   *  function startPulse() {
   *    pulse.start();
   *    pulse.amp(0.5, 0.02);
   *  }
   *  function mouseReleased() {
   *    pulse.amp(0, 0.2);
   *  }
   *  function draw() {
   *    background(220);
   *    text('tap to play', 5, 20, width - 20);
   *    let w = map(mouseX, 0, width, 0, 1);
   *    w = constrain(w, 0, 1);
   *    pulse.width(w);
   *    text('pulse width: ' + w, 5, height - 20);
   *  }
   *  </code></div>
   */


  p5.Pulse = function (freq, w) {
    p5.Oscillator.call(this, freq, 'sawtooth'); 

    this.w = w || 0; 

    this.osc2 = new p5.SawOsc(freq); 

    this.dNode = p5sound.audiocontext.createDelay(); 

    this.dcOffset = createDCOffset();
    this.dcGain = p5sound.audiocontext.createGain();
    this.dcOffset.connect(this.dcGain);
    this.dcGain.connect(this.output); 

    this.f = freq || 440;
    var mW = this.w / this.oscillator.frequency.value;
    this.dNode.delayTime.value = mW;
    this.dcGain.gain.value = 1.7 * (0.5 - this.w); 

    this.osc2.disconnect();
    this.osc2.panner.disconnect();
    this.osc2.amp(-1); 

    this.osc2.output.connect(this.dNode);
    this.dNode.connect(this.output);
    this.output.gain.value = 1;
    this.output.connect(this.panner);
  };

  p5.Pulse.prototype = Object.create(p5.Oscillator.prototype);
  /**
   *  Set the width of a Pulse object (an oscillator that implements
   *  Pulse Width Modulation).
   *
   *  @method  width
   *  @param {Number} [width]    Width between the pulses (0 to 1.0,
   *                         defaults to 0)
   */

  p5.Pulse.prototype.width = function (w) {
    if (typeof w === 'number') {
      if (w <= 1.0 && w >= 0.0) {
        this.w = w; 

        var mW = this.w / this.oscillator.frequency.value;
        this.dNode.delayTime.value = mW;
      }

      this.dcGain.gain.value = 1.7 * (0.5 - this.w);
    } else {
      w.connect(this.dNode.delayTime);
      var sig = new p5.SignalAdd(-0.5);
      sig.setInput(w);
      sig = sig.mult(-1);
      sig = sig.mult(1.7);
      sig.connect(this.dcGain.gain);
    }
  };

  p5.Pulse.prototype.start = function (f, time) {
    var now = p5sound.audiocontext.currentTime;
    var t = time || 0;

    if (!this.started) {
      var freq = f || this.f;
      var type = this.oscillator.type;
      this.oscillator = p5sound.audiocontext.createOscillator();
      this.oscillator.frequency.setValueAtTime(freq, now);
      this.oscillator.type = type;
      this.oscillator.connect(this.output);
      this.oscillator.start(t + now); 

      this.osc2.oscillator = p5sound.audiocontext.createOscillator();
      this.osc2.oscillator.frequency.setValueAtTime(freq, t + now);
      this.osc2.oscillator.type = type;
      this.osc2.oscillator.connect(this.osc2.output);
      this.osc2.start(t + now);
      this.freqNode = [this.oscillator.frequency, this.osc2.oscillator.frequency]; 

      this.dcOffset = createDCOffset();
      this.dcOffset.connect(this.dcGain);
      this.dcOffset.start(t + now); 

      if (this.mods !== undefined && this.mods.frequency !== undefined) {
        this.mods.frequency.connect(this.freqNode[0]);
        this.mods.frequency.connect(this.freqNode[1]);
      }

      this.started = true;
      this.osc2.started = true;
    }
  };

  p5.Pulse.prototype.stop = function (time) {
    if (this.started) {
      var t = time || 0;
      var now = p5sound.audiocontext.currentTime;
      this.oscillator.stop(t + now);

      if (this.osc2.oscillator) {
        this.osc2.oscillator.stop(t + now);
      }

      this.dcOffset.stop(t + now);
      this.started = false;
      this.osc2.started = false;
    }
  };

  p5.Pulse.prototype.freq = function (val, rampTime, tFromNow) {
    if (typeof val === 'number') {
      this.f = val;
      var now = p5sound.audiocontext.currentTime;
      var rampTime = rampTime || 0;
      var tFromNow = tFromNow || 0;
      var currentFreq = this.oscillator.frequency.value;
      this.oscillator.frequency.cancelScheduledValues(now);
      this.oscillator.frequency.setValueAtTime(currentFreq, now + tFromNow);
      this.oscillator.frequency.exponentialRampToValueAtTime(val, tFromNow + rampTime + now);
      this.osc2.oscillator.frequency.cancelScheduledValues(now);
      this.osc2.oscillator.frequency.setValueAtTime(currentFreq, now + tFromNow);
      this.osc2.oscillator.frequency.exponentialRampToValueAtTime(val, tFromNow + rampTime + now);

      if (this.freqMod) {
        this.freqMod.output.disconnect();
        this.freqMod = null;
      }
    } else if (val.output) {
      val.output.disconnect();
      val.output.connect(this.oscillator.frequency);
      val.output.connect(this.osc2.oscillator.frequency);
      this.freqMod = val;
    }
  }; 


  function createDCOffset() {
    var ac = p5sound.audiocontext;
    var buffer = ac.createBuffer(1, 2048, ac.sampleRate);
    var data = buffer.getChannelData(0);

    for (var i = 0; i < 2048; i++) {
      data[i] = 1.0;
    }

    var bufferSource = ac.createBufferSource();
    bufferSource.buffer = buffer;
    bufferSource.loop = true;
    return bufferSource;
  }
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);
  /**
   *  Noise is a type of oscillator that generates a buffer with random values.
   *
   *  @class p5.Noise
   *  @extends p5.Oscillator
   *  @constructor
   *  @param {String} type Type of noise can be 'white' (default),
   *                       'brown' or 'pink'.
   */


  p5.Noise = function (type) {
    var assignType;
    p5.Oscillator.call(this);
    delete this.f;
    delete this.freq;
    delete this.oscillator;

    if (type === 'brown') {
      assignType = _brownNoise;
    } else if (type === 'pink') {
      assignType = _pinkNoise;
    } else {
      assignType = _whiteNoise;
    }

    this.buffer = assignType;
  };

  p5.Noise.prototype = Object.create(p5.Oscillator.prototype); 

  var _whiteNoise = function () {
    var bufferSize = 2 * p5sound.audiocontext.sampleRate;
    var whiteBuffer = p5sound.audiocontext.createBuffer(1, bufferSize, p5sound.audiocontext.sampleRate);
    var noiseData = whiteBuffer.getChannelData(0);

    for (var i = 0; i < bufferSize; i++) {
      noiseData[i] = Math.random() * 2 - 1;
    }

    whiteBuffer.type = 'white';
    return whiteBuffer;
  }();

  var _pinkNoise = function () {
    var bufferSize = 2 * p5sound.audiocontext.sampleRate;
    var pinkBuffer = p5sound.audiocontext.createBuffer(1, bufferSize, p5sound.audiocontext.sampleRate);
    var noiseData = pinkBuffer.getChannelData(0);
    var b0, b1, b2, b3, b4, b5, b6;
    b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;

    for (var i = 0; i < bufferSize; i++) {
      var white = Math.random() * 2 - 1;
      b0 = 0.99886 * b0 + white * 0.0555179;
      b1 = 0.99332 * b1 + white * 0.0750759;
      b2 = 0.96900 * b2 + white * 0.1538520;
      b3 = 0.86650 * b3 + white * 0.3104856;
      b4 = 0.55000 * b4 + white * 0.5329522;
      b5 = -0.7616 * b5 - white * 0.0168980;
      noiseData[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
      noiseData[i] *= 0.11; 

      b6 = white * 0.115926;
    }

    pinkBuffer.type = 'pink';
    return pinkBuffer;
  }();

  var _brownNoise = function () {
    var bufferSize = 2 * p5sound.audiocontext.sampleRate;
    var brownBuffer = p5sound.audiocontext.createBuffer(1, bufferSize, p5sound.audiocontext.sampleRate);
    var noiseData = brownBuffer.getChannelData(0);
    var lastOut = 0.0;

    for (var i = 0; i < bufferSize; i++) {
      var white = Math.random() * 2 - 1;
      noiseData[i] = (lastOut + 0.02 * white) / 1.02;
      lastOut = noiseData[i];
      noiseData[i] *= 3.5;
    }

    brownBuffer.type = 'brown';
    return brownBuffer;
  }();
  /**
   *  Set type of noise to 'white', 'pink' or 'brown'.
   *  White is the default.
   *
   *  @method setType
   *  @param {String} [type] 'white', 'pink' or 'brown'
   */


  p5.Noise.prototype.setType = function (type) {
    switch (type) {
      case 'white':
        this.buffer = _whiteNoise;
        break;

      case 'pink':
        this.buffer = _pinkNoise;
        break;

      case 'brown':
        this.buffer = _brownNoise;
        break;

      default:
        this.buffer = _whiteNoise;
    }

    if (this.started) {
      var now = p5sound.audiocontext.currentTime;
      this.stop(now);
      this.start(now + .01);
    }
  };

  p5.Noise.prototype.getType = function () {
    return this.buffer.type;
  };

  p5.Noise.prototype.start = function () {
    if (this.started) {
      this.stop();
    }

    this.noise = p5sound.audiocontext.createBufferSource();
    this.noise.buffer = this.buffer;
    this.noise.loop = true;
    this.noise.connect(this.output);
    var now = p5sound.audiocontext.currentTime;
    this.noise.start(now);
    this.started = true;
  };

  p5.Noise.prototype.stop = function () {
    var now = p5sound.audiocontext.currentTime;

    if (this.noise) {
      this.noise.stop(now);
      this.started = false;
    }
  };

  p5.Noise.prototype.dispose = function () {
    var now = p5sound.audiocontext.currentTime; 

    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);

    if (this.noise) {
      this.noise.disconnect();
      this.stop(now);
    }

    if (this.output) {
      this.output.disconnect();
    }

    if (this.panner) {
      this.panner.disconnect();
    }

    this.output = null;
    this.panner = null;
    this.buffer = null;
    this.noise = null;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1); 


  p5sound.inputSources = [];
  /**
   *  <p>Get audio from an input, i.e. your computer's microphone.</p>
   *
   *  <p>Turn the mic on/off with the start() and stop() methods. When the mic
   *  is on, its volume can be measured with getLevel or by connecting an
   *  FFT object.</p>
   *
   *  <p>If you want to hear the AudioIn, use the .connect() method.
   *  AudioIn does not connect to p5.sound output by default to prevent
   *  feedback.</p>
   *
   *  <p><em>Note: This uses the <a href="http://caniuse.com/stream">getUserMedia/
   *  Stream</a> API, which is not supported by certain browsers. Access in Chrome browser
   *  is limited to localhost and https, but access over http may be limited.</em></p>
   *
   *  @class p5.AudioIn
   *  @constructor
   *  @param {Function} [errorCallback] A function to call if there is an error
   *                                    accessing the AudioIn. For example,
   *                                    Safari and iOS devices do not
   *                                    currently allow microphone access.
   *  @example
   *  <div><code>
   *  let mic;
   *
   *   function setup(){
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(userStartAudio);
   *    textAlign(CENTER);
   *    mic = new p5.AudioIn();
   *    mic.start();
   *  }
   *
   *  function draw(){
   *    background(0);
   *    fill(255);
   *    text('tap to start', width/2, 20);
   *
   *    micLevel = mic.getLevel();
   *    let y = height - micLevel * height;
   *    ellipse(width/2, y, 10, 10);
   *  }
   *  </code></div>
   */

  p5.AudioIn = function (errorCallback) {

    /**
     * @property {GainNode} input
     */
    this.input = p5sound.audiocontext.createGain();
    /**
     * @property {GainNode} output
     */

    this.output = p5sound.audiocontext.createGain();
    /**
     * @property {MediaStream|null} stream
     */

    this.stream = null;
    /**
     * @property {MediaStreamAudioSourceNode|null} mediaStream
     */

    this.mediaStream = null;
    /**
     * @property {Number|null} currentSource
     */

    this.currentSource = null;
    /**
     *  Client must allow browser to access their microphone / audioin source.
     *  Default: false. Will become true when the client enables access.
     *
     *  @property {Boolean} enabled
     */

    this.enabled = false;
    /**
     * Input amplitude, connect to it by default but not to master out
     *
     *  @property {p5.Amplitude} amplitude
     */

    this.amplitude = new p5.Amplitude();
    this.output.connect(this.amplitude.input);

    if (!window.MediaStreamTrack || !window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia) {
      errorCallback ? errorCallback() : window.alert('This browser does not support MediaStreamTrack and mediaDevices');
    } 


    p5sound.soundArray.push(this);
  };
  /**
   *  Start processing audio input. This enables the use of other
   *  AudioIn methods like getLevel(). Note that by default, AudioIn
   *  is not connected to p5.sound's output. So you won't hear
   *  anything unless you use the connect() method.<br/>
   *
   *  Certain browsers limit access to the user's microphone. For example,
   *  Chrome only allows access from localhost and over https. For this reason,
   *  you may want to include an errorCallbacka function that is called in case
   *  the browser won't provide mic access.
   *
   *  @method start
   *  @for p5.AudioIn
   *  @param {Function} [successCallback] Name of a function to call on
   *                                    success.
   *  @param {Function} [errorCallback] Name of a function to call if
   *                                    there was an error. For example,
   *                                    some browsers do not support
   *                                    getUserMedia.
   */


  p5.AudioIn.prototype.start = function (successCallback, errorCallback) {
    var self = this;

    if (this.stream) {
      this.stop();
    } 


    var audioSource = p5sound.inputSources[self.currentSource];
    var constraints = {
      audio: {
        sampleRate: p5sound.audiocontext.sampleRate,
        echoCancellation: false
      }
    }; 

    if (p5sound.inputSources[this.currentSource]) {
      constraints.audio.deviceId = audioSource.deviceId;
    }

    window.navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
      self.stream = stream;
      self.enabled = true; 

      self.mediaStream = p5sound.audiocontext.createMediaStreamSource(stream);
      self.mediaStream.connect(self.output); 

      self.amplitude.setInput(self.output);
      if (successCallback) successCallback();
    })["catch"](function (err) {
      if (errorCallback) errorCallback(err);else console.error(err);
    });
  };
  /**
   *  Turn the AudioIn off. If the AudioIn is stopped, it cannot getLevel().
   *  If re-starting, the user may be prompted for permission access.
   *
   *  @method stop
   *  @for p5.AudioIn
   */


  p5.AudioIn.prototype.stop = function () {
    if (this.stream) {
      this.stream.getTracks().forEach(function (track) {
        track.stop();
      });
      this.mediaStream.disconnect();
      delete this.mediaStream;
      delete this.stream;
    }
  };
  /**
   *  Connect to an audio unit. If no parameter is provided, will
   *  connect to the master output (i.e. your speakers).<br/>
   *
   *  @method  connect
   *  @for p5.AudioIn
   *  @param  {Object} [unit] An object that accepts audio input,
   *                          such as an FFT
   */


  p5.AudioIn.prototype.connect = function (unit) {
    if (unit) {
      if (unit.hasOwnProperty('input')) {
        this.output.connect(unit.input);
      } else if (unit.hasOwnProperty('analyser')) {
        this.output.connect(unit.analyser);
      } else {
        this.output.connect(unit);
      }
    } else {
      this.output.connect(p5sound.input);
    }
  };
  /**
   *  Disconnect the AudioIn from all audio units. For example, if
   *  connect() had been called, disconnect() will stop sending
   *  signal to your speakers.<br/>
   *
   *  @method  disconnect
   *  @for p5.AudioIn
   */


  p5.AudioIn.prototype.disconnect = function () {
    if (this.output) {
      this.output.disconnect(); 

      this.output.connect(this.amplitude.input);
    }
  };
  /**
   *  Read the Amplitude (volume level) of an AudioIn. The AudioIn
   *  class contains its own instance of the Amplitude class to help
   *  make it easy to get a microphone's volume level. Accepts an
   *  optional smoothing value (0.0 < 1.0). <em>NOTE: AudioIn must
   *  .start() before using .getLevel().</em><br/>
   *
   *  @method  getLevel
   *  @for p5.AudioIn
   *  @param  {Number} [smoothing] Smoothing is 0.0 by default.
   *                               Smooths values based on previous values.
   *  @return {Number}           Volume level (between 0.0 and 1.0)
   */


  p5.AudioIn.prototype.getLevel = function (smoothing) {
    if (smoothing) {
      this.amplitude.smoothing = smoothing;
    }

    return this.amplitude.getLevel();
  };
  /**
   *  Set amplitude (volume) of a mic input between 0 and 1.0. <br/>
   *
   *  @method  amp
   *  @for p5.AudioIn
   *  @param  {Number} vol between 0 and 1.0
   *  @param {Number} [time] ramp time (optional)
   */


  p5.AudioIn.prototype.amp = function (vol, t) {
    if (t) {
      var rampTime = t || 0;
      var currentVol = this.output.gain.value;
      this.output.gain.cancelScheduledValues(p5sound.audiocontext.currentTime);
      this.output.gain.setValueAtTime(currentVol, p5sound.audiocontext.currentTime);
      this.output.gain.linearRampToValueAtTime(vol, rampTime + p5sound.audiocontext.currentTime);
    } else {
      this.output.gain.cancelScheduledValues(p5sound.audiocontext.currentTime);
      this.output.gain.setValueAtTime(vol, p5sound.audiocontext.currentTime);
    }
  };
  /**
   * Returns a list of available input sources. This is a wrapper
   * for <a title="MediaDevices.enumerateDevices() - Web APIs | MDN" target="_blank" href=
   *  "https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices"
   *  > and it returns a Promise.
   *
   * @method  getSources
   * @for p5.AudioIn
   * @param  {Function} [successCallback] This callback function handles the sources when they
   *                                      have been enumerated. The callback function
   *                                      receives the deviceList array as its only argument
   * @param  {Function} [errorCallback] This optional callback receives the error
   *                                    message as its argument.
   * @returns {Promise} Returns a Promise that can be used in place of the callbacks, similar
   *                            to the enumerateDevices() method
   * @example
   *  <div><code>
   *  let audioIn;
   *
   *  function setup(){
   *    text('getting sources...', 0, 20);
   *    audioIn = new p5.AudioIn();
   *    audioIn.getSources(gotSources);
   *  }
   *
   *  function gotSources(deviceList) {
   *    if (deviceList.length > 0) {
   *      //set the source to the first item in the deviceList array
   *      audioIn.setSource(0);
   *      let currentSource = deviceList[audioIn.currentSource];
   *      text('set source to: ' + currentSource.deviceId, 5, 20, width);
   *    }
   *  }
   *  </code></div>
   */


  p5.AudioIn.prototype.getSources = function (onSuccess, onError) {
    return new Promise(function (resolve, reject) {
      window.navigator.mediaDevices.enumerateDevices().then(function (devices) {
        p5sound.inputSources = devices.filter(function (device) {
          return device.kind === 'audioinput';
        });
        resolve(p5sound.inputSources);

        if (onSuccess) {
          onSuccess(p5sound.inputSources);
        }
      })["catch"](function (error) {
        reject(error);

        if (onError) {
          onError(error);
        } else {
          console.error('This browser does not support MediaStreamTrack.getSources()');
        }
      });
    });
  };
  /**
   *  Set the input source. Accepts a number representing a
   *  position in the array returned by getSources().
   *  This is only available in browsers that support
   *  <a title="MediaDevices.enumerateDevices() - Web APIs | MDN" target="_blank" href=
   *  "https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices"
   *  >navigator.mediaDevices.enumerateDevices()</a>.<br/>
   *
   *  @method setSource
   *  @for p5.AudioIn
   *  @param {number} num position of input source in the array
   *  @example
   *  <div><code>
   *  let audioIn;
   *
   *  function setup(){
   *    text('getting sources...', 0, 20);
   *    audioIn = new p5.AudioIn();
   *    audioIn.getSources(gotSources);
   *  }
   *
   *  function gotSources(deviceList) {
   *    if (deviceList.length > 0) {
   *      //set the source to the first item in the deviceList array
   *      audioIn.setSource(0);
   *      let currentSource = deviceList[audioIn.currentSource];
   *      text('set source to: ' + currentSource.deviceId, 5, 20, width);
   *    }
   *  }
   *  </code></div>
   */


  p5.AudioIn.prototype.setSource = function (num) {
    if (p5sound.inputSources.length > 0 && num < p5sound.inputSources.length) {
      this.currentSource = num;
      console.log('set source to ', p5sound.inputSources[this.currentSource]);
    } else {
      console.log('unable to set input source');
    } 


    if (this.stream && this.stream.active) {
      this.start();
    }
  }; 


  p5.AudioIn.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);
    this.stop();

    if (this.output) {
      this.output.disconnect();
    }

    if (this.amplitude) {
      this.amplitude.disconnect();
    }

    delete this.amplitude;
    delete this.output;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(2),__webpack_require__(52),__webpack_require__(58),__webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){"use strict";return i.CrossFade=function(e){this.createInsOuts(2,1),this.a=this.input[0]=new i.Gain,this.b=this.input[1]=new i.Gain,this.fade=new i.Signal(this.defaultArg(e,.5),i.Type.NormalRange),this._equalPowerA=new i.EqualPowerGain,this._equalPowerB=new i.EqualPowerGain,this._invert=new i.Expr("1 - $0"),this.a.connect(this.output),this.b.connect(this.output),this.fade.chain(this._equalPowerB,this.b.gain),this.fade.chain(this._invert,this._equalPowerA,this.a.gain),this._readOnly("fade")},i.extend(i.CrossFade),i.CrossFade.prototype.dispose=function(){return i.prototype.dispose.call(this),this._writable("fade"),this._equalPowerA.dispose(),this._equalPowerA=null,this._equalPowerB.dispose(),this._equalPowerB=null,this.fade.dispose(),this.fade=null,this._invert.dispose(),this._invert=null,this.a.dispose(),this.a=null,this.b.dispose(),this.b=null,this},i.CrossFade}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(7),__webpack_require__(16),__webpack_require__(3),__webpack_require__(53),__webpack_require__(26),__webpack_require__(54),__webpack_require__(25),__webpack_require__(55),__webpack_require__(56),__webpack_require__(57)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(p){"use strict";function r(e,n,r){var t=new e;return r._eval(n[0]).connect(t,0,0),r._eval(n[1]).connect(t,0,1),t}function t(e,n,r){var t=new e;return r._eval(n[0]).connect(t,0,0),t}function o(e){return e?parseFloat(e):void 0}function i(e){return e&&e.args?parseFloat(e.args):void 0}return p.Expr=function(){var n=this._replacements(Array.prototype.slice.call(arguments)),e=this._parseInputs(n);this._nodes=[],this.input=new Array(e);for(var r=0;r<e;r++)this.input[r]=this.context.createGain();var t,o=this._parseTree(n);try{t=this._eval(o)}catch(e){throw this._disposeNodes(),new Error("Tone.Expr: Could evaluate expression: "+n)}this.output=t},p.extend(p.Expr,p.SignalBase),p.Expr._Expressions={value:{signal:{regexp:/^\d+\.\d+|^\d+/,method:function(e){return new p.Signal(o(e))}},input:{regexp:/^\$\d/,method:function(e,n){return n.input[o(e.substr(1))]}}},glue:{"(":{regexp:/^\(/},")":{regexp:/^\)/},",":{regexp:/^,/}},func:{abs:{regexp:/^abs/,method:t.bind(this,p.Abs)},mod:{regexp:/^mod/,method:function(e,n){var r=i(e[1]),t=new p.Modulo(r);return n._eval(e[0]).connect(t),t}},pow:{regexp:/^pow/,method:function(e,n){var r=i(e[1]),t=new p.Pow(r);return n._eval(e[0]).connect(t),t}},a2g:{regexp:/^a2g/,method:function(e,n){var r=new p.AudioToGain;return n._eval(e[0]).connect(r),r}}},binary:{"+":{regexp:/^\+/,precedence:1,method:r.bind(this,p.Add)},"-":{regexp:/^\-/,precedence:1,method:function(e,n){return 1===e.length?t(p.Negate,e,n):r(p.Subtract,e,n)}},"*":{regexp:/^\*/,precedence:0,method:r.bind(this,p.Multiply)}},unary:{"-":{regexp:/^\-/,method:t.bind(this,p.Negate)},"!":{regexp:/^\!/,method:t.bind(this,p.NOT)}}},p.Expr.prototype._parseInputs=function(e){var n=e.match(/\$\d/g),r=0;if(null!==n)for(var t=0;t<n.length;t++){var o=parseInt(n[t].substr(1))+1;r=Math.max(r,o)}return r},p.Expr.prototype._replacements=function(e){for(var n=e.shift(),r=0;r<e.length;r++)n=n.replace(/\%/i,e[r]);return n},p.Expr.prototype._tokenize=function(e){for(var n=-1,r=[];0<e.length;){var t=o(e=e.trim());r.push(t),e=e.substr(t.value.length)}function o(e){for(var n in p.Expr._Expressions){var r=p.Expr._Expressions[n];for(var t in r){var o=r[t],i=o.regexp,a=e.match(i);if(null!==a)return{type:n,value:a[0],method:o.method}}}throw new SyntaxError("Tone.Expr: Unexpected token "+e)}return{next:function(){return r[++n]},peek:function(){return r[n+1]}}},p.Expr.prototype._parseTree=function(e){var t=this._tokenize(e),a=this.isUndef.bind(this);function r(e,n){return!a(e)&&"glue"===e.type&&e.value===n}function o(e,n,r){var t=p.Expr._Expressions[n];if(!a(e))for(var o in t){var i=t[o];if(i.regexp.test(e.value)){if(a(r))return!0;if(i.precedence===r)return!0}}return!1}function i(e){var n;a(e)&&(e=5),n=e<0?function e(){var n,r;n=t.peek();if(o(n,"unary"))return n=t.next(),r=e(),{operator:n.value,method:n.method,args:[r]};return s()}():i(e-1);for(var r=t.peek();o(r,"binary",e);)n={operator:(r=t.next()).value,method:r.method,args:[n,i(e-1)]},r=t.peek();return n}function s(){var e,n;if(e=t.peek(),a(e))throw new SyntaxError("Tone.Expr: Unexpected termination of expression");if("func"===e.type)return function(e){var n=[];if(!r(t.next(),"("))throw new SyntaxError('Tone.Expr: Expected ( in a function call "'+e.value+'"');r(t.peek(),")")||(n=function(){var e,n=[];for(;e=i(),!a(e)&&(n.push(e),r(t.peek(),","));)t.next();return n}());if(r(t.next(),")"))return{method:e.method,args:n,name:name};throw new SyntaxError('Tone.Expr: Expected ) in a function call "'+e.value+'"')}(e=t.next());if("value"===e.type)return{method:(e=t.next()).method,args:e.value};if(r(e,"(")){if(t.next(),n=i(),!r(e=t.next(),")"))throw new SyntaxError("Expected )");return n}throw new SyntaxError("Tone.Expr: Parse error, cannot process token "+e.value)}return i()},p.Expr.prototype._eval=function(e){if(!this.isUndef(e)){var n=e.method(e.args,this);return this._nodes.push(n),n}},p.Expr.prototype._disposeNodes=function(){for(var e=0;e<this._nodes.length;e++){var n=this._nodes[e];this.isFunction(n.dispose)?n.dispose():this.isFunction(n.disconnect)&&n.disconnect(),n=null,this._nodes[e]=null}this._nodes=null},p.Expr.prototype.dispose=function(){p.prototype.dispose.call(this),this._disposeNodes()},p.Expr}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(26),__webpack_require__(16),__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(e){"use strict";return e.GreaterThan=function(t){this.createInsOuts(2,0),this._param=this.input[0]=new e.Subtract(t),this.input[1]=this._param.input[1],this._gtz=this.output=new e.GreaterThanZero,this._param.connect(this._gtz)},e.extend(e.GreaterThan,e.Signal),e.GreaterThan.prototype.dispose=function(){return e.prototype.dispose.call(this),this._param.dispose(),this._param=null,this._gtz.dispose(),this._gtz=null,this},e.GreaterThan}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(5),__webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(s){"use strict";return s.Abs=function(){this._abs=this.input=this.output=new s.WaveShaper(function(s){return 0===s?0:Math.abs(s)},127)},s.extend(s.Abs,s.SignalBase),s.Abs.prototype.dispose=function(){return s.prototype.dispose.call(this),this._abs.dispose(),this._abs=null,this},s.Abs}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(5),__webpack_require__(3),__webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){"use strict";return i.Modulo=function(t){this.createInsOuts(1,0),this._shaper=new i.WaveShaper(Math.pow(2,16)),this._multiply=new i.Multiply,this._subtract=this.output=new i.Subtract,this._modSignal=new i.Signal(t),this.input.fan(this._shaper,this._subtract),this._modSignal.connect(this._multiply,0,0),this._shaper.connect(this._multiply,0,1),this._multiply.connect(this._subtract,0,1),this._setWaveShaper(t)},i.extend(i.Modulo,i.SignalBase),i.Modulo.prototype._setWaveShaper=function(i){this._shaper.setMap(function(t){return Math.floor((t+1e-4)/i)})},Object.defineProperty(i.Modulo.prototype,"value",{get:function(){return this._modSignal.value},set:function(t){this._modSignal.value=t,this._setWaveShaper(t)}}),i.Modulo.prototype.dispose=function(){return i.prototype.dispose.call(this),this._shaper.dispose(),this._shaper=null,this._multiply.dispose(),this._multiply=null,this._subtract.dispose(),this._subtract=null,this._modSignal.dispose(),this._modSignal=null,this},i.Modulo}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(t){"use strict";return t.Pow=function(e){this._exp=this.defaultArg(e,1),this._expScaler=this.input=this.output=new t.WaveShaper(this._expFunc(this._exp),8192)},t.extend(t.Pow,t.SignalBase),Object.defineProperty(t.Pow.prototype,"value",{get:function(){return this._exp},set:function(e){this._exp=e,this._expScaler.setMap(this._expFunc(this._exp))}}),t.Pow.prototype._expFunc=function(t){return function(e){return Math.pow(Math.abs(e),t)}},t.Pow.prototype.dispose=function(){return t.prototype.dispose.call(this),this._expScaler.dispose(),this._expScaler=null,this},t.Pow}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(5),__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(n){"use strict";return n.AudioToGain=function(){this._norm=this.input=this.output=new n.WaveShaper(function(n){return(n+1)/2})},n.extend(n.AudioToGain,n.SignalBase),n.AudioToGain.prototype.dispose=function(){return n.prototype.dispose.call(this),this._norm.dispose(),this._norm=null,this},n.AudioToGain}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(e){"use strict";return e.EqualPowerGain=function(){this._eqPower=this.input=this.output=new e.WaveShaper(function(e){return Math.abs(e)<.001?0:this.equalPowerScale(e)}.bind(this),4096)},e.extend(e.EqualPowerGain,e.SignalBase),e.EqualPowerGain.prototype.dispose=function(){return e.prototype.dispose.call(this),this._eqPower.dispose(),this._eqPower=null,this},e.EqualPowerGain}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var Effect = __webpack_require__(4);

  var EQFilter = __webpack_require__(60);
  /**
   * p5.EQ is an audio effect that performs the function of a multiband
   * audio equalizer. Equalization is used to adjust the balance of
   * frequency compoenents of an audio signal. This process is commonly used
   * in sound production and recording to change the waveform before it reaches
   * a sound output device. EQ can also be used as an audio effect to create
   * interesting distortions by filtering out parts of the spectrum. p5.EQ is
   * built using a chain of Web Audio Biquad Filter Nodes and can be
   * instantiated with 3 or 8 bands. Bands can be added or removed from
   * the EQ by directly modifying p5.EQ.bands (the array that stores filters).
   *
   * This class extends <a href = "/reference/#/p5.Effect">p5.Effect</a>.
   * Methods <a href = "/reference/#/p5.Effect/amp">amp()</a>, <a href = "/reference/#/p5.Effect/chain">chain()</a>,
   * <a href = "/reference/#/p5.Effect/drywet">drywet()</a>, <a href = "/reference/#/p5.Effect/connect">connect()</a>, and
   * <a href = "/reference/#/p5.Effect/disconnect">disconnect()</a> are available.
   *
   * @class p5.EQ
   * @constructor
   * @extends p5.Effect
   * @param {Number} [_eqsize] Constructor will accept 3 or 8, defaults to 3
   * @return {Object} p5.EQ object
   *
   * @example
   * <div><code>
   * let eq, soundFile
   * let eqBandIndex = 0;
   * let eqBandNames = ['lows', 'mids', 'highs'];
   *
   * function preload() {
   *   soundFormats('mp3', 'ogg');
   *   soundFile = loadSound('assets/beat');
   * }
   *
   * function setup() {
   *   let cnv = createCanvas(100, 100);
   *   cnv.mousePressed(toggleSound);
   *
   *   eq = new p5.EQ(eqBandNames.length);
   *   soundFile.disconnect();
   *   eq.process(soundFile);
   * }
   *
   * function draw() {
   *   background(30);
   *   noStroke();
   *   fill(255);
   *   textAlign(CENTER);
   *   text('filtering ', 50, 25);
   *
   *   fill(255, 40, 255);
   *   textSize(26);
   *   text(eqBandNames[eqBandIndex], 50, 55);
   *
   *   fill(255);
   *   textSize(9);
   *
   *   if (!soundFile.isPlaying()) {
   *     text('tap to play', 50, 80);
   *   } else {
   *     text('tap to filter next band', 50, 80)
   *   }
   * }
   *
   * function toggleSound() {
   *   if (!soundFile.isPlaying()) {
   *     soundFile.play();
   *   } else {
   *     eqBandIndex = (eqBandIndex + 1) % eq.bands.length;
   *   }
   *
   *   for (let i = 0; i < eq.bands.length; i++) {
   *     eq.bands[i].gain(0);
   *   }
   *   // filter the band we want to filter
   *   eq.bands[eqBandIndex].gain(-40);
   * }
   * </code></div>
   */


  p5.EQ = function (_eqsize) {
    Effect.call(this); 

    _eqsize = _eqsize === 3 || _eqsize === 8 ? _eqsize : 3;
    var factor;
    _eqsize === 3 ? factor = Math.pow(2, 3) : factor = 2;
    /**
      *  The p5.EQ is built with abstracted p5.Filter objects.
      *  To modify any bands, use methods of the <a
      *  href="/reference/#/p5.Filter" title="p5.Filter reference">
      *  p5.Filter</a> API, especially `gain` and `freq`.
      *  Bands are stored in an array, with indices 0 - 3, or 0 - 7
      *  @property {Array}  bands
      *
    */

    this.bands = [];
    var freq, res;

    for (var i = 0; i < _eqsize; i++) {
      if (i === _eqsize - 1) {
        freq = 21000;
        res = .01;
      } else if (i === 0) {
        freq = 100;
        res = .1;
      } else if (i === 1) {
        freq = _eqsize === 3 ? 360 * factor : 360;
        res = 1;
      } else {
        freq = this.bands[i - 1].freq() * factor;
        res = 1;
      }

      this.bands[i] = this._newBand(freq, res);

      if (i > 0) {
        this.bands[i - 1].connect(this.bands[i].biquad);
      } else {
        this.input.connect(this.bands[i].biquad);
      }
    }

    this.bands[_eqsize - 1].connect(this.output);
  };

  p5.EQ.prototype = Object.create(Effect.prototype);
  /**
   * Process an input by connecting it to the EQ
   * @method  process
   * @param  {Object} src Audio source
   */

  p5.EQ.prototype.process = function (src) {
    src.connect(this.input);
  }; 
  //   * Set the frequency and gain of each band in the EQ. This method should be
  //   * called with 3 or 8 frequency and gain pairs, depending on the size of the EQ.
  //   * ex. eq.set(freq0, gain0, freq1, gain1, freq2, gain2);
  //   *
  //   * @method  set
  //   * @for p5.EQ
  //   * @param {Number} [freq0] Frequency value for band with index 0
  //   * @param {Number} [gain0] Gain value for band with index 0
  //   * @param {Number} [freq1] Frequency value for band with index 1
  //   * @param {Number} [gain1] Gain value for band with index 1
  //   * @param {Number} [freq2] Frequency value for band with index 2
  //   * @param {Number} [gain2] Gain value for band with index 2
  //   * @param {Number} [freq3] Frequency value for band with index 3
  //   * @param {Number} [gain3] Gain value for band with index 3
  //   * @param {Number} [freq4] Frequency value for band with index 4
  //   * @param {Number} [gain4] Gain value for band with index 4
  //   * @param {Number} [freq5] Frequency value for band with index 5
  //   * @param {Number} [gain5] Gain value for band with index 5
  //   * @param {Number} [freq6] Frequency value for band with index 6
  //   * @param {Number} [gain6] Gain value for band with index 6
  //   * @param {Number} [freq7] Frequency value for band with index 7
  //   * @param {Number} [gain7] Gain value for band with index 7
  //   */


  p5.EQ.prototype.set = function () {
    if (arguments.length === this.bands.length * 2) {
      for (var i = 0; i < arguments.length; i += 2) {
        this.bands[i / 2].freq(arguments[i]);
        this.bands[i / 2].gain(arguments[i + 1]);
      }
    } else {
      console.error('Argument mismatch. .set() should be called with ' + this.bands.length * 2 + ' arguments. (one frequency and gain value pair for each band of the eq)');
    }
  };
  /**
   * Add a new band. Creates a p5.Filter and strips away everything but
   * the raw biquad filter. This method returns an abstracted p5.Filter,
   * which can be added to p5.EQ.bands, in order to create new EQ bands.
   * @private
   * @for p5.EQ
   * @method  _newBand
   * @param  {Number} freq
   * @param  {Number} res
   * @return {Object}      Abstracted Filter
   */


  p5.EQ.prototype._newBand = function (freq, res) {
    return new EQFilter(freq, res);
  };

  p5.EQ.prototype.dispose = function () {
    Effect.prototype.dispose.apply(this);

    if (this.bands) {
      while (this.bands.length > 0) {
        delete this.bands.pop().dispose();
      }

      delete this.bands;
    }
  };

  return p5.EQ;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var Filter = __webpack_require__(15);

  var p5sound = __webpack_require__(1);
  /**
   *  EQFilter extends p5.Filter with constraints
   *  necessary for the p5.EQ
   *
   *  @private
   */


  var EQFilter = function EQFilter(freq, res) {
    Filter.call(this, 'peaking');
    this.disconnect();
    this.set(freq, res);
    this.biquad.gain.value = 0;
    delete this.input;
    delete this.output;
    delete this._drywet;
    delete this.wet;
  };

  EQFilter.prototype = Object.create(Filter.prototype);

  EQFilter.prototype.amp = function () {
    console.warn('`amp()` is not available for p5.EQ bands. Use `.gain()`');
  };

  EQFilter.prototype.drywet = function () {
    console.warn('`drywet()` is not available for p5.EQ bands.');
  };

  EQFilter.prototype.connect = function (unit) {
    var u = unit || p5.soundOut.input;

    if (this.biquad) {
      this.biquad.connect(u.input ? u.input : u);
    } else {
      this.output.connect(u.input ? u.input : u);
    }
  };

  EQFilter.prototype.disconnect = function () {
    if (this.biquad) {
      this.biquad.disconnect();
    }
  };

  EQFilter.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);
    this.disconnect();
    delete this.biquad;
  };

  return EQFilter;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var Effect = __webpack_require__(4);
  /**
   * Panner3D is based on the <a title="Web Audio Panner docs"  href=
   * "https://developer.mozilla.org/en-US/docs/Web/API/PannerNode">
   * Web Audio Spatial Panner Node</a>.
   * This panner is a spatial processing node that allows audio to be positioned
   * and oriented in 3D space.
   *
   * The position is relative to an <a title="Web Audio Listener docs" href=
   * "https://developer.mozilla.org/en-US/docs/Web/API/AudioListener">
   * Audio Context Listener</a>, which can be accessed
   * by <code>p5.soundOut.audiocontext.listener</code>
   *
   *
   * @class p5.Panner3D
   * @constructor
   */


  p5.Panner3D = function () {
    Effect.call(this);
    /**
     *  <a title="Web Audio Panner docs"  href=
     *  "https://developer.mozilla.org/en-US/docs/Web/API/PannerNode">
     *  Web Audio Spatial Panner Node</a>
     *
     *  Properties include
     *    -  <a title="w3 spec for Panning Model"
     *    href="https://www.w3.org/TR/webaudio/#idl-def-PanningModelType"
     *    >panningModel</a>: "equal power" or "HRTF"
     *    -  <a title="w3 spec for Distance Model"
     *    href="https://www.w3.org/TR/webaudio/#idl-def-DistanceModelType"
     *    >distanceModel</a>: "linear", "inverse", or "exponential"
     *
     *  @property {AudioNode} panner
     *
     */

    this.panner = this.ac.createPanner();
    this.panner.panningModel = 'HRTF';
    this.panner.distanceModel = 'linear';
    this.panner.connect(this.output);
    this.input.connect(this.panner);
  };

  p5.Panner3D.prototype = Object.create(Effect.prototype);
  /**
   * Connect an audio sorce
   *
   * @method  process
   * @for p5.Panner3D
   * @param  {Object} src Input source
   */

  p5.Panner3D.prototype.process = function (src) {
    src.connect(this.input);
  };
  /**
   * Set the X,Y,Z position of the Panner
   * @method set
   * @for p5.Panner3D
   * @param  {Number} xVal
   * @param  {Number} yVal
   * @param  {Number} zVal
   * @param  {Number} time
   * @return {Array}      Updated x, y, z values as an array
   */


  p5.Panner3D.prototype.set = function (xVal, yVal, zVal, time) {
    this.positionX(xVal, time);
    this.positionY(yVal, time);
    this.positionZ(zVal, time);
    return [this.panner.positionX.value, this.panner.positionY.value, this.panner.positionZ.value];
  };
  /**
   * Getter and setter methods for position coordinates
   * @method positionX
   * @for p5.Panner3D
   * @return {Number}      updated coordinate value
   */

  /**
   * Getter and setter methods for position coordinates
   * @method positionY
   * @for p5.Panner3D
   * @return {Number}      updated coordinate value
   */

  /**
   * Getter and setter methods for position coordinates
   * @method positionZ
   * @for p5.Panner3D
   * @return {Number}      updated coordinate value
   */


  p5.Panner3D.prototype.positionX = function (xVal, time) {
    var t = time || 0;

    if (typeof xVal === 'number') {
      this.panner.positionX.value = xVal;
      this.panner.positionX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.panner.positionX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);
    } else if (xVal) {
      xVal.connect(this.panner.positionX);
    }

    return this.panner.positionX.value;
  };

  p5.Panner3D.prototype.positionY = function (yVal, time) {
    var t = time || 0;

    if (typeof yVal === 'number') {
      this.panner.positionY.value = yVal;
      this.panner.positionY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.panner.positionY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);
    } else if (yVal) {
      yVal.connect(this.panner.positionY);
    }

    return this.panner.positionY.value;
  };

  p5.Panner3D.prototype.positionZ = function (zVal, time) {
    var t = time || 0;

    if (typeof zVal === 'number') {
      this.panner.positionZ.value = zVal;
      this.panner.positionZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.panner.positionZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);
    } else if (zVal) {
      zVal.connect(this.panner.positionZ);
    }

    return this.panner.positionZ.value;
  };
  /**
   * Set the X,Y,Z position of the Panner
   * @method  orient
   * @for p5.Panner3D
   * @param  {Number} xVal
   * @param  {Number} yVal
   * @param  {Number} zVal
   * @param  {Number} time
   * @return {Array}      Updated x, y, z values as an array
   */


  p5.Panner3D.prototype.orient = function (xVal, yVal, zVal, time) {
    this.orientX(xVal, time);
    this.orientY(yVal, time);
    this.orientZ(zVal, time);
    return [this.panner.orientationX.value, this.panner.orientationY.value, this.panner.orientationZ.value];
  };
  /**
   * Getter and setter methods for orient coordinates
   * @method orientX
   * @for p5.Panner3D
   * @return {Number}      updated coordinate value
   */

  /**
   * Getter and setter methods for orient coordinates
   * @method orientY
   * @for p5.Panner3D
   * @return {Number}      updated coordinate value
   */

  /**
   * Getter and setter methods for orient coordinates
   * @method orientZ
   * @for p5.Panner3D
   * @return {Number}      updated coordinate value
   */


  p5.Panner3D.prototype.orientX = function (xVal, time) {
    var t = time || 0;

    if (typeof xVal === 'number') {
      this.panner.orientationX.value = xVal;
      this.panner.orientationX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.panner.orientationX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);
    } else if (xVal) {
      xVal.connect(this.panner.orientationX);
    }

    return this.panner.orientationX.value;
  };

  p5.Panner3D.prototype.orientY = function (yVal, time) {
    var t = time || 0;

    if (typeof yVal === 'number') {
      this.panner.orientationY.value = yVal;
      this.panner.orientationY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.panner.orientationY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);
    } else if (yVal) {
      yVal.connect(this.panner.orientationY);
    }

    return this.panner.orientationY.value;
  };

  p5.Panner3D.prototype.orientZ = function (zVal, time) {
    var t = time || 0;

    if (typeof zVal === 'number') {
      this.panner.orientationZ.value = zVal;
      this.panner.orientationZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.panner.orientationZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);
    } else if (zVal) {
      zVal.connect(this.panner.orientationZ);
    }

    return this.panner.orientationZ.value;
  };
  /**
   * Set the rolloff factor and max distance
   * @method  setFalloff
   * @for p5.Panner3D
   * @param {Number} [maxDistance]
   * @param {Number} [rolloffFactor]
   */


  p5.Panner3D.prototype.setFalloff = function (maxDistance, rolloffFactor) {
    this.maxDist(maxDistance);
    this.rolloff(rolloffFactor);
  };
  /**
   * Maxium distance between the source and the listener
   * @method  maxDist
   * @for p5.Panner3D
   * @param  {Number} maxDistance
   * @return {Number} updated value
   */


  p5.Panner3D.prototype.maxDist = function (maxDistance) {
    if (typeof maxDistance === 'number') {
      this.panner.maxDistance = maxDistance;
    }

    return this.panner.maxDistance;
  };
  /**
   * How quickly the volume is reduced as the source moves away from the listener
   * @method  rollof
   * @for p5.Panner3D
   * @param  {Number} rolloffFactor
   * @return {Number} updated value
   */


  p5.Panner3D.prototype.rolloff = function (rolloffFactor) {
    if (typeof rolloffFactor === 'number') {
      this.panner.rolloffFactor = rolloffFactor;
    }

    return this.panner.rolloffFactor;
  };

  p5.Panner3D.dispose = function () {
    Effect.prototype.dispose.apply(this);

    if (this.panner) {
      this.panner.disconnect();
      delete this.panner;
    }
  };

  return p5.Panner3D;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var Effect = __webpack_require__(4); 
  //   * listener is a class that can construct both a Spatial Panner
  //   * and a Spatial Listener. The panner is based on the 
  //   * Web Audio Spatial Panner Node
  //   * https://www.w3.org/TR/webaudio/#the-listenernode-interface
  //   * This panner is a spatial processing node that allows audio to be positioned
  //   * and oriented in 3D space. 
  //   *
  //   * The Listener modifies the properties of the Audio Context Listener. 
  //   * Both objects types use the same methods. The default is a spatial panner.
  //   *
  //   * <code>p5.Panner3D</code> - Constructs a Spatial Panner<br/>
  //   * <code>p5.Listener3D</code> - Constructs a Spatial Listener<br/>
  //   *
  //   * @class listener
  //   * @constructor
  //   * @return {Object} p5.Listener3D Object
  //   *
  //   * @param {Web Audio Node} listener Web Audio Spatial Panning Node
  //   * @param {AudioParam} listener.panningModel "equal power" or "HRTF"
  //   * @param {AudioParam} listener.distanceModel "linear", "inverse", or "exponential"
  //   * @param {String} [type] [Specify construction of a spatial panner or listener]
  //   */


  p5.Listener3D = function (type) {
    this.ac = p5sound.audiocontext;
    this.listener = this.ac.listener;
  }; 
  //   * Connect an audio sorce
  //   * @param  {Object} src Input source
  //   */


  p5.Listener3D.prototype.process = function (src) {
    src.connect(this.input);
  }; 
  //   * Set the X,Y,Z position of the Panner
  //   * @param  {[Number]} xVal
  //   * @param  {[Number]} yVal
  //   * @param  {[Number]} zVal
  //   * @param  {[Number]} time
  //   * @return {[Array]}      [Updated x, y, z values as an array]
  //   */


  p5.Listener3D.prototype.position = function (xVal, yVal, zVal, time) {
    this.positionX(xVal, time);
    this.positionY(yVal, time);
    this.positionZ(zVal, time);
    return [this.listener.positionX.value, this.listener.positionY.value, this.listener.positionZ.value];
  }; 
  //   * Getter and setter methods for position coordinates
  //   * @return {Number}      [updated coordinate value]
  //   */


  p5.Listener3D.prototype.positionX = function (xVal, time) {
    var t = time || 0;

    if (typeof xVal === 'number') {
      this.listener.positionX.value = xVal;
      this.listener.positionX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.positionX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);
    } else if (xVal) {
      xVal.connect(this.listener.positionX);
    }

    return this.listener.positionX.value;
  };

  p5.Listener3D.prototype.positionY = function (yVal, time) {
    var t = time || 0;

    if (typeof yVal === 'number') {
      this.listener.positionY.value = yVal;
      this.listener.positionY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.positionY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);
    } else if (yVal) {
      yVal.connect(this.listener.positionY);
    }

    return this.listener.positionY.value;
  };

  p5.Listener3D.prototype.positionZ = function (zVal, time) {
    var t = time || 0;

    if (typeof zVal === 'number') {
      this.listener.positionZ.value = zVal;
      this.listener.positionZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.positionZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);
    } else if (zVal) {
      zVal.connect(this.listener.positionZ);
    }

    return this.listener.positionZ.value;
  }; 
  //   * Overrides the listener orient() method because Listener has slightly
  //   * different params. In human terms, Forward vectors are the direction the 
  //   * nose is pointing. Up vectors are the direction of the top of the head.
  //   *
  //   * @method orient
  //   * @param  {Number} xValF  Forward vector X direction
  //   * @param  {Number} yValF  Forward vector Y direction
  //   * @param  {Number} zValF  Forward vector Z direction
  //   * @param  {Number} xValU  Up vector X direction
  //   * @param  {Number} yValU  Up vector Y direction
  //   * @param  {Number} zValU  Up vector Z direction
  //   * @param  {Number} time  
  //   * @return {Array}       All orienation params
  //   */


  p5.Listener3D.prototype.orient = function (xValF, yValF, zValF, xValU, yValU, zValU, time) {
    if (arguments.length === 3 || arguments.length === 4) {
      time = arguments[3];
      this.orientForward(xValF, yValF, zValF, time);
    } else if (arguments.length === 6 || arguments === 7) {
      this.orientForward(xValF, yValF, zValF);
      this.orientUp(xValU, yValU, zValU, time);
    }

    return [this.listener.forwardX.value, this.listener.forwardY.value, this.listener.forwardZ.value, this.listener.upX.value, this.listener.upY.value, this.listener.upZ.value];
  };

  p5.Listener3D.prototype.orientForward = function (xValF, yValF, zValF, time) {
    this.forwardX(xValF, time);
    this.forwardY(yValF, time);
    this.forwardZ(zValF, time);
    return [this.listener.forwardX, this.listener.forwardY, this.listener.forwardZ];
  };

  p5.Listener3D.prototype.orientUp = function (xValU, yValU, zValU, time) {
    this.upX(xValU, time);
    this.upY(yValU, time);
    this.upZ(zValU, time);
    return [this.listener.upX, this.listener.upY, this.listener.upZ];
  }; 
  //   * Getter and setter methods for orient coordinates
  //   * @return {Number}      [updated coordinate value]
  //   */


  p5.Listener3D.prototype.forwardX = function (xVal, time) {
    var t = time || 0;

    if (typeof xVal === 'number') {
      this.listener.forwardX.value = xVal;
      this.listener.forwardX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.forwardX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);
    } else if (xVal) {
      xVal.connect(this.listener.forwardX);
    }

    return this.listener.forwardX.value;
  };

  p5.Listener3D.prototype.forwardY = function (yVal, time) {
    var t = time || 0;

    if (typeof yVal === 'number') {
      this.listener.forwardY.value = yVal;
      this.listener.forwardY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.forwardY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);
    } else if (yVal) {
      yVal.connect(this.listener.forwardY);
    }

    return this.listener.forwardY.value;
  };

  p5.Listener3D.prototype.forwardZ = function (zVal, time) {
    var t = time || 0;

    if (typeof zVal === 'number') {
      this.listener.forwardZ.value = zVal;
      this.listener.forwardZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.forwardZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);
    } else if (zVal) {
      zVal.connect(this.listener.forwardZ);
    }

    return this.listener.forwardZ.value;
  };

  p5.Listener3D.prototype.upX = function (xVal, time) {
    var t = time || 0;

    if (typeof xVal === 'number') {
      this.listener.upX.value = xVal;
      this.listener.upX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.upX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);
    } else if (xVal) {
      xVal.connect(this.listener.upX);
    }

    return this.listener.upX.value;
  };

  p5.Listener3D.prototype.upY = function (yVal, time) {
    var t = time || 0;

    if (typeof yVal === 'number') {
      this.listener.upY.value = yVal;
      this.listener.upY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.upY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);
    } else if (yVal) {
      yVal.connect(this.listener.upY);
    }

    return this.listener.upY.value;
  };

  p5.Listener3D.prototype.upZ = function (zVal, time) {
    var t = time || 0;

    if (typeof zVal === 'number') {
      this.listener.upZ.value = zVal;
      this.listener.upZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.listener.upZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);
    } else if (zVal) {
      zVal.connect(this.listener.upZ);
    }

    return this.listener.upZ.value;
  };

  return p5.Listener3D;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var Filter = __webpack_require__(15);

  var Effect = __webpack_require__(4);
  /**
   *  Delay is an echo effect. It processes an existing sound source,
   *  and outputs a delayed version of that sound. The p5.Delay can
   *  produce different effects depending on the delayTime, feedback,
   *  filter, and type. In the example below, a feedback of 0.5 (the
   *  default value) will produce a looping delay that decreases in
   *  volume by 50% each repeat. A filter will cut out the high
   *  frequencies so that the delay does not sound as piercing as the
   *  original source.
   *
   *
   *  This class extends <a href = "/reference/#/p5.Effect">p5.Effect</a>.
   *  Methods <a href = "/reference/#/p5.Effect/amp">amp()</a>, <a href = "/reference/#/p5.Effect/chain">chain()</a>,
   *  <a href = "/reference/#/p5.Effect/drywet">drywet()</a>, <a href = "/reference/#/p5.Effect/connect">connect()</a>, and
   *  <a href = "/reference/#/p5.Effect/disconnect">disconnect()</a> are available.
   *  @class p5.Delay
   *  @extends p5.Effect
   *  @constructor
   *  @example
   *  <div><code>
   *  let osc;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    background(220);
   *    textAlign(CENTER);
   *    text('tap to play', width/2, height/2);
   *
   *    osc = new p5.Oscillator('square');
   *    osc.amp(0.5);
   *    delay = new p5.Delay();
   *
   *    // delay.process() accepts 4 parameters:
   *    // source, delayTime (in seconds), feedback, filter frequency
   *    delay.process(osc, 0.12, .7, 2300);
   *
   *    cnv.mousePressed(oscStart);
   *  }
   *
   *  function oscStart() {
   *    osc.start();
   *  }
   *
   *  function mouseReleased() {
   *    osc.stop();
   *  }
   *  </code></div>
   */


  p5.Delay = function () {
    Effect.call(this);
    this._split = this.ac.createChannelSplitter(2);
    this._merge = this.ac.createChannelMerger(2);
    this._leftGain = this.ac.createGain();
    this._rightGain = this.ac.createGain();
    /**
     *  The p5.Delay is built with two
     *  <a href="http://www.w3.org/TR/webaudio/#DelayNode">
     *  Web Audio Delay Nodes</a>, one for each stereo channel.
     *
     *  @for p5.Delay
     *  @property {DelayNode} leftDelay
     */

    this.leftDelay = this.ac.createDelay();
    /**
     *  The p5.Delay is built with two
     *  <a href="http://www.w3.org/TR/webaudio/#DelayNode">
     *  Web Audio Delay Nodes</a>, one for each stereo channel.
     *  @for p5.Delay
     *  @property {DelayNode} rightDelay
     */

    this.rightDelay = this.ac.createDelay();
    this._leftFilter = new Filter();
    this._rightFilter = new Filter();

    this._leftFilter.disconnect();

    this._rightFilter.disconnect();

    this._leftFilter.biquad.frequency.setValueAtTime(1200, this.ac.currentTime);

    this._rightFilter.biquad.frequency.setValueAtTime(1200, this.ac.currentTime);

    this._leftFilter.biquad.Q.setValueAtTime(0.3, this.ac.currentTime);

    this._rightFilter.biquad.Q.setValueAtTime(0.3, this.ac.currentTime); 


    this.input.connect(this._split);
    this.leftDelay.connect(this._leftGain);
    this.rightDelay.connect(this._rightGain);

    this._leftGain.connect(this._leftFilter.input);

    this._rightGain.connect(this._rightFilter.input);

    this._merge.connect(this.wet);

    this._leftFilter.biquad.gain.setValueAtTime(1, this.ac.currentTime);

    this._rightFilter.biquad.gain.setValueAtTime(1, this.ac.currentTime); 


    this.setType(0);
    this._maxDelay = this.leftDelay.delayTime.maxValue; 

    this.feedback(0.5);
  };

  p5.Delay.prototype = Object.create(Effect.prototype);
  /**
   *  Add delay to an audio signal according to a set
   *  of delay parameters.
   *
   *  @method  process
   *  @for p5.Delay
   *  @param  {Object} Signal  An object that outputs audio
   *  @param  {Number} [delayTime] Time (in seconds) of the delay/echo.
   *                               Some browsers limit delayTime to
   *                               1 second.
   *  @param  {Number} [feedback]  sends the delay back through itself
   *                               in a loop that decreases in volume
   *                               each time.
   *  @param  {Number} [lowPass]   Cutoff frequency. Only frequencies
   *                               below the lowPass will be part of the
   *                               delay.
   */

  p5.Delay.prototype.process = function (src, _delayTime, _feedback, _filter) {
    var feedback = _feedback || 0;
    var delayTime = _delayTime || 0;

    if (feedback >= 1.0) {
      throw new Error('Feedback value will force a positive feedback loop.');
    }

    if (delayTime >= this._maxDelay) {
      throw new Error('Delay Time exceeds maximum delay time of ' + this._maxDelay + ' second.');
    }

    src.connect(this.input);
    this.leftDelay.delayTime.setValueAtTime(delayTime, this.ac.currentTime);
    this.rightDelay.delayTime.setValueAtTime(delayTime, this.ac.currentTime);
    this._leftGain.gain.value = feedback;
    this._rightGain.gain.value = feedback;

    if (_filter) {
      this._leftFilter.freq(_filter);

      this._rightFilter.freq(_filter);
    }
  };
  /**
   *  Set the delay (echo) time, in seconds. Usually this value will be
   *  a floating point number between 0.0 and 1.0.
   *
   *  @method  delayTime
   *  @for p5.Delay
   *  @param {Number} delayTime Time (in seconds) of the delay
   */


  p5.Delay.prototype.delayTime = function (t) {
    if (typeof t !== 'number') {
      t.connect(this.leftDelay.delayTime);
      t.connect(this.rightDelay.delayTime);
    } else {
      this.leftDelay.delayTime.cancelScheduledValues(this.ac.currentTime);
      this.rightDelay.delayTime.cancelScheduledValues(this.ac.currentTime);
      this.leftDelay.delayTime.linearRampToValueAtTime(t, this.ac.currentTime);
      this.rightDelay.delayTime.linearRampToValueAtTime(t, this.ac.currentTime);
    }
  };
  /**
   *  Feedback occurs when Delay sends its signal back through its input
   *  in a loop. The feedback amount determines how much signal to send each
   *  time through the loop. A feedback greater than 1.0 is not desirable because
   *  it will increase the overall output each time through the loop,
   *  creating an infinite feedback loop. The default value is 0.5
   *
   *  @method  feedback
   *  @for p5.Delay
   *  @param {Number|Object} feedback 0.0 to 1.0, or an object such as an
   *                                  Oscillator that can be used to
   *                                  modulate this param
   *  @returns {Number} Feedback value
   *
   */


  p5.Delay.prototype.feedback = function (f) {
    if (f && typeof f !== 'number') {
      f.connect(this._leftGain.gain);
      f.connect(this._rightGain.gain);
    } else if (f >= 1.0) {
      throw new Error('Feedback value will force a positive feedback loop.');
    } else if (typeof f === 'number') {
      this._leftGain.gain.value = f;
      this._rightGain.gain.value = f;
    } 


    return this._leftGain.gain.value;
  };
  /**
   *  Set a lowpass filter frequency for the delay. A lowpass filter
   *  will cut off any frequencies higher than the filter frequency.
   *
   *  @method  filter
   *  @for p5.Delay
   *  @param {Number|Object} cutoffFreq  A lowpass filter will cut off any
   *                              frequencies higher than the filter frequency.
   *  @param {Number|Object} res  Resonance of the filter frequency
   *                              cutoff, or an object (i.e. a p5.Oscillator)
   *                              that can be used to modulate this parameter.
   *                              High numbers (i.e. 15) will produce a resonance,
   *                              low numbers (i.e. .2) will produce a slope.
   */


  p5.Delay.prototype.filter = function (freq, q) {
    this._leftFilter.set(freq, q);

    this._rightFilter.set(freq, q);
  };
  /**
   *  Choose a preset type of delay. 'pingPong' bounces the signal
   *  from the left to the right channel to produce a stereo effect.
   *  Any other parameter will revert to the default delay setting.
   *
   *  @method  setType
   *  @for p5.Delay
   *  @param {String|Number} type 'pingPong' (1) or 'default' (0)
   */


  p5.Delay.prototype.setType = function (t) {
    if (t === 1) {
      t = 'pingPong';
    }

    this._split.disconnect();

    this._leftFilter.disconnect();

    this._rightFilter.disconnect();

    this._split.connect(this.leftDelay, 0);

    this._split.connect(this.rightDelay, 1);

    switch (t) {
      case 'pingPong':
        this._rightFilter.setType(this._leftFilter.biquad.type);

        this._leftFilter.output.connect(this._merge, 0, 0);

        this._rightFilter.output.connect(this._merge, 0, 1);

        this._leftFilter.output.connect(this.rightDelay);

        this._rightFilter.output.connect(this.leftDelay);

        break;

      default:
        this._leftFilter.output.connect(this._merge, 0, 0);

        this._rightFilter.output.connect(this._merge, 0, 1);

        this._leftFilter.output.connect(this.leftDelay);

        this._rightFilter.output.connect(this.rightDelay);

    }
  }; 

  /**
   *  Set the output level of the delay effect.
   *
   *  @method  amp
   *  @for p5.Delay
   *  @param  {Number} volume amplitude between 0 and 1.0
   *  @param {Number} [rampTime] create a fade that lasts rampTime
   *  @param {Number} [timeFromNow] schedule this event to happen
   *                                seconds from now
   */

  /**
   *  Send output to a p5.sound or web audio object
   *
   *  @method  connect
   *  @for p5.Delay
   *  @param  {Object} unit
   */

  /**
   *  Disconnect all output.
   *
   *  @method disconnect
   *  @for p5.Delay
   */


  p5.Delay.prototype.dispose = function () {
    Effect.prototype.dispose.apply(this);

    this._split.disconnect();

    this._leftFilter.dispose();

    this._rightFilter.dispose();

    this._merge.disconnect();

    this._leftGain.disconnect();

    this._rightGain.disconnect();

    this.leftDelay.disconnect();
    this.rightDelay.disconnect();
    this._split = undefined;
    this._leftFilter = undefined;
    this._rightFilter = undefined;
    this._merge = undefined;
    this._leftGain = undefined;
    this._rightGain = undefined;
    this.leftDelay = undefined;
    this.rightDelay = undefined;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var CustomError = __webpack_require__(11);

  var Effect = __webpack_require__(4);
  /**
   *  Reverb adds depth to a sound through a large number of decaying
   *  echoes. It creates the perception that sound is occurring in a
   *  physical space. The p5.Reverb has paramters for Time (how long does the
   *  reverb last) and decayRate (how much the sound decays with each echo)
   *  that can be set with the .set() or .process() methods. The p5.Convolver
   *  extends p5.Reverb allowing you to recreate the sound of actual physical
   *  spaces through convolution.
   *
   *  This class extends <a href = "/reference/#/p5.Effect">p5.Effect</a>.
   *  Methods <a href = "/reference/#/p5.Effect/amp">amp()</a>, <a href = "/reference/#/p5.Effect/chain">chain()</a>,
   *  <a href = "/reference/#/p5.Effect/drywet">drywet()</a>, <a href = "/reference/#/p5.Effect/connect">connect()</a>, and
   *  <a href = "/reference/#/p5.Effect/disconnect">disconnect()</a> are available.
   *
   *  @class p5.Reverb
   *  @extends p5.Effect
   *  @constructor
   *  @example
   *  <div><code>
   *  let soundFile, reverb;
   *  function preload() {
   *    soundFile = loadSound('assets/Damscray_DancingTiger.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playSound);
   *
   *    reverb = new p5.Reverb();
   *    soundFile.disconnect(); // so we'll only hear reverb...
   *
   *    // connect soundFile to reverb, process w/
   *    // 3 second reverbTime, decayRate of 2%
   *    reverb.process(soundFile, 3, 2);
   *  }
   *
   *  function draw() {
   *    let dryWet = constrain(map(mouseX, 0, width, 0, 1), 0, 1);
   *    // 1 = all reverb, 0 = no reverb
   *    reverb.drywet(dryWet);
   *
   *    background(220);
   *    text('tap to play', 10, 20);
   *    text('dry/wet: ' + round(dryWet * 100) + '%', 10, height - 20);
   *  }
   *
   *  function playSound() {
   *    soundFile.play();
   *  }
   *  </code></div>
   */


  p5.Reverb = function () {
    Effect.call(this);

    this._initConvolverNode(); 


    this.input.gain.value = 0.5; 

    this._seconds = 3;
    this._decay = 2;
    this._reverse = false;

    this._buildImpulse();
  };

  p5.Reverb.prototype = Object.create(Effect.prototype);

  p5.Reverb.prototype._initConvolverNode = function () {
    this.convolverNode = this.ac.createConvolver();
    this.input.connect(this.convolverNode);
    this.convolverNode.connect(this.wet);
  };

  p5.Reverb.prototype._teardownConvolverNode = function () {
    if (this.convolverNode) {
      this.convolverNode.disconnect();
      delete this.convolverNode;
    }
  };

  p5.Reverb.prototype._setBuffer = function (audioBuffer) {
    this._teardownConvolverNode();

    this._initConvolverNode();

    this.convolverNode.buffer = audioBuffer;
  };
  /**
   *  Connect a source to the reverb, and assign reverb parameters.
   *
   *  @method  process
   *  @for p5.Reverb
   *  @param  {Object} src     p5.sound / Web Audio object with a sound
   *                           output.
   *  @param  {Number} [seconds] Duration of the reverb, in seconds.
   *                           Min: 0, Max: 10. Defaults to 3.
   *  @param  {Number} [decayRate] Percentage of decay with each echo.
   *                            Min: 0, Max: 100. Defaults to 2.
   *  @param  {Boolean} [reverse] Play the reverb backwards or forwards.
   */


  p5.Reverb.prototype.process = function (src, seconds, decayRate, reverse) {
    src.connect(this.input);
    var rebuild = false;

    if (seconds) {
      this._seconds = seconds;
      rebuild = true;
    }

    if (decayRate) {
      this._decay = decayRate;
    }

    if (reverse) {
      this._reverse = reverse;
    }

    if (rebuild) {
      this._buildImpulse();
    }
  };
  /**
   *  Set the reverb settings. Similar to .process(), but without
   *  assigning a new input.
   *
   *  @method  set
   *  @for p5.Reverb
   *  @param  {Number} [seconds] Duration of the reverb, in seconds.
   *                           Min: 0, Max: 10. Defaults to 3.
   *  @param  {Number} [decayRate] Percentage of decay with each echo.
   *                            Min: 0, Max: 100. Defaults to 2.
   *  @param  {Boolean} [reverse] Play the reverb backwards or forwards.
   */


  p5.Reverb.prototype.set = function (seconds, decayRate, reverse) {
    var rebuild = false;

    if (seconds) {
      this._seconds = seconds;
      rebuild = true;
    }

    if (decayRate) {
      this._decay = decayRate;
    }

    if (reverse) {
      this._reverse = reverse;
    }

    if (rebuild) {
      this._buildImpulse();
    }
  }; 

  /**
   *  Set the output level of the reverb effect.
   *
   *  @method  amp
   *  @for p5.Reverb
   *  @param  {Number} volume amplitude between 0 and 1.0
   *  @param  {Number} [rampTime] create a fade that lasts rampTime
   *  @param  {Number} [timeFromNow] schedule this event to happen
   *                                seconds from now
   */

  /**
   *  Send output to a p5.sound or web audio object
   *
   *  @method  connect
   *  @for p5.Reverb
   *  @param  {Object} unit
   */

  /**
   *  Disconnect all output.
   *
   *  @method disconnect
   *  @for p5.Reverb
   */

  /**
   *  Inspired by Simple Reverb by Jordan Santell
   *  https://github.com/web-audio-components/simple-reverb/blob/master/index.js
   *
   *  Utility function for building an impulse response
   *  based on the module parameters.
   *
   *  @private
   */


  p5.Reverb.prototype._buildImpulse = function () {
    var rate = this.ac.sampleRate;
    var length = rate * this._seconds;
    var decay = this._decay;
    var impulse = this.ac.createBuffer(2, length, rate);
    var impulseL = impulse.getChannelData(0);
    var impulseR = impulse.getChannelData(1);
    var n, i;

    for (i = 0; i < length; i++) {
      n = this._reverse ? length - i : i;
      impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
      impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
    }

    this._setBuffer(impulse);
  };

  p5.Reverb.prototype.dispose = function () {
    Effect.prototype.dispose.apply(this);

    this._teardownConvolverNode();
  }; 

  /**
   *  <p>p5.Convolver extends p5.Reverb. It can emulate the sound of real
   *  physical spaces through a process called <a href="
   *  https://en.wikipedia.org/wiki/Convolution_reverb#Real_space_simulation">
   *  convolution</a>.</p>
   *
   *  <p>Convolution multiplies any audio input by an "impulse response"
   *  to simulate the dispersion of sound over time. The impulse response is
   *  generated from an audio file that you provide. One way to
   *  generate an impulse response is to pop a balloon in a reverberant space
   *  and record the echo. Convolution can also be used to experiment with
   *  sound.</p>
   *
   *  <p>Use the method <code>createConvolution(path)</code> to instantiate a
   *  p5.Convolver with a path to your impulse response audio file.</p>
   *
   *  @class p5.Convolver
   *  @extends p5.Effect
   *  @constructor
   *  @param  {String}   path     path to a sound file
   *  @param  {Function} [callback] function to call when loading succeeds
   *  @param  {Function} [errorCallback] function to call if loading fails.
   *                                     This function will receive an error or
   *                                     XMLHttpRequest object with information
   *                                     about what went wrong.
   *  @example
   *  <div><code>
   *  let cVerb, sound;
   *  function preload() {
   *    // We have both MP3 and OGG versions of all sound assets
   *    soundFormats('ogg', 'mp3');
   *
   *    // Try replacing 'bx-spring' with other soundfiles like
   *    // 'concrete-tunnel' 'small-plate' 'drum' 'beatbox'
   *    cVerb = createConvolver('assets/bx-spring.mp3');
   *
   *    // Try replacing 'Damscray_DancingTiger' with
   *    // 'beat', 'doorbell', lucky_dragons_-_power_melody'
   *    sound = loadSound('assets/Damscray_DancingTiger.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playSound);
   *    background(220);
   *    text('tap to play', 20, 20);
   *
   *    // disconnect from master output...
   *    sound.disconnect();
   *
   *    // ...and process with cVerb
   *    // so that we only hear the convolution
   *    cVerb.process(sound);
   *  }
   *
   *  function playSound() {
   *    sound.play();
   *  }
   *  </code></div>
   */


  p5.Convolver = function (path, callback, errorCallback) {
    p5.Reverb.call(this);
    /**
     *  Internally, the p5.Convolver uses the a
     *  <a href="http://www.w3.org/TR/webaudio/#ConvolverNode">
     *  Web Audio Convolver Node</a>.
     *
     *  @property {ConvolverNode} convolverNode
     */

    this._initConvolverNode(); 


    this.input.gain.value = 0.5;

    if (path) {
      this.impulses = [];

      this._loadBuffer(path, callback, errorCallback);
    } else {
      this._seconds = 3;
      this._decay = 2;
      this._reverse = false;

      this._buildImpulse();
    }
  };

  p5.Convolver.prototype = Object.create(p5.Reverb.prototype);
  p5.prototype.registerPreloadMethod('createConvolver', p5.prototype);
  /**
   *  Create a p5.Convolver. Accepts a path to a soundfile
   *  that will be used to generate an impulse response.
   *
   *  @method  createConvolver
   *  @for p5
   *  @param  {String}   path     path to a sound file
   *  @param  {Function} [callback] function to call if loading is successful.
   *                                The object will be passed in as the argument
   *                                to the callback function.
   *  @param  {Function} [errorCallback] function to call if loading is not successful.
   *                                A custom error will be passed in as the argument
   *                                to the callback function.
   *  @return {p5.Convolver}
   *  @example
   *  <div><code>
   *  let cVerb, sound;
   *  function preload() {
   *    // We have both MP3 and OGG versions of all sound assets
   *    soundFormats('ogg', 'mp3');
   *
   *    // Try replacing 'bx-spring' with other soundfiles like
   *    // 'concrete-tunnel' 'small-plate' 'drum' 'beatbox'
   *    cVerb = createConvolver('assets/bx-spring.mp3');
   *
   *    // Try replacing 'Damscray_DancingTiger' with
   *    // 'beat', 'doorbell', lucky_dragons_-_power_melody'
   *    sound = loadSound('assets/Damscray_DancingTiger.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playSound);
   *    background(220);
   *    text('tap to play', 20, 20);
   *
   *    // disconnect from master output...
   *    sound.disconnect();
   *
   *    // ...and process with cVerb
   *    // so that we only hear the convolution
   *    cVerb.process(sound);
   *  }
   *
   *  function playSound() {
   *    sound.play();
   *  }
   *  </code></div>
   */

  p5.prototype.createConvolver = function (path, callback, errorCallback) {
    if (window.location.origin.indexOf('file://') > -1 && window.cordova === 'undefined') {
      alert('This sketch may require a server to load external files. Please see http://bit.ly/1qcInwS');
    }

    var self = this;
    var cReverb = new p5.Convolver(path, function (buffer) {
      if (typeof callback === 'function') {
        callback(buffer);
      }

      if (typeof self._decrementPreload === 'function') {
        self._decrementPreload();
      }
    }, errorCallback);
    cReverb.impulses = [];
    return cReverb;
  };
  /**
   *  Private method to load a buffer as an Impulse Response,
   *  assign it to the convolverNode, and add to the Array of .impulses.
   *
   *  @param   {String}   path
   *  @param   {Function} callback
   *  @param   {Function} errorCallback
   *  @private
   */


  p5.Convolver.prototype._loadBuffer = function (path, callback, errorCallback) {
    var path = p5.prototype._checkFileFormats(path);

    var self = this;
    var errorTrace = new Error().stack;
    var ac = p5.prototype.getAudioContext();
    var request = new XMLHttpRequest();
    request.open('GET', path, true);
    request.responseType = 'arraybuffer';

    request.onload = function () {
      if (request.status === 200) {
        ac.decodeAudioData(request.response, function (buff) {
          var buffer = {};
          var chunks = path.split('/');
          buffer.name = chunks[chunks.length - 1];
          buffer.audioBuffer = buff;
          self.impulses.push(buffer);

          self._setBuffer(buffer.audioBuffer);

          if (callback) {
            callback(buffer);
          }
        }, 
        function () {
          var err = new CustomError('decodeAudioData', errorTrace, self.url);
          var msg = 'AudioContext error at decodeAudioData for ' + self.url;

          if (errorCallback) {
            err.msg = msg;
            errorCallback(err);
          } else {
            console.error(msg + '\n The error stack trace includes: \n' + err.stack);
          }
        });
      } 
      else {
          var err = new CustomError('loadConvolver', errorTrace, self.url);
          var msg = 'Unable to load ' + self.url + '. The request status was: ' + request.status + ' (' + request.statusText + ')';

          if (errorCallback) {
            err.message = msg;
            errorCallback(err);
          } else {
            console.error(msg + '\n The error stack trace includes: \n' + err.stack);
          }
        }
    }; 


    request.onerror = function () {
      var err = new CustomError('loadConvolver', errorTrace, self.url);
      var msg = 'There was no response from the server at ' + self.url + '. Check the url and internet connectivity.';

      if (errorCallback) {
        err.message = msg;
        errorCallback(err);
      } else {
        console.error(msg + '\n The error stack trace includes: \n' + err.stack);
      }
    };

    request.send();
  };

  p5.Convolver.prototype.set = null;
  /**
   *  Connect a source to the convolver.
   *
   *  @method  process
   *  @for p5.Convolver
   *  @param  {Object} src     p5.sound / Web Audio object with a sound
   *                           output.
   *  @example
   *  <div><code>
   *  let cVerb, sound;
   *  function preload() {
   *    // We have both MP3 and OGG versions of all sound assets
   *    soundFormats('ogg', 'mp3');
   *
   *    // Try replacing 'bx-spring' with other soundfiles like
   *    // 'concrete-tunnel' 'small-plate' 'drum' 'beatbox'
   *    cVerb = createConvolver('assets/bx-spring.mp3');
   *
   *    // Try replacing 'Damscray_DancingTiger' with
   *    // 'beat', 'doorbell', lucky_dragons_-_power_melody'
   *    sound = loadSound('assets/Damscray_DancingTiger.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playSound);
   *    background(220);
   *    text('tap to play', 20, 20);
   *
   *    // disconnect from master output...
   *    sound.disconnect();
   *
   *    // ...and process with cVerb
   *    // so that we only hear the convolution
   *    cVerb.process(sound);
   *  }
   *
   *  function playSound() {
   *    sound.play();
   *  }
   *
   *  </code></div>
   */

  p5.Convolver.prototype.process = function (src) {
    src.connect(this.input);
  };
  /**
   *  If you load multiple impulse files using the .addImpulse method,
   *  they will be stored as Objects in this Array. Toggle between them
   *  with the <code>toggleImpulse(id)</code> method.
   *
   *  @property {Array} impulses
   *  @for p5.Convolver
   */


  p5.Convolver.prototype.impulses = [];
  /**
   *  Load and assign a new Impulse Response to the p5.Convolver.
   *  The impulse is added to the <code>.impulses</code> array. Previous
   *  impulses can be accessed with the <code>.toggleImpulse(id)</code>
   *  method.
   *
   *  @method  addImpulse
   *  @for p5.Convolver
   *  @param  {String}   path     path to a sound file
   *  @param  {Function} callback function (optional)
   *  @param  {Function} errorCallback function (optional)
   */

  p5.Convolver.prototype.addImpulse = function (path, callback, errorCallback) {
    if (window.location.origin.indexOf('file://') > -1 && window.cordova === 'undefined') {
      alert('This sketch may require a server to load external files. Please see http://bit.ly/1qcInwS');
    }

    this._loadBuffer(path, callback, errorCallback);
  };
  /**
   *  Similar to .addImpulse, except that the <code>.impulses</code>
   *  Array is reset to save memory. A new <code>.impulses</code>
   *  array is created with this impulse as the only item.
   *
   *  @method  resetImpulse
   *  @for p5.Convolver
   *  @param  {String}   path     path to a sound file
   *  @param  {Function} callback function (optional)
   *  @param  {Function} errorCallback function (optional)
   */


  p5.Convolver.prototype.resetImpulse = function (path, callback, errorCallback) {
    if (window.location.origin.indexOf('file://') > -1 && window.cordova === 'undefined') {
      alert('This sketch may require a server to load external files. Please see http://bit.ly/1qcInwS');
    }

    this.impulses = [];

    this._loadBuffer(path, callback, errorCallback);
  };
  /**
   *  If you have used <code>.addImpulse()</code> to add multiple impulses
   *  to a p5.Convolver, then you can use this method to toggle between
   *  the items in the <code>.impulses</code> Array. Accepts a parameter
   *  to identify which impulse you wish to use, identified either by its
   *  original filename (String) or by its position in the <code>.impulses
   *  </code> Array (Number).<br/>
   *  You can access the objects in the .impulses Array directly. Each
   *  Object has two attributes: an <code>.audioBuffer</code> (type:
   *  Web Audio <a href="
   *  http://webaudio.github.io/web-audio-api/#the-audiobuffer-interface">
   *  AudioBuffer)</a> and a <code>.name</code>, a String that corresponds
   *  with the original filename.
   *
   *  @method toggleImpulse
   *  @for p5.Convolver
   *  @param {String|Number} id Identify the impulse by its original filename
   *                            (String), or by its position in the
   *                            <code>.impulses</code> Array (Number).
   */


  p5.Convolver.prototype.toggleImpulse = function (id) {
    if (typeof id === 'number' && id < this.impulses.length) {
      this._setBuffer(this.impulses[id].audioBuffer);
    }

    if (typeof id === 'string') {
      for (var i = 0; i < this.impulses.length; i++) {
        if (this.impulses[i].name === id) {
          this._setBuffer(this.impulses[i].audioBuffer);

          break;
        }
      }
    }
  };

  p5.Convolver.prototype.dispose = function () {
    p5.Reverb.prototype.dispose.apply(this); 

    for (var i in this.impulses) {
      if (this.impulses[i]) {
        this.impulses[i] = null;
      }
    }
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1); 


  var Clock = __webpack_require__(27);

  p5.Metro = function () {
    this.clock = new Clock({
      'callback': this.ontick.bind(this)
    });
    this.syncedParts = [];
    this.bpm = 120; 

    this._init();

    this.prevTick = 0;
    this.tatumTime = 0;

    this.tickCallback = function () {};
  };

  p5.Metro.prototype.ontick = function (tickTime) {
    var elapsedTime = tickTime - this.prevTick;
    var secondsFromNow = tickTime - p5sound.audiocontext.currentTime;

    if (elapsedTime - this.tatumTime <= -0.02) {
      return;
    } else {
      this.prevTick = tickTime; 

      var self = this;
      this.syncedParts.forEach(function (thisPart) {
        if (!thisPart.isPlaying) return;
        thisPart.incrementStep(secondsFromNow); 

        thisPart.phrases.forEach(function (thisPhrase) {
          var phraseArray = thisPhrase.sequence;
          var bNum = self.metroTicks % phraseArray.length;

          if (phraseArray[bNum] !== 0 && (self.metroTicks < phraseArray.length || !thisPhrase.looping)) {
            thisPhrase.callback(secondsFromNow, phraseArray[bNum]);
          }
        });
      });
      this.metroTicks += 1;
      this.tickCallback(secondsFromNow);
    }
  };

  p5.Metro.prototype.setBPM = function (bpm, rampTime) {
    var beatTime = 60 / (bpm * this.tatums);
    var now = p5sound.audiocontext.currentTime;
    this.tatumTime = beatTime;
    var rampTime = rampTime || 0;
    this.clock.frequency.setValueAtTime(this.clock.frequency.value, now);
    this.clock.frequency.linearRampToValueAtTime(bpm, now + rampTime);
    this.bpm = bpm;
  };

  p5.Metro.prototype.getBPM = function () {
    return this.clock.getRate() / this.tatums * 60;
  };

  p5.Metro.prototype._init = function () {
    this.metroTicks = 0; 
  }; 


  p5.Metro.prototype.resetSync = function (part) {
    this.syncedParts = [part];
  }; 


  p5.Metro.prototype.pushSync = function (part) {
    this.syncedParts.push(part);
  };

  p5.Metro.prototype.start = function (timeFromNow) {
    var t = timeFromNow || 0;
    var now = p5sound.audiocontext.currentTime;
    this.clock.start(now + t);
    this.setBPM(this.bpm);
  };

  p5.Metro.prototype.stop = function (timeFromNow) {
    var t = timeFromNow || 0;
    var now = p5sound.audiocontext.currentTime;
    this.clock.stop(now + t);
  };

  p5.Metro.prototype.beatLength = function (tatums) {
    this.tatums = 1 / tatums / 4; 
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0),__webpack_require__(24),__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(t){"use strict";return t.TimelineState=function(e){t.Timeline.call(this),this._initial=e},t.extend(t.TimelineState,t.Timeline),t.TimelineState.prototype.getValueAtTime=function(e){var t=this.get(e);return null!==t?t.state:this._initial},t.TimelineState.prototype.setStateAtTime=function(e,t){this.add({state:e,time:t})},t.TimelineState}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var BPM = 120;
  /**
   *  Set the global tempo, in beats per minute, for all
   *  p5.Parts. This method will impact all active p5.Parts.
   *
   *  @method setBPM
   *  @for p5
   *  @param {Number} BPM      Beats Per Minute
   *  @param {Number} rampTime Seconds from now
   */

  p5.prototype.setBPM = function (bpm, rampTime) {
    BPM = bpm;

    for (var i in p5sound.parts) {
      if (p5sound.parts[i]) {
        p5sound.parts[i].setBPM(bpm, rampTime);
      }
    }
  };
  /**
   *  <p>A phrase is a pattern of musical events over time, i.e.
   *  a series of notes and rests.</p>
   *
   *  <p>Phrases must be added to a p5.Part for playback, and
   *  each part can play multiple phrases at the same time.
   *  For example, one Phrase might be a kick drum, another
   *  could be a snare, and another could be the bassline.</p>
   *
   *  <p>The first parameter is a name so that the phrase can be
   *  modified or deleted later. The callback is a a function that
   *  this phrase will call at every stepfor example it might be
   *  called <code>playNote(value){}</code>. The array determines
   *  which value is passed into the callback at each step of the
   *  phrase. It can be numbers, an object with multiple numbers,
   *  or a zero (0) indicates a rest so the callback won't be called).</p>
   *
   *  @class p5.Phrase
   *  @constructor
   *  @param {String}   name     Name so that you can access the Phrase.
   *  @param {Function} callback The name of a function that this phrase
   *                             will call. Typically it will play a sound,
   *                             and accept two parameters: a time at which
   *                             to play the sound (in seconds from now),
   *                             and a value from the sequence array. The
   *                             time should be passed into the play() or
   *                             start() method to ensure precision.
   *  @param {Array}   sequence    Array of values to pass into the callback
   *                            at each step of the phrase.
   *  @example
   *  <div><code>
   *  let mySound, myPhrase, myPart;
   *  let pattern = [1,0,0,2,0,2,0,0];
   *
   *  function preload() {
   *    mySound = loadSound('assets/beatbox.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playMyPart);
   *    background(220);
   *    text('tap to play', width/2, height/2);
   *    textAlign(CENTER, CENTER);
   *
   *    myPhrase = new p5.Phrase('bbox', onEachStep, pattern);
   *    myPart = new p5.Part();
   *    myPart.addPhrase(myPhrase);
   *    myPart.setBPM(60);
   *  }
   *
   *  function onEachStep(time, playbackRate) {
   *    mySound.rate(playbackRate);
   *    mySound.play(time);
   *  }
   *
   *  function playMyPart() {
   *    userStartAudio();
   *    myPart.start();
   *  }
   *  </code></div>
   */


  p5.Phrase = function (name, callback, sequence) {
    this.phraseStep = 0;
    this.name = name;
    this.callback = callback;
    /**
     * Array of values to pass into the callback
     * at each step of the phrase. Depending on the callback
     * function's requirements, these values may be numbers,
     * strings, or an object with multiple parameters.
     * Zero (0) indicates a rest.
     *
     * @property {Array} sequence
     */

    this.sequence = sequence;
  };
  /**
   *  <p>A p5.Part plays back one or more p5.Phrases. Instantiate a part
   *  with steps and tatums. By default, each step represents a 1/16th note.</p>
   *
   *  <p>See p5.Phrase for more about musical timing.</p>
   *
   *  @class p5.Part
   *  @constructor
   *  @param {Number} [steps]   Steps in the part
   *  @param {Number} [tatums] Divisions of a beat, e.g. use 1/4, or 0.25 for a quater note (default is 1/16, a sixteenth note)
   *  @example
   *  <div><code>
   *  let box, drum, myPart;
   *  let boxPat = [1,0,0,2,0,2,0,0];
   *  let drumPat = [0,1,1,0,2,0,1,0];
   *
   *  function preload() {
   *    box = loadSound('assets/beatbox.mp3');
   *    drum = loadSound('assets/drum.mp3');
   *  }
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(playMyPart);
   *    background(220);
   *    textAlign(CENTER, CENTER);
   *    text('tap to play', width/2, height/2);
   *
   *    let boxPhrase = new p5.Phrase('box', playBox, boxPat);
   *    let drumPhrase = new p5.Phrase('drum', playDrum, drumPat);
   *    myPart = new p5.Part();
   *    myPart.addPhrase(boxPhrase);
   *    myPart.addPhrase(drumPhrase);
   *    myPart.setBPM(60);
   *  }
   *
   *  function playBox(time, playbackRate) {
   *    box.rate(playbackRate);
   *    box.play(time);
   *  }
   *
   *  function playDrum(time, playbackRate) {
   *    drum.rate(playbackRate);
   *    drum.play(time);
   *  }
   *
   *  function playMyPart() {
   *    userStartAudio();
   *
   *    myPart.start();
   *  }
   *  </code></div>
   */


  p5.Part = function (steps, bLength) {
    this.length = steps || 0; 

    this.partStep = 0;
    this.phrases = [];
    this.isPlaying = false;
    this.noLoop();
    this.tatums = bLength || 0.0625; 

    this.metro = new p5.Metro();

    this.metro._init();

    this.metro.beatLength(this.tatums);
    this.metro.setBPM(BPM);
    p5sound.parts.push(this);

    this.callback = function () {};
  };
  /**
   *  Set the tempo of this part, in Beats Per Minute.
   *
   *  @method  setBPM
   *  @for p5.Part
   *  @param {Number} BPM      Beats Per Minute
   *  @param {Number} [rampTime] Seconds from now
   */


  p5.Part.prototype.setBPM = function (tempo, rampTime) {
    this.metro.setBPM(tempo, rampTime);
  };
  /**
   *  Returns the tempo, in Beats Per Minute, of this part.
   *
   *  @method getBPM
   *  @for p5.Part
   *  @return {Number}
   */


  p5.Part.prototype.getBPM = function () {
    return this.metro.getBPM();
  };
  /**
   *  Start playback of this part. It will play
   *  through all of its phrases at a speed
   *  determined by setBPM.
   *
   *  @method  start
   *  @for p5.Part
   *  @param  {Number} [time] seconds from now
   */


  p5.Part.prototype.start = function (time) {
    if (!this.isPlaying) {
      this.isPlaying = true;
      this.metro.resetSync(this);
      var t = time || 0;
      this.metro.start(t);
    }
  };
  /**
   *  Loop playback of this part. It will begin
   *  looping through all of its phrases at a speed
   *  determined by setBPM.
   *
   *  @method  loop
   *  @for p5.Part
   *  @param  {Number} [time] seconds from now
   */


  p5.Part.prototype.loop = function (time) {
    this.looping = true; 

    this.onended = function () {
      this.partStep = 0;
    };

    var t = time || 0;
    this.start(t);
  };
  /**
   *  Tell the part to stop looping.
   *
   *  @method  noLoop
   *  @for p5.Part
   */


  p5.Part.prototype.noLoop = function () {
    this.looping = false; 

    this.onended = function () {
      this.stop();
    };
  };
  /**
   *  Stop the part and cue it to step 0. Playback will resume from the begining of the Part when it is played again.
   *
   *  @method  stop
   *  @for p5.Part
   *  @param  {Number} [time] seconds from now
   */


  p5.Part.prototype.stop = function (time) {
    this.partStep = 0;
    this.pause(time);
  };
  /**
   *  Pause the part. Playback will resume
   *  from the current step.
   *
   *  @method  pause
   *  @for p5.Part
   *  @param  {Number} time seconds from now
   */


  p5.Part.prototype.pause = function (time) {
    this.isPlaying = false;
    var t = time || 0;
    this.metro.stop(t);
  };
  /**
   *  Add a p5.Phrase to this Part.
   *
   *  @method  addPhrase
   *  @for p5.Part
   *  @param {p5.Phrase}   phrase   reference to a p5.Phrase
   */


  p5.Part.prototype.addPhrase = function (name, callback, array) {
    var p;

    if (arguments.length === 3) {
      p = new p5.Phrase(name, callback, array);
    } else if (arguments[0] instanceof p5.Phrase) {
      p = arguments[0];
    } else {
      throw 'invalid input. addPhrase accepts name, callback, array or a p5.Phrase';
    }

    this.phrases.push(p); 

    if (p.sequence.length > this.length) {
      this.length = p.sequence.length;
    }
  };
  /**
   *  Remove a phrase from this part, based on the name it was
   *  given when it was created.
   *
   *  @method  removePhrase
   *  @for p5.Part
   *  @param  {String} phraseName
   */


  p5.Part.prototype.removePhrase = function (name) {
    for (var i in this.phrases) {
      if (this.phrases[i].name === name) {
        this.phrases.splice(i, 1);
      }
    }
  };
  /**
   *  Get a phrase from this part, based on the name it was
   *  given when it was created. Now you can modify its array.
   *
   *  @method  getPhrase
   *  @for p5.Part
   *  @param  {String} phraseName
   */


  p5.Part.prototype.getPhrase = function (name) {
    for (var i in this.phrases) {
      if (this.phrases[i].name === name) {
        return this.phrases[i];
      }
    }
  };
  /**
   *  Find all sequences with the specified name, and replace their patterns with the specified array.
   *
   *  @method  replaceSequence
   *  @for p5.Part
   *  @param  {String} phraseName
   *  @param  {Array} sequence  Array of values to pass into the callback
   *                            at each step of the phrase.
   */


  p5.Part.prototype.replaceSequence = function (name, array) {
    for (var i in this.phrases) {
      if (this.phrases[i].name === name) {
        this.phrases[i].sequence = array;
      }
    }
  };

  p5.Part.prototype.incrementStep = function (time) {
    if (this.partStep < this.length - 1) {
      this.callback(time);
      this.partStep += 1;
    } else {
      if (!this.looping && this.partStep === this.length - 1) {
        this.onended();
      }
    }
  };
  /**
   *  Set the function that will be called at every step. This will clear the previous function.
   *
   *  @method onStep
   *  @for p5.Part
   *  @param  {Function} callback The name of the callback
   *                              you want to fire
   *                              on every beat/tatum.
   */


  p5.Part.prototype.onStep = function (callback) {
    this.callback = callback;
  }; 

  /**
   *  A Score consists of a series of Parts. The parts will
   *  be played back in order. For example, you could have an
   *  A part, a B part, and a C part, and play them back in this order
   *  <code>new p5.Score(a, a, b, a, c)</code>
   *
   *  @class p5.Score
   *  @constructor
   *  @param {p5.Part} [...parts] One or multiple parts, to be played in sequence.
   */


  p5.Score = function () {
    this.parts = [];
    this.currentPart = 0;
    var thisScore = this;

    for (var i in arguments) {
      if (arguments[i] && this.parts[i]) {
        this.parts[i] = arguments[i];
        this.parts[i].nextPart = this.parts[i + 1];

        this.parts[i].onended = function () {
          thisScore.resetPart(i);
          playNextPart(thisScore);
        };
      }
    }

    this.looping = false;
  };

  p5.Score.prototype.onended = function () {
    if (this.looping) {
      this.parts[0].start();
    } else {
      this.parts[this.parts.length - 1].onended = function () {
        this.stop();
        this.resetParts();
      };
    }

    this.currentPart = 0;
  };
  /**
   *  Start playback of the score.
   *
   *  @method  start
   *  @for p5.Score
   */


  p5.Score.prototype.start = function () {
    this.parts[this.currentPart].start();
    this.scoreStep = 0;
  };
  /**
   *  Stop playback of the score.
   *
   *  @method  stop
   *  @for p5.Score
   */


  p5.Score.prototype.stop = function () {
    this.parts[this.currentPart].stop();
    this.currentPart = 0;
    this.scoreStep = 0;
  };
  /**
   *  Pause playback of the score.
   *
   *  @method  pause
   *  @for p5.Score
   */


  p5.Score.prototype.pause = function () {
    this.parts[this.currentPart].stop();
  };
  /**
   *  Loop playback of the score.
   *
   *  @method  loop
   *  @for p5.Score
   */


  p5.Score.prototype.loop = function () {
    this.looping = true;
    this.start();
  };
  /**
   *  Stop looping playback of the score. If it
   *  is currently playing, this will go into effect
   *  after the current round of playback completes.
   *
   *  @method  noLoop
   *  @for p5.Score
   */


  p5.Score.prototype.noLoop = function () {
    this.looping = false;
  };

  p5.Score.prototype.resetParts = function () {
    var self = this;
    this.parts.forEach(function (part) {
      self.resetParts[part];
    });
  };

  p5.Score.prototype.resetPart = function (i) {
    this.parts[i].stop();
    this.parts[i].partStep = 0;

    for (var p in this.parts[i].phrases) {
      if (this.parts[i]) {
        this.parts[i].phrases[p].phraseStep = 0;
      }
    }
  };
  /**
   *  Set the tempo for all parts in the score
   *
   *  @method setBPM
   *  @for p5.Score
   *  @param {Number} BPM      Beats Per Minute
   *  @param {Number} rampTime Seconds from now
   */


  p5.Score.prototype.setBPM = function (bpm, rampTime) {
    for (var i in this.parts) {
      if (this.parts[i]) {
        this.parts[i].setBPM(bpm, rampTime);
      }
    }
  };

  function playNextPart(aScore) {
    aScore.currentPart++;

    if (aScore.currentPart >= aScore.parts.length) {
      aScore.scoreStep = 0;
      aScore.onended();
    } else {
      aScore.scoreStep = 0;
      aScore.parts[aScore.currentPart - 1].stop();
      aScore.parts[aScore.currentPart].start();
    }
  }
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var Clock = __webpack_require__(27);
  /**
   * SoundLoop
   *
   * @class p5.SoundLoop
   * @constructor
   *
   * @param {Function} callback this function will be called on each iteration of theloop
   * @param {Number|String} [interval] amount of time (if a number) or beats (if a string, following <a href = "https://github.com/Tonejs/Tone.js/wiki/Time">Tone.Time</a> convention) for each iteration of the loop. Defaults to 1 second.
   *
   * @example
   * <div><code>
   *  let synth, soundLoop;
   *  let notePattern = [60, 62, 64, 67, 69, 72];
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    colorMode(HSB);
   *    background(0, 0, 86);
   *    text('tap to start/stop', 10, 20);
   *
   *    //the looper's callback is passed the timeFromNow
   *    //this value should be used as a reference point from
   *    //which to schedule sounds
   *    let intervalInSeconds = 0.2;
   *    soundLoop = new p5.SoundLoop(onSoundLoop, intervalInSeconds);
   *
   *    synth = new p5.MonoSynth();
   * }
   *
   * function canvasPressed() {
   *   // ensure audio is enabled
   *   userStartAudio();
   *
   *   if (soundLoop.isPlaying) {
   *     soundLoop.stop();
   *   } else {
   *     // start the loop
   *     soundLoop.start();
   *   }
   * }
   *
   * function onSoundLoop(timeFromNow) {
   *   let noteIndex = (soundLoop.iterations - 1) % notePattern.length;
   *   let note = midiToFreq(notePattern[noteIndex]);
   *   synth.play(note, 0.5, timeFromNow);
   *   background(noteIndex * 360 / notePattern.length, 50, 100);
   * }
   * </code></div>
   */


  p5.SoundLoop = function (callback, interval) {
    this.callback = callback;
    /**
     * musicalTimeMode uses <a href = "https://github.com/Tonejs/Tone.js/wiki/Time">Tone.Time</a> convention
     * true if string, false if number
     * @property {Boolean} musicalTimeMode
     */

    this.musicalTimeMode = typeof this._interval === 'number' ? false : true;
    this._interval = interval || 1;
    /**
     * musicalTimeMode variables
     * modify these only when the interval is specified in musicalTime format as a string
     */

    this._timeSignature = 4;
    this._bpm = 60;
    this.isPlaying = false;
    /**
     * Set a limit to the number of loops to play. defaults to Infinity
     * @property {Number} maxIterations
     */

    this.maxIterations = Infinity;
    var self = this;
    this.clock = new Clock({
      'callback': function callback(time) {
        var timeFromNow = time - p5sound.audiocontext.currentTime;
        /**
         * Do not initiate the callback if timeFromNow is < 0
         * This ususually occurs for a few milliseconds when the page
         * is not fully loaded
         *
         * The callback should only be called until maxIterations is reached
         */

        if (timeFromNow > 0 && self.iterations <= self.maxIterations) {
          self.callback(timeFromNow);
        }
      },
      'frequency': this._calcFreq()
    });
  };
  /**
   * Start the loop
   * @method  start
   * @for p5.SoundLoop
   * @param  {Number} [timeFromNow] schedule a starting time
   */


  p5.SoundLoop.prototype.start = function (timeFromNow) {
    var t = timeFromNow || 0;
    var now = p5sound.audiocontext.currentTime;

    if (!this.isPlaying) {
      this.clock.start(now + t);
      this.isPlaying = true;
    }
  };
  /**
   * Stop the loop
   * @method  stop
   * @for p5.SoundLoop
   * @param  {Number} [timeFromNow] schedule a stopping time
   */


  p5.SoundLoop.prototype.stop = function (timeFromNow) {
    var t = timeFromNow || 0;
    var now = p5sound.audiocontext.currentTime;

    if (this.isPlaying) {
      this.clock.stop(now + t);
      this.isPlaying = false;
    }
  };
  /**
   * Pause the loop
   * @method pause
   * @for p5.SoundLoop
   * @param  {Number} [timeFromNow] schedule a pausing time
   */


  p5.SoundLoop.prototype.pause = function (timeFromNow) {
    var t = timeFromNow || 0;
    var now = p5sound.audiocontext.currentTime;

    if (this.isPlaying) {
      this.clock.pause(now + t);
      this.isPlaying = false;
    }
  };
  /**
   * Synchronize loops. Use this method to start two more more loops in synchronization
   * or to start a loop in synchronization with a loop that is already playing
   * This method will schedule the implicit loop in sync with the explicit master loop
   * i.e. loopToStart.syncedStart(loopToSyncWith)
   *
   * @method  syncedStart
   * @for p5.SoundLoop
   * @param  {Object} otherLoop   a p5.SoundLoop to sync with
   * @param  {Number} [timeFromNow] Start the loops in sync after timeFromNow seconds
   */


  p5.SoundLoop.prototype.syncedStart = function (otherLoop, timeFromNow) {
    var t = timeFromNow || 0;
    var now = p5sound.audiocontext.currentTime;

    if (!otherLoop.isPlaying) {
      otherLoop.clock.start(now + t);
      otherLoop.isPlaying = true;
      this.clock.start(now + t);
      this.isPlaying = true;
    } else if (otherLoop.isPlaying) {
      var time = otherLoop.clock._nextTick - p5sound.audiocontext.currentTime;
      this.clock.start(now + time);
      this.isPlaying = true;
    }
  };
  /**
   * Updates frequency value, reflected in next callback
   * @private
   * @for p5.SoundLoop
   * @method  _update
   */


  p5.SoundLoop.prototype._update = function () {
    this.clock.frequency.value = this._calcFreq();
  };
  /**
   * Calculate the frequency of the clock's callback based on bpm, interval, and timesignature
   * @private
   * @for p5.SoundLoop
   * @method  _calcFreq
   * @return {Number} new clock frequency value
   */


  p5.SoundLoop.prototype._calcFreq = function () {
    if (typeof this._interval === 'number') {
      this.musicalTimeMode = false;
      return 1 / this._interval;
    } 
    else if (typeof this._interval === 'string') {
        this.musicalTimeMode = true;
        return this._bpm / 60 / this._convertNotation(this._interval) * (this._timeSignature / 4);
      }
  };
  /**
   * Convert notation from musical time format to seconds
   * Uses <a href = "https://github.com/Tonejs/Tone.js/wiki/Time">Tone.Time</a> convention
   * @private
   * @for p5.SoundLoop
   * @method _convertNotation
   * @param  {String} value value to be converted
   * @return {Number}       converted value in seconds
   */


  p5.SoundLoop.prototype._convertNotation = function (value) {
    var type = value.slice(-1);
    value = Number(value.slice(0, -1));

    switch (type) {
      case 'm':
        return this._measure(value);

      case 'n':
        return this._note(value);

      default:
        console.warn('Specified interval is not formatted correctly. See Tone.js ' + 'timing reference for more info: https://github.com/Tonejs/Tone.js/wiki/Time');
    }
  };
  /**
   * Helper conversion methods of measure and note
   * @private
   * @for p5.SoundLoop
   * @method  _measure
   */


  p5.SoundLoop.prototype._measure = function (value) {
    return value * this._timeSignature;
  };
  /**
   * @private
   * @method  _note
   * @for p5.SoundLoop
   */


  p5.SoundLoop.prototype._note = function (value) {
    return this._timeSignature / value;
  };
  /**
   * Getters and Setters, setting any paramter will result in a change in the clock's
   * frequency, that will be reflected after the next callback
   * beats per minute (defaults to 60)
   * @property {Number} bpm
   * @for p5.SoundLoop
   */


  Object.defineProperty(p5.SoundLoop.prototype, 'bpm', {
    get: function get() {
      return this._bpm;
    },
    set: function set(bpm) {
      if (!this.musicalTimeMode) {
        console.warn('Changing the BPM in "seconds" mode has no effect. ' + 'BPM is only relevant in musicalTimeMode ' + 'when the interval is specified as a string ' + '("2n", "4n", "1m"...etc)');
      }

      this._bpm = bpm;

      this._update();
    }
  });
  /**
   * number of quarter notes in a measure (defaults to 4)
   * @property {Number} timeSignature
   * @for p5.SoundLoop
   */

  Object.defineProperty(p5.SoundLoop.prototype, 'timeSignature', {
    get: function get() {
      return this._timeSignature;
    },
    set: function set(timeSig) {
      if (!this.musicalTimeMode) {
        console.warn('Changing the timeSignature in "seconds" mode has no effect. ' + 'BPM is only relevant in musicalTimeMode ' + 'when the interval is specified as a string ' + '("2n", "4n", "1m"...etc)');
      }

      this._timeSignature = timeSig;

      this._update();
    }
  });
  /**
   * length of the loops interval
   * @property {Number|String} interval
   * @for p5.SoundLoop
   */

  Object.defineProperty(p5.SoundLoop.prototype, 'interval', {
    get: function get() {
      return this._interval;
    },
    set: function set(interval) {
      this.musicalTimeMode = typeof interval === 'Number' ? false : true;
      this._interval = interval;

      this._update();
    }
  });
  /**
   * how many times the callback has been called so far
   * @property {Number} iterations
   * @for p5.SoundLoop
   * @readonly
   */

  Object.defineProperty(p5.SoundLoop.prototype, 'iterations', {
    get: function get() {
      return this.clock.ticks;
    }
  });
  return p5.SoundLoop;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  'use strict';

  var p5sound = __webpack_require__(1);

  var Effect = __webpack_require__(4);

  var CustomError = __webpack_require__(11);
  /**
   * Compressor is an audio effect class that performs dynamics compression
   * on an audio input source. This is a very commonly used technique in music
   * and sound production. Compression creates an overall louder, richer,
   * and fuller sound by lowering the volume of louds and raising that of softs.
   * Compression can be used to avoid clipping (sound distortion due to
   * peaks in volume) and is especially useful when many sounds are played
   * at once. Compression can be used on indivudal sound sources in addition
   * to the master output.
   *
   * This class extends <a href = "/reference/#/p5.Effect">p5.Effect</a>.
   * Methods <a href = "/reference/#/p5.Effect/amp">amp()</a>, <a href = "/reference/#/p5.Effect/chain">chain()</a>,
   * <a href = "/reference/#/p5.Effect/drywet">drywet()</a>, <a href = "/reference/#/p5.Effect/connect">connect()</a>, and
   * <a href = "/reference/#/p5.Effect/disconnect">disconnect()</a> are available.
   *
   * @class p5.Compressor
   * @constructor
   * @extends p5.Effect
   *
   *
   */


  p5.Compressor = function () {
    Effect.call(this);
    /**
     * The p5.Compressor is built with a <a href="https://www.w3.org/TR/webaudio/#the-dynamicscompressornode-interface"
    *   target="_blank" title="W3 spec for Dynamics Compressor Node">Web Audio Dynamics Compressor Node
    *   </a>
     * @property {AudioNode} compressor
     */

    this.compressor = this.ac.createDynamicsCompressor();
    this.input.connect(this.compressor);
    this.compressor.connect(this.wet);
  };

  p5.Compressor.prototype = Object.create(Effect.prototype);
  /**
   * Performs the same function as .connect, but also accepts
   * optional parameters to set compressor's audioParams
   * @method process
   * @for p5.Compressor
   *
   * @param {Object} src         Sound source to be connected
   *
   * @param {Number} [attack]     The amount of time (in seconds) to reduce the gain by 10dB,
   *                            default = .003, range 0 - 1
   * @param {Number} [knee]       A decibel value representing the range above the
   *                            threshold where the curve smoothly transitions to the "ratio" portion.
   *                            default = 30, range 0 - 40
   * @param {Number} [ratio]      The amount of dB change in input for a 1 dB change in output
   *                            default = 12, range 1 - 20
   * @param {Number} [threshold]  The decibel value above which the compression will start taking effect
   *                            default = -24, range -100 - 0
   * @param {Number} [release]    The amount of time (in seconds) to increase the gain by 10dB
   *                            default = .25, range 0 - 1
   */

  p5.Compressor.prototype.process = function (src, attack, knee, ratio, threshold, release) {
    src.connect(this.input);
    this.set(attack, knee, ratio, threshold, release);
  };
  /**
   * Set the paramters of a compressor.
   * @method  set
   * @for p5.Compressor
   * @param {Number} attack     The amount of time (in seconds) to reduce the gain by 10dB,
   *                            default = .003, range 0 - 1
   * @param {Number} knee       A decibel value representing the range above the
   *                            threshold where the curve smoothly transitions to the "ratio" portion.
   *                            default = 30, range 0 - 40
   * @param {Number} ratio      The amount of dB change in input for a 1 dB change in output
   *                            default = 12, range 1 - 20
   * @param {Number} threshold  The decibel value above which the compression will start taking effect
   *                            default = -24, range -100 - 0
   * @param {Number} release    The amount of time (in seconds) to increase the gain by 10dB
   *                            default = .25, range 0 - 1
   */


  p5.Compressor.prototype.set = function (attack, knee, ratio, threshold, release) {
    if (typeof attack !== 'undefined') {
      this.attack(attack);
    }

    if (typeof knee !== 'undefined') {
      this.knee(knee);
    }

    if (typeof ratio !== 'undefined') {
      this.ratio(ratio);
    }

    if (typeof threshold !== 'undefined') {
      this.threshold(threshold);
    }

    if (typeof release !== 'undefined') {
      this.release(release);
    }
  };
  /**
   * Get current attack or set value w/ time ramp
   *
   *
   * @method attack
   * @for p5.Compressor
   * @param {Number} [attack] Attack is the amount of time (in seconds) to reduce the gain by 10dB,
   *                          default = .003, range 0 - 1
   * @param {Number} [time]  Assign time value to schedule the change in value
   */


  p5.Compressor.prototype.attack = function (attack, time) {
    var t = time || 0;

    if (typeof attack == 'number') {
      this.compressor.attack.value = attack;
      this.compressor.attack.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.compressor.attack.linearRampToValueAtTime(attack, this.ac.currentTime + 0.02 + t);
    } else if (typeof attack !== 'undefined') {
      attack.connect(this.compressor.attack);
    }

    return this.compressor.attack.value;
  };
  /**
    * Get current knee or set value w/ time ramp
    *
    * @method knee
    * @for p5.Compressor
    * @param {Number} [knee] A decibel value representing the range above the
    *                        threshold where the curve smoothly transitions to the "ratio" portion.
    *                        default = 30, range 0 - 40
    * @param {Number} [time]  Assign time value to schedule the change in value
    */


  p5.Compressor.prototype.knee = function (knee, time) {
    var t = time || 0;

    if (typeof knee == 'number') {
      this.compressor.knee.value = knee;
      this.compressor.knee.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.compressor.knee.linearRampToValueAtTime(knee, this.ac.currentTime + 0.02 + t);
    } else if (typeof knee !== 'undefined') {
      knee.connect(this.compressor.knee);
    }

    return this.compressor.knee.value;
  };
  /**
   * Get current ratio or set value w/ time ramp
   * @method ratio
   * @for p5.Compressor
   * @param {Number} [ratio]      The amount of dB change in input for a 1 dB change in output
   *                            default = 12, range 1 - 20
   * @param {Number} [time]  Assign time value to schedule the change in value
   */


  p5.Compressor.prototype.ratio = function (ratio, time) {
    var t = time || 0;

    if (typeof ratio == 'number') {
      this.compressor.ratio.value = ratio;
      this.compressor.ratio.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.compressor.ratio.linearRampToValueAtTime(ratio, this.ac.currentTime + 0.02 + t);
    } else if (typeof ratio !== 'undefined') {
      ratio.connect(this.compressor.ratio);
    }

    return this.compressor.ratio.value;
  };
  /**
   * Get current threshold or set value w/ time ramp
   * @method threshold
   * @for p5.Compressor
   * @param {Number} threshold  The decibel value above which the compression will start taking effect
   *                            default = -24, range -100 - 0
   * @param {Number} [time]  Assign time value to schedule the change in value
   */


  p5.Compressor.prototype.threshold = function (threshold, time) {
    var t = time || 0;

    if (typeof threshold == 'number') {
      this.compressor.threshold.value = threshold;
      this.compressor.threshold.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.compressor.threshold.linearRampToValueAtTime(threshold, this.ac.currentTime + 0.02 + t);
    } else if (typeof threshold !== 'undefined') {
      threshold.connect(this.compressor.threshold);
    }

    return this.compressor.threshold.value;
  };
  /**
   * Get current release or set value w/ time ramp
   * @method release
   * @for p5.Compressor
   * @param {Number} release    The amount of time (in seconds) to increase the gain by 10dB
   *                            default = .25, range 0 - 1
   *
   * @param {Number} [time]  Assign time value to schedule the change in value
   */


  p5.Compressor.prototype.release = function (release, time) {
    var t = time || 0;

    if (typeof release == 'number') {
      this.compressor.release.value = release;
      this.compressor.release.cancelScheduledValues(this.ac.currentTime + 0.01 + t);
      this.compressor.release.linearRampToValueAtTime(release, this.ac.currentTime + 0.02 + t);
    } else if (typeof number !== 'undefined') {
      release.connect(this.compressor.release);
    }

    return this.compressor.release.value;
  };
  /**
   * Return the current reduction value
   *
   * @method reduction
   * @for p5.Compressor
   * @return {Number} Value of the amount of gain reduction that is applied to the signal
   */


  p5.Compressor.prototype.reduction = function () {
    return this.compressor.reduction.value;
  };

  p5.Compressor.prototype.dispose = function () {
    Effect.prototype.dispose.apply(this);

    if (this.compressor) {
      this.compressor.disconnect();
      delete this.compressor;
    }
  };

  return p5.Compressor;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);

  var _require = __webpack_require__(6),
      convertToWav = _require.convertToWav,
      safeBufferSize = _require.safeBufferSize;

  var processorNames = __webpack_require__(10);

  var ac = p5sound.audiocontext;
  /**
   *  <p>Record sounds for playback and/or to save as a .wav file.
   *  The p5.SoundRecorder records all sound output from your sketch,
   *  or can be assigned a specific source with setInput().</p>
   *  <p>The record() method accepts a p5.SoundFile as a parameter.
   *  When playback is stopped (either after the given amount of time,
   *  or with the stop() method), the p5.SoundRecorder will send its
   *  recording to that p5.SoundFile for playback.</p>
   *
   *  @class p5.SoundRecorder
   *  @constructor
   *  @example
   *  <div><code>
   *  let mic, recorder, soundFile;
   *  let state = 0;
   *
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(canvasPressed);
   *    background(220);
   *    textAlign(CENTER, CENTER);
   *
   *    // create an audio in
   *    mic = new p5.AudioIn();
   *
   *    // prompts user to enable their browser mic
   *    mic.start();
   *
   *    // create a sound recorder
   *    recorder = new p5.SoundRecorder();
   *
   *    // connect the mic to the recorder
   *    recorder.setInput(mic);
   *
   *    // this sound file will be used to
   *    // playback & save the recording
   *    soundFile = new p5.SoundFile();
   *
   *    text('tap to record', width/2, height/2);
   *  }
   *
   *  function canvasPressed() {
   *    // ensure audio is enabled
   *    userStartAudio();
   *
   *    // make sure user enabled the mic
   *    if (state === 0 && mic.enabled) {
   *
   *      // record to our p5.SoundFile
   *      recorder.record(soundFile);
   *
   *      background(255,0,0);
   *      text('Recording!', width/2, height/2);
   *      state++;
   *    }
   *    else if (state === 1) {
   *      background(0,255,0);
   *
   *      // stop recorder and
   *      // send result to soundFile
   *      recorder.stop();
   *
   *      text('Done! Tap to play and download', width/2, height/2, width - 20);
   *      state++;
   *    }
   *
   *    else if (state === 2) {
   *      soundFile.play(); // play the result!
   *      save(soundFile, 'mySound.wav');
   *      state++;
   *    }
   *  }
   *  </div></code>
   */

  p5.SoundRecorder = function () {
    this.input = ac.createGain();
    this.output = ac.createGain();
    this._inputChannels = 2;
    this._outputChannels = 2; 

    var workletBufferSize = safeBufferSize(1024);
    this._workletNode = new AudioWorkletNode(ac, processorNames.recorderProcessor, {
      outputChannelCount: [this._outputChannels],
      processorOptions: {
        numInputChannels: this._inputChannels,
        bufferSize: workletBufferSize
      }
    });

    this._workletNode.port.onmessage = function (event) {
      if (event.data.name === 'buffers') {
        var buffers = [new Float32Array(event.data.leftBuffer), new Float32Array(event.data.rightBuffer)];

        this._callback(buffers);
      }
    }.bind(this);
    /**
     *  callback invoked when the recording is over
     *  @private
     *  @type Function(Float32Array)
     */


    this._callback = function () {}; 


    this._workletNode.connect(p5.soundOut._silentNode);

    this.setInput(); 

    p5sound.soundArray.push(this);
  };
  /**
   *  Connect a specific device to the p5.SoundRecorder.
   *  If no parameter is given, p5.SoundRecorer will record
   *  all audible p5.sound from your sketch.
   *
   *  @method  setInput
   *  @for p5.SoundRecorder
   *  @param {Object} [unit] p5.sound object or a web audio unit
   *                         that outputs sound
   */


  p5.SoundRecorder.prototype.setInput = function (unit) {
    this.input.disconnect();
    this.input = null;
    this.input = ac.createGain();
    this.input.connect(this._workletNode);
    this.input.connect(this.output);

    if (unit) {
      unit.connect(this.input);
    } else {
      p5.soundOut.output.connect(this.input);
    }
  };
  /**
   *  Start recording. To access the recording, provide
   *  a p5.SoundFile as the first parameter. The p5.SoundRecorder
   *  will send its recording to that p5.SoundFile for playback once
   *  recording is complete. Optional parameters include duration
   *  (in seconds) of the recording, and a callback function that
   *  will be called once the complete recording has been
   *  transfered to the p5.SoundFile.
   *
   *  @method  record
   *  @for p5.SoundRecorder
   *  @param  {p5.SoundFile}   soundFile    p5.SoundFile
   *  @param  {Number}   [duration] Time (in seconds)
   *  @param  {Function} [callback] The name of a function that will be
   *                                called once the recording completes
   */


  p5.SoundRecorder.prototype.record = function (sFile, duration, callback) {
    this._workletNode.port.postMessage({
      name: 'start',
      duration: duration
    });

    if (sFile && callback) {
      this._callback = function (buffer) {
        sFile.setBuffer(buffer);
        callback();
      };
    } else if (sFile) {
      this._callback = function (buffer) {
        sFile.setBuffer(buffer);
      };
    }
  };
  /**
   *  Stop the recording. Once the recording is stopped,
   *  the results will be sent to the p5.SoundFile that
   *  was given on .record(), and if a callback function
   *  was provided on record, that function will be called.
   *
   *  @method  stop
   *  @for p5.SoundRecorder
   */


  p5.SoundRecorder.prototype.stop = function () {
    this._workletNode.port.postMessage({
      name: 'stop'
    });
  };

  p5.SoundRecorder.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);

    this._callback = function () {};

    if (this.input) {
      this.input.disconnect();
    }

    this.input = null;
    this._workletNode = null;
  };
  /**
   * Save a p5.SoundFile as a .wav file. The browser will prompt the user
   * to download the file to their device.
   * For uploading audio to a server, use
   * <a href="/docs/reference/#/p5.SoundFile/saveBlob">`p5.SoundFile.saveBlob`</a>.
   *
   *  @for p5
   *  @method saveSound
   *  @param  {p5.SoundFile} soundFile p5.SoundFile that you wish to save
   *  @param  {String} fileName      name of the resulting .wav file.
   */


  p5.prototype.saveSound = function (soundFile, fileName) {
    var dataView = convertToWav(soundFile.buffer);
    p5.prototype.writeFile([dataView], fileName, 'wav');
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  /**
   *  <p>PeakDetect works in conjunction with p5.FFT to
   *  look for onsets in some or all of the frequency spectrum.
   *  </p>
   *  <p>
   *  To use p5.PeakDetect, call <code>update</code> in the draw loop
   *  and pass in a p5.FFT object.
   *  </p>
   *  <p>
   *  You can listen for a specific part of the frequency spectrum by
   *  setting the range between <code>freq1</code> and <code>freq2</code>.
   *  </p>
   *
   *  <p><code>threshold</code> is the threshold for detecting a peak,
   *  scaled between 0 and 1. It is logarithmic, so 0.1 is half as loud
   *  as 1.0.</p>
   *
   *  <p>
   *  The update method is meant to be run in the draw loop, and
   *  <b>frames</b> determines how many loops must pass before
   *  another peak can be detected.
   *  For example, if the frameRate() = 60, you could detect the beat of a
   *  120 beat-per-minute song with this equation:
   *  <code> framesPerPeak = 60 / (estimatedBPM / 60 );</code>
   *  </p>
   *
   *  <p>
   *  Based on example contribtued by @b2renger, and a simple beat detection
   *  explanation by <a
   *  href="http://www.airtightinteractive.com/2013/10/making-audio-reactive-visuals/"
   *  target="_blank">Felix Turner</a>.
   *  </p>
   *
   *  @class  p5.PeakDetect
   *  @constructor
   *  @param {Number} [freq1]     lowFrequency - defaults to 20Hz
   *  @param {Number} [freq2]     highFrequency - defaults to 20000 Hz
   *  @param {Number} [threshold] Threshold for detecting a beat between 0 and 1
   *                            scaled logarithmically where 0.1 is 1/2 the loudness
   *                            of 1.0. Defaults to 0.35.
   *  @param {Number} [framesPerPeak]     Defaults to 20.
   *  @example
   *  <div><code>
   *
   *  var cnv, soundFile, fft, peakDetect;
   *  var ellipseWidth = 10;
   *
   *  function preload() {
   *    soundFile = loadSound('assets/beat.mp3');
   *  }
   *
   *  function setup() {
   *    background(0);
   *    noStroke();
   *    fill(255);
   *    textAlign(CENTER);
   *
   *    // p5.PeakDetect requires a p5.FFT
   *    fft = new p5.FFT();
   *    peakDetect = new p5.PeakDetect();
   *  }
   *
   *  function draw() {
   *    background(0);
   *    text('click to play/pause', width/2, height/2);
   *
   *    // peakDetect accepts an fft post-analysis
   *    fft.analyze();
   *    peakDetect.update(fft);
   *
   *    if ( peakDetect.isDetected ) {
   *      ellipseWidth = 50;
   *    } else {
   *      ellipseWidth *= 0.95;
   *    }
   *
   *    ellipse(width/2, height/2, ellipseWidth, ellipseWidth);
   *  }
   *
   *  // toggle play/stop when canvas is clicked
   *  function mouseClicked() {
   *    if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
   *      if (soundFile.isPlaying() ) {
   *        soundFile.stop();
   *      } else {
   *        soundFile.play();
   *      }
   *    }
   *  }
   *  </code></div>
   */
  p5.PeakDetect = function (freq1, freq2, threshold, _framesPerPeak) {
    this.framesPerPeak = _framesPerPeak || 20;
    this.framesSinceLastPeak = 0;
    this.decayRate = 0.95;
    this.threshold = threshold || 0.35;
    this.cutoff = 0; 

    this.cutoffMult = 1.5;
    this.energy = 0;
    this.penergy = 0; 

    this.currentValue = 0;
    /**
     *  isDetected is set to true when a peak is detected.
     *
     *  @attribute isDetected {Boolean}
     *  @default  false
     */

    this.isDetected = false;
    this.f1 = freq1 || 40;
    this.f2 = freq2 || 20000; 

    this._onPeak = function () {};
  };
  /**
   *  The update method is run in the draw loop.
   *
   *  Accepts an FFT object. You must call .analyze()
   *  on the FFT object prior to updating the peakDetect
   *  because it relies on a completed FFT analysis.
   *
   *  @method  update
   *  @param  {p5.FFT} fftObject A p5.FFT object
   */


  p5.PeakDetect.prototype.update = function (fftObject) {
    var nrg = this.energy = fftObject.getEnergy(this.f1, this.f2) / 255;

    if (nrg > this.cutoff && nrg > this.threshold && nrg - this.penergy > 0) {
      this._onPeak();

      this.isDetected = true; 

      this.cutoff = nrg * this.cutoffMult;
      this.framesSinceLastPeak = 0;
    } else {
      this.isDetected = false;

      if (this.framesSinceLastPeak <= this.framesPerPeak) {
        this.framesSinceLastPeak++;
      } else {
        this.cutoff *= this.decayRate;
        this.cutoff = Math.max(this.cutoff, this.threshold);
      }
    }

    this.currentValue = nrg;
    this.penergy = nrg;
  };
  /**
   *  onPeak accepts two arguments: a function to call when
   *  a peak is detected. The value of the peak,
   *  between 0.0 and 1.0, is passed to the callback.
   *
   *  @method  onPeak
   *  @param  {Function} callback Name of a function that will
   *                              be called when a peak is
   *                              detected.
   *  @param  {Object}   [val]    Optional value to pass
   *                              into the function when
   *                              a peak is detected.
   *  @example
   *  <div><code>
   *  var cnv, soundFile, fft, peakDetect;
   *  var ellipseWidth = 0;
   *
   *  function preload() {
   *    soundFile = loadSound('assets/beat.mp3');
   *  }
   *
   *  function setup() {
   *    cnv = createCanvas(100,100);
   *    textAlign(CENTER);
   *
   *    fft = new p5.FFT();
   *    peakDetect = new p5.PeakDetect();
   *
   *    setupSound();
   *
   *    // when a beat is detected, call triggerBeat()
   *    peakDetect.onPeak(triggerBeat);
   *  }
   *
   *  function draw() {
   *    background(0);
   *    fill(255);
   *    text('click to play', width/2, height/2);
   *
   *    fft.analyze();
   *    peakDetect.update(fft);
   *
   *    ellipseWidth *= 0.95;
   *    ellipse(width/2, height/2, ellipseWidth, ellipseWidth);
   *  }
   *
   *  // this function is called by peakDetect.onPeak
   *  function triggerBeat() {
   *    ellipseWidth = 50;
   *  }
   *
   *  // mouseclick starts/stops sound
   *  function setupSound() {
   *    cnv.mouseClicked( function() {
   *      if (soundFile.isPlaying() ) {
   *        soundFile.stop();
   *      } else {
   *        soundFile.play();
   *      }
   *    });
   *  }
   *  </code></div>
   */


  p5.PeakDetect.prototype.onPeak = function (callback, val) {
    var self = this;

    self._onPeak = function () {
      callback(self.energy, val);
    };
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var p5sound = __webpack_require__(1);
  /**
   *  A gain node is usefull to set the relative volume of sound.
   *  It's typically used to build mixers.
   *
   *  @class p5.Gain
   *  @constructor
   *  @example
   *  <div><code>
   *
   *  // load two soundfile and crossfade beetween them
   *  let sound1,sound2;
   *  let sound1Gain, sound2Gain, masterGain;
   *  function preload(){
   *    soundFormats('ogg', 'mp3');
   *    sound1 = loadSound('assets/Damscray_-_Dancing_Tiger_01');
   *    sound2 = loadSound('assets/beat');
   *  }
   *  function setup() {
   *    let cnv = createCanvas(100, 100);
   *    cnv.mousePressed(startSound);
   *    // create a 'master' gain to which we will connect both soundfiles
   *    masterGain = new p5.Gain();
   *    masterGain.connect();
   *    sound1.disconnect(); // diconnect from p5 output
   *    sound1Gain = new p5.Gain(); // setup a gain node
   *    sound1Gain.setInput(sound1); // connect the first sound to its input
   *    sound1Gain.connect(masterGain); // connect its output to the 'master'
   *    sound2.disconnect();
   *    sound2Gain = new p5.Gain();
   *    sound2Gain.setInput(sound2);
   *    sound2Gain.connect(masterGain);
   *  }
   *  function startSound() {
   *    sound1.loop();
   *    sound2.loop();
   *    loop();
   *  }
   *  function mouseReleased() {
   *    sound1.stop();
   *    sound2.stop();
   *  }
   *  function draw(){
   *    background(220);
   *    textAlign(CENTER);
   *    textSize(11);
   *    fill(0);
   *    if (!sound1.isPlaying()) {
   *      text('tap and drag to play', width/2, height/2);
   *      return;
   *    }
   *    // map the horizontal position of the mouse to values useable for volume    *  control of sound1
   *    var sound1Volume = constrain(map(mouseX,width,0,0,1), 0, 1);
   *    var sound2Volume = 1-sound1Volume;
   *    sound1Gain.amp(sound1Volume);
   *    sound2Gain.amp(sound2Volume);
   *    // map the vertical position of the mouse to values useable for 'master    *  volume control'
   *    var masterVolume = constrain(map(mouseY,height,0,0,1), 0, 1);
   *    masterGain.amp(masterVolume);
   *    text('master', width/2, height - masterVolume * height * 0.9)
   *    fill(255, 0, 255);
   *    textAlign(LEFT);
   *    text('sound1', 5, height - sound1Volume * height * 0.9);
   *    textAlign(RIGHT);
   *    text('sound2', width - 5, height - sound2Volume * height * 0.9);
   *  }
   *</code></div>
   */


  p5.Gain = function () {
    this.ac = p5sound.audiocontext;
    this.input = this.ac.createGain();
    this.output = this.ac.createGain(); 

    this.input.gain.value = 0.5;
    this.input.connect(this.output); 

    p5sound.soundArray.push(this);
  };
  /**
   *  Connect a source to the gain node.
   *
   *  @method  setInput
   *  @for p5.Gain
   *  @param  {Object} src     p5.sound / Web Audio object with a sound
   *                           output.
   */


  p5.Gain.prototype.setInput = function (src) {
    src.connect(this.input);
  };
  /**
   *  Send output to a p5.sound or web audio object
   *
   *  @method  connect
   *  @for p5.Gain
   *  @param  {Object} unit
   */


  p5.Gain.prototype.connect = function (unit) {
    var u = unit || p5.soundOut.input;
    this.output.connect(u.input ? u.input : u);
  };
  /**
   *  Disconnect all output.
   *
   *  @method disconnect
   *  @for p5.Gain
   */


  p5.Gain.prototype.disconnect = function () {
    if (this.output) {
      this.output.disconnect();
    }
  };
  /**
   *  Set the output level of the gain node.
   *
   *  @method  amp
   *  @for p5.Gain
   *  @param  {Number} volume amplitude between 0 and 1.0
   *  @param  {Number} [rampTime] create a fade that lasts rampTime
   *  @param  {Number} [timeFromNow] schedule this event to happen
   *                                seconds from now
   */


  p5.Gain.prototype.amp = function (vol, rampTime, tFromNow) {
    var rampTime = rampTime || 0;
    var tFromNow = tFromNow || 0;
    var now = p5sound.audiocontext.currentTime;
    var currentVol = this.output.gain.value;
    this.output.gain.cancelScheduledValues(now);
    this.output.gain.linearRampToValueAtTime(currentVol, now + tFromNow);
    this.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime);
  };

  p5.Gain.prototype.dispose = function () {
    var index = p5sound.soundArray.indexOf(this);
    p5sound.soundArray.splice(index, 1);

    if (this.output) {
      this.output.disconnect();
      delete this.output;
    }

    if (this.input) {
      this.input.disconnect();
      delete this.input;
    }
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
  var Effect = __webpack_require__(4);


  function makeDistortionCurve(amount) {
    var k = typeof amount === 'number' ? amount : 50;
    var numSamples = 44100;
    var curve = new Float32Array(numSamples);
    var deg = Math.PI / 180;
    var i = 0;
    var x;

    for (; i < numSamples; ++i) {
      x = i * 2 / numSamples - 1;
      curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }

    return curve;
  }
  /**
   * A Distortion effect created with a Waveshaper Node,
   * with an approach adapted from
   * [Kevin Ennis](http://stackoverflow.com/questions/22312841/waveshaper-node-in-webaudio-how-to-emulate-distortion)
   *
   * This class extends <a href = "/reference/#/p5.Effect">p5.Effect</a>.
   * Methods <a href = "/reference/#/p5.Effect/amp">amp()</a>, <a href = "/reference/#/p5.Effect/chain">chain()</a>,
   * <a href = "/reference/#/p5.Effect/drywet">drywet()</a>, <a href = "/reference/#/p5.Effect/connect">connect()</a>, and
   * <a href = "/reference/#/p5.Effect/disconnect">disconnect()</a> are available.
   *
   * @class p5.Distortion
   * @extends p5.Effect
   * @constructor
   * @param {Number} [amount=0.25] Unbounded distortion amount.
   *                                Normal values range from 0-1.
   * @param {String} [oversample='none'] 'none', '2x', or '4x'.
   *
   */


  p5.Distortion = function (amount, oversample) {
    Effect.call(this);

    if (typeof amount === 'undefined') {
      amount = 0.25;
    }

    if (typeof amount !== 'number') {
      throw new Error('amount must be a number');
    }

    if (typeof oversample === 'undefined') {
      oversample = '2x';
    }

    if (typeof oversample !== 'string') {
      throw new Error('oversample must be a String');
    }

    var curveAmount = p5.prototype.map(amount, 0.0, 1.0, 0, 2000);
    /**
     *  The p5.Distortion is built with a
     *  <a href="http://www.w3.org/TR/webaudio/#WaveShaperNode">
     *  Web Audio WaveShaper Node</a>.
     *
     *  @property {AudioNode} WaveShaperNode
     */

    this.waveShaperNode = this.ac.createWaveShaper();
    this.amount = curveAmount;
    this.waveShaperNode.curve = makeDistortionCurve(curveAmount);
    this.waveShaperNode.oversample = oversample;
    this.input.connect(this.waveShaperNode);
    this.waveShaperNode.connect(this.wet);
  };

  p5.Distortion.prototype = Object.create(Effect.prototype);
  /**
   * Process a sound source, optionally specify amount and oversample values.
   *
   * @method process
   * @for p5.Distortion
   * @param {Number} [amount=0.25] Unbounded distortion amount.
   *                                Normal values range from 0-1.
   * @param {String} [oversample='none'] 'none', '2x', or '4x'.
   */

  p5.Distortion.prototype.process = function (src, amount, oversample) {
    src.connect(this.input);
    this.set(amount, oversample);
  };
  /**
   * Set the amount and oversample of the waveshaper distortion.
   *
   * @method set
   * @for p5.Distortion
   * @param {Number} [amount=0.25] Unbounded distortion amount.
   *                                Normal values range from 0-1.
   * @param {String} [oversample='none'] 'none', '2x', or '4x'.
   */


  p5.Distortion.prototype.set = function (amount, oversample) {
    if (amount) {
      var curveAmount = p5.prototype.map(amount, 0.0, 1.0, 0, 2000);
      this.amount = curveAmount;
      this.waveShaperNode.curve = makeDistortionCurve(curveAmount);
    }

    if (oversample) {
      this.waveShaperNode.oversample = oversample;
    }
  };
  /**
   *  Return the distortion amount, typically between 0-1.
   *
   *  @method  getAmount
   *  @for p5.Distortion
   *  @return {Number} Unbounded distortion amount.
   *                   Normal values range from 0-1.
   */


  p5.Distortion.prototype.getAmount = function () {
    return this.amount;
  };
  /**
   *  Return the oversampling.
   *
   *  @method getOversample
   *  @for p5.Distortion
   *  @return {String} Oversample can either be 'none', '2x', or '4x'.
   */


  p5.Distortion.prototype.getOversample = function () {
    return this.waveShaperNode.oversample;
  };

  p5.Distortion.prototype.dispose = function () {
    Effect.prototype.dispose.apply(this);

    if (this.waveShaperNode) {
      this.waveShaperNode.disconnect();
      this.waveShaperNode = null;
    }
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

 })
 ]);


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p5 */ "p5");
/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var p5_lib_addons_p5_sound__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p5/lib/addons/p5.sound */ "./node_modules/p5/lib/addons/p5.sound.js");
/* harmony import */ var p5_lib_addons_p5_sound__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(p5_lib_addons_p5_sound__WEBPACK_IMPORTED_MODULE_1__);


const sketch = (p) => {
    let fft;
    let mic;
    p.setup = () => {
        let canvas = p.createCanvas(710, 1024);
        p.noFill();
        mic = new p5__WEBPACK_IMPORTED_MODULE_0__["AudioIn"]();
        mic.start();
        fft = new p5__WEBPACK_IMPORTED_MODULE_0__["FFT"]();
        fft.setInput(mic);
    };
    p.draw = () => {
        p.background(200);
        let spectrum = fft.analyze();
        p.beginShape();
        for (let i = 0; i < spectrum.length; i++) {
            p.vertex(p.map(spectrum[i], 0, 255, 0, p.width), i);
        }
        p.endShape();
    };
};
new p5__WEBPACK_IMPORTED_MODULE_0__(sketch);


/***/ }),

/***/ "p5":
/*!*********************!*\
  !*** external "p5" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = p5;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3A1L2xpYi9hZGRvbnMvcDUuc291bmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy9leHRlcm5hbCBcInA1XCIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixjQUFjLE9BQU87QUFDckI7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEs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QUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSzs7O0FBR0E7QUFDQSxJOzs7QUFHQTtBQUNBLG1DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0I7O0FBRUE7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSzs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0I7O0FBRUE7QUFDQSwyQjs7QUFFQTtBQUNBO0FBQ0EsNkI7O0FBRUEsZ0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCOztBQUVBO0FBQ0E7QUFDQSx1Qjs7QUFFQSwwQjs7QUFFQSw0Qjs7QUFFQTtBQUNBLCtEOztBQUVBO0FBQ0E7QUFDQSxLOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSTs7O0FBR0EsZ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FB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QSx5Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esb0I7QUFDQSxJOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQkFBcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEk7OztBQUdBO0FBQ0E7QUFDQSx5Qjs7QUFFQTtBQUNBLDZFOztBQUVBLGtDOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFk7OztBQUdMO0FBQ0EsaUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQjs7QUFFQSx1RDs7QUFFQSw2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBO0FBQ0E7QUFDQSxPO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQjs7O0FBR0Esc0M7O0FBRUEsMkI7O0FBRUEsa0M7O0FBRUEsK0I7O0FBRUEsOEI7O0FBRUEsOEI7O0FBRUE7QUFDQSxJOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxtRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw0Qjs7QUFFQTtBQUNBO0FBQ0EsNEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDhCO0FBQ0EsSTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsNEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOzs7QUFHQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQSxJOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSzs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEs7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEs7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEs7OztBQUdBLHdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPOzs7QUFHQSwyQzs7QUFFQTtBQUNBO0FBQ0EsSztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxNQUFNO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE1BQU07QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDLGlCQUFpQixXQUFXO0FBQzVCLGlCQUFpQixXQUFXO0FBQzVCLGlCQUFpQixPQUFPO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBLEk7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixRQUFRO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE1BQU07QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLDhCOzs7QUFHQSxnQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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RUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQSx3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esb0M7OztBQUdBOztBQUVBLG9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQjs7QUFFQTtBQUNBO0FBQ0EscUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Qjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHVDOztBQUVBO0FBQ0Esb0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLEVBQUU7QUFDRjs7Ozs7Ozs7Ozs7OztBQ3pqWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF5QjtBQUNPO0FBRWhDLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBSyxFQUFFLEVBQUU7SUFDdkIsSUFBSSxHQUFXLENBQUM7SUFDaEIsSUFBSSxHQUFlLENBQUM7SUFFcEIsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEVBQUU7UUFDYixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN2QyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFWCxHQUFHLEdBQUcsSUFBSSwwQ0FBVSxFQUFFLENBQUM7UUFDdkIsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBRVosR0FBRyxHQUFHLElBQUksc0NBQU0sRUFBRSxDQUFDO1FBQ25CLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEIsQ0FBQyxDQUFDO0lBRUYsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEVBQUU7UUFDWixDQUFDLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLElBQUksUUFBUSxHQUFHLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM3QixDQUFDLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDZixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNyRDtRQUNELENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNmLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLElBQUksK0JBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0FDOUJmLG9CIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c1wiKTtcbiIsIi8qKiBbcDUuc291bmRdICBWZXJzaW9uOiAwLjMuMTIgLSAyMDIwLTAxLTA2ICovIFxuIC8qKlxuICogIDxwPnA1LnNvdW5kIGV4dGVuZHMgcDUgd2l0aCA8YSBocmVmPVwiaHR0cDovL2Nhbml1c2UuY29tL2F1ZGlvLWFwaVwiXG4gKiAgdGFyZ2V0PVwiX2JsYW5rXCI+V2ViIEF1ZGlvPC9hPiBmdW5jdGlvbmFsaXR5IGluY2x1ZGluZyBhdWRpbyBpbnB1dCxcbiAqICBwbGF5YmFjaywgYW5hbHlzaXMgYW5kIHN5bnRoZXNpcy5cbiAqICA8L3A+XG4gKiAgPHVsPlxuICogIDxsaT48YSBocmVmPVwiIy9wNS5Tb3VuZEZpbGVcIj48Yj5wNS5Tb3VuZEZpbGU8L2I+PC9hPjogTG9hZCBhbmQgcGxheSBzb3VuZCBmaWxlcy48L2xpPlxuICogIDxsaT48YSBocmVmPVwiIy9wNS5BbXBsaXR1ZGVcIj48Yj5wNS5BbXBsaXR1ZGU8L2I+PC9hPjogR2V0IHRoZSBjdXJyZW50IHZvbHVtZSBvZiBhIHNvdW5kLjwvbGk+XG4gKiAgPGxpPjxhIGhyZWY9XCIjL3A1LkF1ZGlvSW5cIj48Yj5wNS5BdWRpb0luPC9iPjwvYT46IEdldCBzb3VuZCBmcm9tIGFuIGlucHV0IHNvdXJjZSwgdHlwaWNhbGx5XG4gKiAgICBhIGNvbXB1dGVyIG1pY3JvcGhvbmUuPC9saT5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUuRkZUXCI+PGI+cDUuRkZUPC9iPjwvYT46IEFuYWx5emUgdGhlIGZyZXF1ZW5jeSBvZiBzb3VuZC4gUmV0dXJuc1xuICogICAgcmVzdWx0cyBmcm9tIHRoZSBmcmVxdWVuY3kgc3BlY3RydW0gb3IgdGltZSBkb21haW4gKHdhdmVmb3JtKS48L2xpPlxuICogIDxsaT48YSBocmVmPVwiIy9wNS5Pc2NpbGxhdG9yXCI+PGI+cDUuT3NjaWxsYXRvcjwvYj48L2E+OiBHZW5lcmF0ZSBTaW5lLFxuICogICAgVHJpYW5nbGUsIFNxdWFyZSBhbmQgU2F3dG9vdGggd2F2ZWZvcm1zLiBCYXNlIGNsYXNzIG9mXG4gKiAgICA8bGk+PGEgaHJlZj1cIiMvcDUuTm9pc2VcIj5wNS5Ob2lzZTwvYT4gYW5kIDxhIGhyZWY9XCIjL3A1LlB1bHNlXCI+cDUuUHVsc2U8L2E+LlxuICogICAgPC9saT5cbiAqICA8bGk+XG4gKiAgICA8YSBocmVmPVwiIy9wNS5Nb25vU3ludGhcIj5wNS5Nb25vU3ludGg8L2E+IGFuZCA8YSBocmVmPVwiIy9wNS5Qb2x5U3ludGhcIj5wNS5Qb2x5U3ludGg8L2E+OiBQbGF5IG11c2ljYWwgbm90ZXNcbiAqICA8L2xpPlxuICogIDxsaT48YSBocmVmPVwiIy9wNS5FbnZlbG9wZVwiPjxiPnA1LkVudmVsb3BlPC9iPjwvYT46IEFuIEVudmVsb3BlIGlzIGEgc2VyaWVzXG4gKiAgICBvZiBmYWRlcyBvdmVyIHRpbWUuIE9mdGVuIHVzZWQgdG8gY29udHJvbCBhbiBvYmplY3Qnc1xuICogICAgb3V0cHV0IGdhaW4gbGV2ZWwgYXMgYW4gXCJBRFNSIEVudmVsb3BlXCIgKEF0dGFjaywgRGVjYXksXG4gKiAgICBTdXN0YWluLCBSZWxlYXNlKS4gQ2FuIGFsc28gbW9kdWxhdGUgb3RoZXIgcGFyYW1ldGVycy48L2xpPlxuICogIDxsaT48YSBocmVmPVwiIy9wNS5EZWxheVwiPjxiPnA1LkRlbGF5PC9iPjwvYT46IEEgZGVsYXkgZWZmZWN0IHdpdGhcbiAqICAgIHBhcmFtZXRlcnMgZm9yIGZlZWRiYWNrLCBkZWxheVRpbWUsIGFuZCBsb3dwYXNzIGZpbHRlci48L2xpPlxuICogIDxsaT48YSBocmVmPVwiIy9wNS5GaWx0ZXJcIj48Yj5wNS5GaWx0ZXI8L2I+PC9hPjogRmlsdGVyIHRoZSBmcmVxdWVuY3kgcmFuZ2Ugb2YgYVxuICogICAgc291bmQuXG4gKiAgPC9saT5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUuUmV2ZXJiXCI+PGI+cDUuUmV2ZXJiPC9iPjwvYT46IEFkZCByZXZlcmIgdG8gYSBzb3VuZCBieSBzcGVjaWZ5aW5nXG4gKiAgICBkdXJhdGlvbiBhbmQgZGVjYXkuIDwvbGk+XG4gKiAgPGI+PGxpPjxhIGhyZWY9XCIjL3A1LkNvbnZvbHZlclwiPnA1LkNvbnZvbHZlcjwvYT46PC9iPiBFeHRlbmRzXG4gKiAgPGEgaHJlZj1cIiMvcDUuUmV2ZXJiXCI+cDUuUmV2ZXJiPC9hPiB0byBzaW11bGF0ZSB0aGUgc291bmQgb2YgcmVhbFxuICogICAgcGh5c2ljYWwgc3BhY2VzIHRocm91Z2ggY29udm9sdXRpb24uPC9saT5cbiAqICA8Yj48bGk+PGEgaHJlZj1cIiMvcDUuU291bmRSZWNvcmRlclwiPnA1LlNvdW5kUmVjb3JkZXI8L2E+PC9iPjogUmVjb3JkIHNvdW5kIGZvciBwbGF5YmFja1xuICogICAgLyBzYXZlIHRoZSAud2F2IGZpbGUuXG4gKiAgPGI+PGxpPjxhIGhyZWY9XCIjL3A1LlNvdW5kTG9vcFwiPnA1LlNvdW5kTG9vcDwvYT4sIDxhIGhyZWY9XCIjL3A1LlBocmFzZVwiPnA1LlBocmFzZTwvYT48L2I+LCA8Yj48YSBocmVmPVwiIy9wNS5QYXJ0XCI+cDUuUGFydDwvYT48L2I+IGFuZFxuICogIDxiPjxhIGhyZWY9XCIjL3A1LlNjb3JlXCI+cDUuU2NvcmU8L2E+PC9iPjogQ29tcG9zZSBtdXNpY2FsIHNlcXVlbmNlcy5cbiAqICA8L2xpPlxuICogIDxsaT48YSBocmVmPVwiIy9wNS91c2VyU3RhcnRBdWRpb1wiPnVzZXJTdGFydEF1ZGlvPC9hPjogRW5hYmxlIGF1ZGlvIGluIGFcbiAqICBicm93c2VyLSBhbmQgdXNlci1mcmllbmRseSB3YXkuPC9hPlxuICogIDxwPnA1LnNvdW5kIGlzIG9uIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vdGhlcmV3YXNhZ3V5L3A1LnNvdW5kL1wiPkdpdEh1YjwvYT4uXG4gKiAgRG93bmxvYWQgdGhlIGxhdGVzdCB2ZXJzaW9uXG4gKiAgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS90aGVyZXdhc2FndXkvcDUuc291bmQvYmxvYi9tYXN0ZXIvbGliL3A1LnNvdW5kLmpzXCI+aGVyZTwvYT4uPC9wPlxuICpcbiAqICBAbW9kdWxlIHA1LnNvdW5kXG4gKiAgQHN1Ym1vZHVsZSBwNS5zb3VuZFxuICogIEBmb3IgcDUuc291bmRcbiAqICBAbWFpblxuICovXG5cbi8qKlxuICogIHA1LnNvdW5kIFxuICogIGh0dHBzOi8vcDVqcy5vcmcvcmVmZXJlbmNlLyMvbGlicmFyaWVzL3A1LnNvdW5kXG4gKlxuICogIEZyb20gdGhlIFByb2Nlc3NpbmcgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL3Byb2Nlc3NpbmcvcDUuanMtc291bmQvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICpcbiAqICBNSVQgTGljZW5zZSAoTUlUKVxuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9jZXNzaW5nL3A1LmpzLXNvdW5kL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiAgU29tZSBvZiB0aGUgbWFueSBhdWRpbyBsaWJyYXJpZXMgJiByZXNvdXJjZXMgdGhhdCBpbnNwaXJlIHA1LnNvdW5kOlxuICogICAtIFRPTkUuanMgKGMpIFlvdGFtIE1hbm4uIExpY2Vuc2VkIHVuZGVyIFRoZSBNSVQgTGljZW5zZSAoTUlUKS4gaHR0cHM6Ly9naXRodWIuY29tL1RPTkVub1RPTkUvVG9uZS5qc1xuICogICAtIGJ1enouanMgKGMpIEpheSBTYWx2YXQuIExpY2Vuc2VkIHVuZGVyIFRoZSBNSVQgTGljZW5zZSAoTUlUKS4gaHR0cDovL2J1enouamF5c2FsdmF0LmNvbS9cbiAqICAgLSBCb3JpcyBTbXVzIFdlYiBBdWRpbyBBUEkgYm9vaywgMjAxMy4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICogICAtIHdhdmVzdXJmZXIuanMgaHR0cHM6Ly9naXRodWIuY29tL2thdHNwYXVnaC93YXZlc3VyZmVyLmpzXG4gKiAgIC0gV2ViIEF1ZGlvIENvbXBvbmVudHMgYnkgSm9yZGFuIFNhbnRlbGwgaHR0cHM6Ly9naXRodWIuY29tL3dlYi1hdWRpby1jb21wb25lbnRzXG4gKiAgIC0gV2lsbSBUaG9iZW4ncyBTb3VuZCBsaWJyYXJ5IGZvciBQcm9jZXNzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9jZXNzaW5nL3Byb2Nlc3NpbmcvdHJlZS9tYXN0ZXIvamF2YS9saWJyYXJpZXMvc291bmRcbiAqXG4gKiAgIFdlYiBBdWRpbyBBUEk6IGh0dHA6Ly93My5vcmcvVFIvd2ViYXVkaW8vXG4gKi9cblxuIChmdW5jdGlvbihtb2R1bGVzKSB7IFxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzEpO1xuIH0pXG4gKFtcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYSh0LGUpe3RoaXMuaXNVbmRlZih0KXx8MT09PXQ/dGhpcy5pbnB1dD10aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpOjE8dCYmKHRoaXMuaW5wdXQ9bmV3IEFycmF5KHQpKSx0aGlzLmlzVW5kZWYoZSl8fDE9PT1lP3RoaXMub3V0cHV0PXRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk6MTxlJiYodGhpcy5vdXRwdXQ9bmV3IEFycmF5KHQpKX12YXIgZTtyZXR1cm4gYS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmlzT2JqZWN0KHQpKW49ZTtlbHNlIGlmKHRoaXMuaXNTdHJpbmcodCkpe3ZhciBvPXt9O29bdF09ZSx0PW99dDpmb3IodmFyIGkgaW4gdCl7ZT10W2ldO3ZhciByPXRoaXM7aWYoLTEhPT1pLmluZGV4T2YoXCIuXCIpKXtmb3IodmFyIHM9aS5zcGxpdChcIi5cIiksdT0wO3U8cy5sZW5ndGgtMTt1KyspaWYoKHI9cltzW3VdXSlpbnN0YW5jZW9mIGEpe3Muc3BsaWNlKDAsdSsxKTt2YXIgcD1zLmpvaW4oXCIuXCIpO3Iuc2V0KHAsZSk7Y29udGludWUgdH1pPXNbcy5sZW5ndGgtMV19dmFyIGM9cltpXTt0aGlzLmlzVW5kZWYoYyl8fChhLlNpZ25hbCYmYyBpbnN0YW5jZW9mIGEuU2lnbmFsfHxhLlBhcmFtJiZjIGluc3RhbmNlb2YgYS5QYXJhbT9jLnZhbHVlIT09ZSYmKHRoaXMuaXNVbmRlZihuKT9jLnZhbHVlPWU6Yy5yYW1wVG8oZSxuKSk6YyBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0/Yy52YWx1ZSE9PWUmJihjLnZhbHVlPWUpOmMgaW5zdGFuY2VvZiBhP2Muc2V0KGUpOmMhPT1lJiYocltpXT1lKSl9cmV0dXJuIHRoaXN9LGEucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXt0aGlzLmlzVW5kZWYodCk/dD10aGlzLl9jb2xsZWN0RGVmYXVsdHModGhpcy5jb25zdHJ1Y3Rvcik6dGhpcy5pc1N0cmluZyh0KSYmKHQ9W3RdKTtmb3IodmFyIGU9e30sbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dLGk9dGhpcyxyPWU7aWYoLTEhPT1vLmluZGV4T2YoXCIuXCIpKXtmb3IodmFyIHM9by5zcGxpdChcIi5cIiksdT0wO3U8cy5sZW5ndGgtMTt1Kyspe3ZhciBwPXNbdV07cltwXT1yW3BdfHx7fSxyPXJbcF0saT1pW3BdfW89c1tzLmxlbmd0aC0xXX12YXIgYz1pW29dO3RoaXMuaXNPYmplY3QodFtvXSk/cltvXT1jLmdldCgpOmEuU2lnbmFsJiZjIGluc3RhbmNlb2YgYS5TaWduYWw/cltvXT1jLnZhbHVlOmEuUGFyYW0mJmMgaW5zdGFuY2VvZiBhLlBhcmFtP3Jbb109Yy52YWx1ZTpjIGluc3RhbmNlb2YgQXVkaW9QYXJhbT9yW29dPWMudmFsdWU6YyBpbnN0YW5jZW9mIGE/cltvXT1jLmdldCgpOnRoaXMuaXNGdW5jdGlvbihjKXx8dGhpcy5pc1VuZGVmKGMpfHwocltvXT1jKX1yZXR1cm4gZX0sYS5wcm90b3R5cGUuX2NvbGxlY3REZWZhdWx0cz1mdW5jdGlvbih0KXt2YXIgZT1bXTtpZih0aGlzLmlzVW5kZWYodC5kZWZhdWx0cyl8fChlPU9iamVjdC5rZXlzKHQuZGVmYXVsdHMpKSwhdGhpcy5pc1VuZGVmKHQuX3N1cGVyKSlmb3IodmFyIG49dGhpcy5fY29sbGVjdERlZmF1bHRzKHQuX3N1cGVyKSxvPTA7bzxuLmxlbmd0aDtvKyspLTE9PT1lLmluZGV4T2YobltvXSkmJmUucHVzaChuW29dKTtyZXR1cm4gZX0sYS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gYSl7dmFyIGU9dFswXS5tYXRjaCgvXltBLVpdJC8pLG49YVt0XT09PXRoaXMuY29uc3RydWN0b3I7aWYodGhpcy5pc0Z1bmN0aW9uKGFbdF0pJiZlJiZuKXJldHVybiB0fXJldHVyblwiVG9uZVwifSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJudW1iZXJPZklucHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnB1dD90aGlzLmlzQXJyYXkodGhpcy5pbnB1dCk/dGhpcy5pbnB1dC5sZW5ndGg6MTowfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLnByb3RvdHlwZSxcIm51bWJlck9mT3V0cHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vdXRwdXQ/dGhpcy5pc0FycmF5KHRoaXMub3V0cHV0KT90aGlzLm91dHB1dC5sZW5ndGg6MTowfX0pLGEucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1VuZGVmKHRoaXMuaW5wdXQpfHwodGhpcy5pbnB1dCBpbnN0YW5jZW9mIEF1ZGlvTm9kZSYmdGhpcy5pbnB1dC5kaXNjb25uZWN0KCksdGhpcy5pbnB1dD1udWxsKSx0aGlzLmlzVW5kZWYodGhpcy5vdXRwdXQpfHwodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBBdWRpb05vZGUmJnRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKSx0aGlzLm91dHB1dD1udWxsKSx0aGlzfSxhLnByb3RvdHlwZS5jb25uZWN0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLm91dHB1dCk/KGU9dGhpcy5kZWZhdWx0QXJnKGUsMCksdGhpcy5vdXRwdXRbZV0uY29ubmVjdCh0LDAsbikpOnRoaXMub3V0cHV0LmNvbm5lY3QodCxlLG4pLHRoaXN9LGEucHJvdG90eXBlLmRpc2Nvbm5lY3Q9ZnVuY3Rpb24odCxlLG4pe3RoaXMuaXNBcnJheSh0aGlzLm91dHB1dCk/dGhpcy5pc051bWJlcih0KT90aGlzLm91dHB1dFt0XS5kaXNjb25uZWN0KCk6KGU9dGhpcy5kZWZhdWx0QXJnKGUsMCksdGhpcy5vdXRwdXRbZV0uZGlzY29ubmVjdCh0LDAsbikpOnRoaXMub3V0cHV0LmRpc2Nvbm5lY3QuYXBwbHkodGhpcy5vdXRwdXQsYXJndW1lbnRzKX0sYS5wcm90b3R5cGUuY29ubmVjdFNlcmllcz1mdW5jdGlvbigpe2lmKDE8YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgbj1hcmd1bWVudHNbZV07dC5jb25uZWN0KG4pLHQ9bn1yZXR1cm4gdGhpc30sYS5wcm90b3R5cGUuY2hhaW49ZnVuY3Rpb24oKXtpZigwPGFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMsZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBuPWFyZ3VtZW50c1tlXTt0LmNvbm5lY3QobiksdD1ufXJldHVybiB0aGlzfSxhLnByb3RvdHlwZS5mYW49ZnVuY3Rpb24oKXtpZigwPGFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl0aGlzLmNvbm5lY3QoYXJndW1lbnRzW3RdKTtyZXR1cm4gdGhpc30sQXVkaW9Ob2RlLnByb3RvdHlwZS5jaGFpbj1hLnByb3RvdHlwZS5jaGFpbixBdWRpb05vZGUucHJvdG90eXBlLmZhbj1hLnByb3RvdHlwZS5mYW4sYS5wcm90b3R5cGUuZGVmYXVsdEFyZz1mdW5jdGlvbih0LGUpe2lmKHRoaXMuaXNPYmplY3QodCkmJnRoaXMuaXNPYmplY3QoZSkpe3ZhciBuPXt9O2Zvcih2YXIgbyBpbiB0KW5bb109dGhpcy5kZWZhdWx0QXJnKGVbb10sdFtvXSk7Zm9yKHZhciBpIGluIGUpbltpXT10aGlzLmRlZmF1bHRBcmcodFtpXSxlW2ldKTtyZXR1cm4gbn1yZXR1cm4gdGhpcy5pc1VuZGVmKHQpP2U6dH0sYS5wcm90b3R5cGUub3B0aW9uc09iamVjdD1mdW5jdGlvbih0LGUsbil7dmFyIG89e307aWYoMT09PXQubGVuZ3RoJiZ0aGlzLmlzT2JqZWN0KHRbMF0pKW89dFswXTtlbHNlIGZvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKW9bZVtpXV09dFtpXTtyZXR1cm4gdGhpcy5pc1VuZGVmKG4pP286dGhpcy5kZWZhdWx0QXJnKG8sbil9LGEucHJvdG90eXBlLmlzVW5kZWY9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR9LGEucHJvdG90eXBlLmlzRnVuY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH0sYS5wcm90b3R5cGUuaXNOdW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHR9LGEucHJvdG90eXBlLmlzT2JqZWN0PWZ1bmN0aW9uKHQpe3JldHVyblwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkmJnQuY29uc3RydWN0b3I9PT1PYmplY3R9LGEucHJvdG90eXBlLmlzQm9vbGVhbj1mdW5jdGlvbih0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHR9LGEucHJvdG90eXBlLmlzQXJyYXk9ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCl9LGEucHJvdG90eXBlLmlzU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fSxhLm5vT3A9ZnVuY3Rpb24oKXt9LGEucHJvdG90eXBlLl9yZWFkT25seT1mdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKWZvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMuX3JlYWRPbmx5KHRbZV0pO2Vsc2UgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsdCx7d3JpdGFibGU6ITEsZW51bWVyYWJsZTohMH0pfSxhLnByb3RvdHlwZS5fd3JpdGFibGU9ZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLl93cml0YWJsZSh0W2VdKTtlbHNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHQse3dyaXRhYmxlOiEwfSl9LGEuU3RhdGU9e1N0YXJ0ZWQ6XCJzdGFydGVkXCIsU3RvcHBlZDpcInN0b3BwZWRcIixQYXVzZWQ6XCJwYXVzZWRcIn0sYS5wcm90b3R5cGUuZXF1YWxQb3dlclNjYWxlPWZ1bmN0aW9uKHQpe3ZhciBlPS41Kk1hdGguUEk7cmV0dXJuIE1hdGguc2luKHQqZSl9LGEucHJvdG90eXBlLmRiVG9HYWluPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLHQvNil9LGEucHJvdG90eXBlLmdhaW5Ub0RiPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmxvZyh0KS9NYXRoLkxOMTAqMjB9LGEucHJvdG90eXBlLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbz1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMix0LzEyKX0sYS5wcm90b3R5cGUubm93PWZ1bmN0aW9uKCl7cmV0dXJuIGEuY29udGV4dC5ub3coKX0sYS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jb250ZXh0Lm5vdygpfSxhLmV4dGVuZD1mdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt9YS5wcm90b3R5cGUuaXNVbmRlZihlKSYmKGU9YSksbi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsdC5wcm90b3R5cGU9bmV3IG4sKHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQpLl9zdXBlcj1lfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImNvbnRleHRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9LHNldDpmdW5jdGlvbih0KXtlPWEuQ29udGV4dCYmdCBpbnN0YW5jZW9mIGEuQ29udGV4dD90Om5ldyBhLkNvbnRleHQodCksYS5Db250ZXh0JiZhLkNvbnRleHQuZW1pdChcImluaXRcIixlKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJjb250ZXh0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBhLmNvbnRleHR9fSksYS5zZXRDb250ZXh0PWZ1bmN0aW9uKHQpe2EuY29udGV4dD10fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJibG9ja1RpbWVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDEyOC90aGlzLmNvbnRleHQuc2FtcGxlUmF0ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJzYW1wbGVUaW1lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiAxL3RoaXMuY29udGV4dC5zYW1wbGVSYXRlfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwic3VwcG9ydGVkXCIse2dldDpmdW5jdGlvbigpe3ZhciB0PXdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIkF1ZGlvQ29udGV4dFwiKXx8d2luZG93Lmhhc093blByb3BlcnR5KFwid2Via2l0QXVkaW9Db250ZXh0XCIpLGU9d2luZG93Lmhhc093blByb3BlcnR5KFwiUHJvbWlzZVwiKSxuPXdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIldvcmtlclwiKTtyZXR1cm4gdCYmZSYmbn19KSxhLnZlcnNpb249XCJyMTBcIix3aW5kb3cuVE9ORV9TSUxFTkNFX1ZFUlNJT05fTE9HR0lOR3x8Y29uc29sZS5sb2coXCIlYyAqIFRvbmUuanMgXCIrYS52ZXJzaW9uK1wiICogXCIsXCJiYWNrZ3JvdW5kOiAjMDAwOyBjb2xvcjogI2ZmZlwiKSxhfSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygxNyldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAoYXVkaW9jb250ZXh0KSB7XG4gIHZhciBNYXN0ZXIgPSBmdW5jdGlvbiBNYXN0ZXIoKSB7XG4gICAgdGhpcy5pbnB1dCA9IGF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5vdXRwdXQgPSBhdWRpb2NvbnRleHQuY3JlYXRlR2FpbigpOyBcblxuICAgIHRoaXMubGltaXRlciA9IGF1ZGlvY29udGV4dC5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcbiAgICB0aGlzLmxpbWl0ZXIudGhyZXNob2xkLnZhbHVlID0gLTM7XG4gICAgdGhpcy5saW1pdGVyLnJhdGlvLnZhbHVlID0gMjA7XG4gICAgdGhpcy5saW1pdGVyLmtuZWUudmFsdWUgPSAxO1xuICAgIHRoaXMuYXVkaW9jb250ZXh0ID0gYXVkaW9jb250ZXh0O1xuICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTsgXG5cbiAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5saW1pdGVyKTsgXG5cbiAgICB0aGlzLmxpbWl0ZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7IFxuXG4gICAgdGhpcy5tZXRlciA9IGF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5mZnRNZXRlciA9IGF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh0aGlzLm1ldGVyKTtcbiAgICB0aGlzLm91dHB1dC5jb25uZWN0KHRoaXMuZmZ0TWV0ZXIpOyBcblxuICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodGhpcy5hdWRpb2NvbnRleHQuZGVzdGluYXRpb24pOyBcblxuICAgIHRoaXMuc291bmRBcnJheSA9IFtdOyBcblxuICAgIHRoaXMucGFydHMgPSBbXTsgXG5cbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBbXTtcbiAgfTsgXG5cblxuICB2YXIgcDVzb3VuZCA9IG5ldyBNYXN0ZXIoKTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBtYXN0ZXIgYW1wbGl0dWRlICh2b2x1bWUpIGZvciBzb3VuZFxuICAgKiBpbiB0aGlzIHNrZXRjaC5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRNYXN0ZXJWb2x1bWVcbiAgICogQHJldHVybiB7TnVtYmVyfSBNYXN0ZXIgYW1wbGl0dWRlICh2b2x1bWUpIGZvciBzb3VuZCBpbiB0aGlzIHNrZXRjaC5cbiAgICogICAgICAgICAgICAgICAgICBTaG91bGQgYmUgYmV0d2VlbiAwLjAgKHNpbGVuY2UpIGFuZCAxLjAuXG4gICAqL1xuXG4gIHA1LnByb3RvdHlwZS5nZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHA1c291bmQub3V0cHV0LmdhaW4udmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiAgPHA+U2NhbGUgdGhlIG91dHB1dCBvZiBhbGwgc291bmQgaW4gdGhpcyBza2V0Y2g8L3A+XG4gICAqICBTY2FsZWQgYmV0d2VlbiAwLjAgKHNpbGVuY2UpIGFuZCAxLjAgKGZ1bGwgdm9sdW1lKS5cbiAgICogIDEuMCBpcyB0aGUgbWF4aW11bSBhbXBsaXR1ZGUgb2YgYSBkaWdpdGFsIHNvdW5kLCBzbyBtdWx0aXBseWluZ1xuICAgKiAgYnkgZ3JlYXRlciB0aGFuIDEuMCBtYXkgY2F1c2UgZGlnaXRhbCBkaXN0b3J0aW9uLiBUb1xuICAgKiAgZmFkZSwgcHJvdmlkZSBhIDxjb2RlPnJhbXBUaW1lPC9jb2RlPiBwYXJhbWV0ZXIuIEZvciBtb3JlXG4gICAqICBjb21wbGV4IGZhZGVzLCBzZWUgdGhlIEVudmVsb3BlIGNsYXNzLlxuICAgKlxuICAgKiAgQWx0ZXJuYXRlbHksIHlvdSBjYW4gcGFzcyBpbiBhIHNpZ25hbCBzb3VyY2Ugc3VjaCBhcyBhblxuICAgKiAgb3NjaWxsYXRvciB0byBtb2R1bGF0ZSB0aGUgYW1wbGl0dWRlIHdpdGggYW4gYXVkaW8gc2lnbmFsLlxuICAgKlxuICAgKiAgPHA+PGI+SG93IFRoaXMgV29ya3M8L2I+OiBXaGVuIHlvdSBsb2FkIHRoZSBwNS5zb3VuZCBtb2R1bGUsIGl0XG4gICAqICBjcmVhdGVzIGEgc2luZ2xlIGluc3RhbmNlIG9mIHA1c291bmQuIEFsbCBzb3VuZCBvYmplY3RzIGluIHRoaXNcbiAgICogIG1vZHVsZSBvdXRwdXQgdG8gcDVzb3VuZCBiZWZvcmUgcmVhY2hpbmcgeW91ciBjb21wdXRlcidzIG91dHB1dC5cbiAgICogIFNvIGlmIHlvdSBjaGFuZ2UgdGhlIGFtcGxpdHVkZSBvZiBwNXNvdW5kLCBpdCBpbXBhY3RzIGFsbCBvZiB0aGVcbiAgICogIHNvdW5kIGluIHRoaXMgbW9kdWxlLjwvcD5cbiAgICpcbiAgICogIDxwPklmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLCByZXR1cm5zIGEgV2ViIEF1ZGlvIEFQSSBHYWluIE5vZGU8L3A+XG4gICAqXG4gICAqICBAbWV0aG9kICBtYXN0ZXJWb2x1bWVcbiAgICogIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gdm9sdW1lICBWb2x1bWUgKGFtcGxpdHVkZSkgYmV0d2VlbiAwLjBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIDEuMCBvciBtb2R1bGF0aW5nIHNpZ25hbC9vc2NpbGxhdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3JhbXBUaW1lXSAgRmFkZSBmb3IgdCBzZWNvbmRzXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3RpbWVGcm9tTm93XSAgU2NoZWR1bGUgdGhpcyBldmVudCB0byBoYXBwZW4gYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0IHNlY29uZHMgaW4gdGhlIGZ1dHVyZVxuICAgKi9cblxuXG4gIHA1LnByb3RvdHlwZS5tYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbiAodm9sLCByYW1wVGltZSwgdEZyb21Ob3cpIHtcbiAgICBpZiAodHlwZW9mIHZvbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciByYW1wVGltZSA9IHJhbXBUaW1lIHx8IDA7XG4gICAgICB2YXIgdEZyb21Ob3cgPSB0RnJvbU5vdyB8fCAwO1xuICAgICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdmFyIGN1cnJlbnRWb2wgPSBwNXNvdW5kLm91dHB1dC5nYWluLnZhbHVlO1xuICAgICAgcDVzb3VuZC5vdXRwdXQuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMobm93ICsgdEZyb21Ob3cpO1xuICAgICAgcDVzb3VuZC5vdXRwdXQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShjdXJyZW50Vm9sLCBub3cgKyB0RnJvbU5vdyk7XG4gICAgICBwNXNvdW5kLm91dHB1dC5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZvbCwgbm93ICsgdEZyb21Ob3cgKyByYW1wVGltZSk7XG4gICAgfSBlbHNlIGlmICh2b2wpIHtcbiAgICAgIHZvbC5jb25uZWN0KHA1c291bmQub3V0cHV0LmdhaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcDVzb3VuZC5vdXRwdXQuZ2FpbjtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgYHA1LnNvdW5kT3V0YCBpcyB0aGUgcDUuc291bmQgbWFzdGVyIG91dHB1dC4gSXQgc2VuZHMgb3V0cHV0IHRvXG4gICAqICB0aGUgZGVzdGluYXRpb24gb2YgdGhpcyB3aW5kb3cncyB3ZWIgYXVkaW8gY29udGV4dC4gSXQgY29udGFpbnNcbiAgICogIFdlYiBBdWRpbyBBUEkgbm9kZXMgaW5jbHVkaW5nIGEgZHlhbm1pY3NDb21wcmVzc29yICg8Y29kZT4ubGltaXRlcjwvY29kZT4pLFxuICAgKiAgYW5kIEdhaW4gTm9kZXMgZm9yIDxjb2RlPi5pbnB1dDwvY29kZT4gYW5kIDxjb2RlPi5vdXRwdXQ8L2NvZGU+LlxuICAgKlxuICAgKiAgQHByb3BlcnR5IHtPYmplY3R9IHNvdW5kT3V0XG4gICAqL1xuXG5cbiAgcDUucHJvdG90eXBlLnNvdW5kT3V0ID0gcDUuc291bmRPdXQgPSBwNXNvdW5kOyBcblxuICBwNS5zb3VuZE91dC5fc2lsZW50Tm9kZSA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgcDUuc291bmRPdXQuX3NpbGVudE5vZGUuZ2Fpbi52YWx1ZSA9IDA7XG5cbiAgcDUuc291bmRPdXQuX3NpbGVudE5vZGUuY29ubmVjdChwNXNvdW5kLmF1ZGlvY29udGV4dC5kZXN0aW5hdGlvbik7XG5cbiAgcmV0dXJuIHA1c291bmQ7XG59KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXyg1KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLF9fd2VicGFja19yZXF1aXJlX18oMjIpLF9fd2VicGFja19yZXF1aXJlX18oOSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihuKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gbi5TaWduYWw9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLFtcInZhbHVlXCIsXCJ1bml0c1wiXSxuLlNpZ25hbC5kZWZhdWx0cyk7dGhpcy5vdXRwdXQ9dGhpcy5fZ2Fpbj10aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpLHQucGFyYW09dGhpcy5fZ2Fpbi5nYWluLG4uUGFyYW0uY2FsbCh0aGlzLHQpLHRoaXMuaW5wdXQ9dGhpcy5fcGFyYW09dGhpcy5fZ2Fpbi5nYWluLHRoaXMuY29udGV4dC5nZXRDb25zdGFudCgxKS5jaGFpbih0aGlzLl9nYWluKX0sbi5leHRlbmQobi5TaWduYWwsbi5QYXJhbSksbi5TaWduYWwuZGVmYXVsdHM9e3ZhbHVlOjAsdW5pdHM6bi5UeXBlLkRlZmF1bHQsY29udmVydDohMH0sbi5TaWduYWwucHJvdG90eXBlLmNvbm5lY3Q9bi5TaWduYWxCYXNlLnByb3RvdHlwZS5jb25uZWN0LG4uU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIG4uUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9wYXJhbT1udWxsLHRoaXMuX2dhaW4uZGlzY29ubmVjdCgpLHRoaXMuX2dhaW49bnVsbCx0aGlzfSxuLlNpZ25hbH0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLF9fd2VicGFja19yZXF1aXJlX18oOSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihpKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gaS5NdWx0aXBseT1mdW5jdGlvbih0KXt0aGlzLmNyZWF0ZUluc091dHMoMiwwKSx0aGlzLl9tdWx0PXRoaXMuaW5wdXRbMF09dGhpcy5vdXRwdXQ9bmV3IGkuR2Fpbix0aGlzLl9wYXJhbT10aGlzLmlucHV0WzFdPXRoaXMub3V0cHV0LmdhaW4sdGhpcy5fcGFyYW0udmFsdWU9dGhpcy5kZWZhdWx0QXJnKHQsMCl9LGkuZXh0ZW5kKGkuTXVsdGlwbHksaS5TaWduYWwpLGkuTXVsdGlwbHkucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gaS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX211bHQuZGlzcG9zZSgpLHRoaXMuX211bHQ9bnVsbCx0aGlzLl9wYXJhbT1udWxsLHRoaXN9LGkuTXVsdGlwbHl9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIENyb3NzRmFkZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xuICAvKipcbiAgICogRWZmZWN0IGlzIGEgYmFzZSBjbGFzcyBmb3IgYXVkaW8gZWZmZWN0cyBpbiBwNS4gPGJyPlxuICAgKiBUaGlzIG1vZHVsZSBoYW5kbGVzIHRoZSBub2RlcyBhbmQgbWV0aG9kcyB0aGF0IGFyZVxuICAgKiBjb21tb24gYW5kIHVzZWZ1bCBmb3IgY3VycmVudCBhbmQgZnV0dXJlIGVmZmVjdHMuXG4gICAqXG4gICAqXG4gICAqIFRoaXMgY2xhc3MgaXMgZXh0ZW5kZWQgYnkgPGEgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5EaXN0b3J0aW9uXCI+cDUuRGlzdG9ydGlvbjwvYT4sXG4gICAqIDxhIGhyZWY9XCIvcmVmZXJlbmNlLyMvcDUuQ29tcHJlc3NvclwiPnA1LkNvbXByZXNzb3I8L2E+LFxuICAgKiA8YSBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LkRlbGF5XCI+cDUuRGVsYXk8L2E+LFxuICAgKiA8YSBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LkZpbHRlclwiPnA1LkZpbHRlcjwvYT4sXG4gICAqIDxhIGhyZWY9XCIvcmVmZXJlbmNlLyMvcDUuUmV2ZXJiXCI+cDUuUmV2ZXJiPC9hPi5cbiAgICpcbiAgICogQGNsYXNzICBwNS5FZmZlY3RcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYWNdICAgUmVmZXJlbmNlIHRvIHRoZSBhdWRpbyBjb250ZXh0IG9mIHRoZSBwNSBvYmplY3RcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IFtpbnB1dF0gIEdhaW4gTm9kZSBlZmZlY3Qgd3JhcHBlclxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZX0gW291dHB1dF0gR2FpbiBOb2RlIGVmZmVjdCB3cmFwcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbX2RyeXdldF0gICBUb25lLkpTIENyb3NzRmFkZSBub2RlIChkZWZhdWx0cyB0byB2YWx1ZTogMSlcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IFt3ZXRdICBFZmZlY3RzIHRoYXQgZXh0ZW5kIHRoaXMgY2xhc3Mgc2hvdWxkIGNvbm5lY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgd2V0IHNpZ25hbCB0byB0aGlzIGdhaW4gbm9kZSwgc28gdGhhdCBkcnkgYW5kIHdldFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbHMgYXJlIG1peGVkIHByb3Blcmx5LlxuICAgKi9cblxuXG4gIHA1LkVmZmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFjID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7XG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuYWMuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy5hYy5jcmVhdGVHYWluKCk7XG4gICAgLyoqXG4gICAgICpcdFRoZSBwNS5FZmZlY3QgY2xhc3MgaXMgYnVpbHRcbiAgICAgKiBcdHVzaW5nIFRvbmUuanMgQ3Jvc3NGYWRlXG4gICAgICogXHRAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fZHJ5d2V0ID0gbmV3IENyb3NzRmFkZSgxKTtcbiAgICAvKipcbiAgICAgKlx0SW4gY2xhc3NlcyB0aGF0IGV4dGVuZFxuICAgICAqXHRwNS5FZmZlY3QsIGNvbm5lY3QgZWZmZWN0IG5vZGVzXG4gICAgICpcdHRvIHRoZSB3ZXQgcGFyYW1ldGVyXG4gICAgICovXG5cbiAgICB0aGlzLndldCA9IHRoaXMuYWMuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9kcnl3ZXQuYSk7XG4gICAgdGhpcy53ZXQuY29ubmVjdCh0aGlzLl9kcnl3ZXQuYik7XG5cbiAgICB0aGlzLl9kcnl3ZXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cbiAgICB0aGlzLmNvbm5lY3QoKTsgXG5cbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIG91dHB1dCB2b2x1bWUgb2YgdGhlIGZpbHRlci5cbiAgICpcbiAgICogIEBtZXRob2QgIGFtcFxuICAgKiAgQGZvciBwNS5FZmZlY3RcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdm9sXSBhbXBsaXR1ZGUgYmV0d2VlbiAwIGFuZCAxLjBcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbcmFtcFRpbWVdIGNyZWF0ZSBhIGZhZGUgdGhhdCBsYXN0cyB1bnRpbCByYW1wVGltZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt0RnJvbU5vd10gc2NoZWR1bGUgdGhpcyBldmVudCB0byBoYXBwZW4gaW4gdEZyb21Ob3cgc2Vjb25kc1xuICAgKi9cblxuXG4gIHA1LkVmZmVjdC5wcm90b3R5cGUuYW1wID0gZnVuY3Rpb24gKHZvbCwgcmFtcFRpbWUsIHRGcm9tTm93KSB7XG4gICAgdmFyIHJhbXBUaW1lID0gcmFtcFRpbWUgfHwgMDtcbiAgICB2YXIgdEZyb21Ob3cgPSB0RnJvbU5vdyB8fCAwO1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgY3VycmVudFZvbCA9IHRoaXMub3V0cHV0LmdhaW4udmFsdWU7XG4gICAgdGhpcy5vdXRwdXQuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMobm93KTtcbiAgICB0aGlzLm91dHB1dC5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGN1cnJlbnRWb2wsIG5vdyArIHRGcm9tTm93ICsgLjAwMSk7XG4gICAgdGhpcy5vdXRwdXQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2b2wsIG5vdyArIHRGcm9tTm93ICsgcmFtcFRpbWUgKyAuMDAxKTtcbiAgfTtcbiAgLyoqXG4gICAqICBMaW5rIGVmZmVjdHMgdG9nZXRoZXIgaW4gYSBjaGFpblxuICAgKiAgRXhhbXBsZSB1c2FnZTogZmlsdGVyLmNoYWluKHJldmVyYiwgZGVsYXksIHBhbm5lcik7XG4gICAqICBNYXkgYmUgdXNlZCB3aXRoIGFuIG9wZW4tZW5kZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgKlxuICAgKiAgQG1ldGhvZCBjaGFpblxuICAgKiAgQGZvciBwNS5FZmZlY3RcbiAgICogIEBwYXJhbSB7T2JqZWN0fSBbYXJndW1lbnRzXSAgQ2hhaW4gdG9nZXRoZXIgbXVsdGlwbGUgc291bmQgb2JqZWN0c1xuICAgKi9cblxuXG4gIHA1LkVmZmVjdC5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbm5lY3QoYXJndW1lbnRzWzBdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJndW1lbnRzW2kgLSAxXS5jb25uZWN0KGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiAgQWRqdXN0IHRoZSBkcnkvd2V0IHZhbHVlLlxuICAgKlxuICAgKiAgQG1ldGhvZCBkcnl3ZXRcbiAgICogIEBmb3IgcDUuRWZmZWN0XG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZhZGVdIFRoZSBkZXNpcmVkIGRyeXdldCB2YWx1ZSAoMCAtIDEuMClcbiAgICovXG5cblxuICBwNS5FZmZlY3QucHJvdG90eXBlLmRyeXdldCA9IGZ1bmN0aW9uIChmYWRlKSB7XG4gICAgaWYgKHR5cGVvZiBmYWRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLl9kcnl3ZXQuZmFkZS52YWx1ZSA9IGZhZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2RyeXdldC5mYWRlLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogIFNlbmQgb3V0cHV0IHRvIGEgcDUuanMtc291bmQsIFdlYiBBdWRpbyBOb2RlLCBvciB1c2Ugc2lnbmFsIHRvXG4gICAqICBjb250cm9sIGFuIEF1ZGlvUGFyYW1cbiAgICpcbiAgICogIEBtZXRob2QgY29ubmVjdFxuICAgKiAgQGZvciBwNS5FZmZlY3RcbiAgICogIEBwYXJhbSB7T2JqZWN0fSB1bml0XG4gICAqL1xuXG5cbiAgcDUuRWZmZWN0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB2YXIgdSA9IHVuaXQgfHwgcDUuc291bmRPdXQuaW5wdXQ7XG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh1LmlucHV0ID8gdS5pbnB1dCA6IHUpO1xuICB9O1xuICAvKipcbiAgICogRGlzY29ubmVjdCBhbGwgb3V0cHV0LlxuICAgKiBAbWV0aG9kIGRpc2Nvbm5lY3RcbiAgICogQGZvciBwNS5FZmZlY3RcbiAgICovXG5cblxuICBwNS5FZmZlY3QucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIHA1LkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSBwNXNvdW5kLnNvdW5kQXJyYXkuaW5kZXhPZih0aGlzKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGlmICh0aGlzLmlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmlucHV0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMub3V0cHV0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kcnl3ZXQpIHtcbiAgICAgIHRoaXMuX2RyeXdldC5kaXNjb25uZWN0KCk7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9kcnl3ZXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2V0KSB7XG4gICAgICB0aGlzLndldC5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy53ZXQ7XG4gICAgfVxuXG4gICAgdGhpcy5hYyA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gcDUuRWZmZWN0O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO3JldHVybiBlLldhdmVTaGFwZXI9ZnVuY3Rpb24oZSx0KXt0aGlzLl9zaGFwZXI9dGhpcy5pbnB1dD10aGlzLm91dHB1dD10aGlzLmNvbnRleHQuY3JlYXRlV2F2ZVNoYXBlcigpLHRoaXMuX2N1cnZlPW51bGwsQXJyYXkuaXNBcnJheShlKT90aGlzLmN1cnZlPWU6aXNGaW5pdGUoZSl8fHRoaXMuaXNVbmRlZihlKT90aGlzLl9jdXJ2ZT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuZGVmYXVsdEFyZyhlLDEwMjQpKTp0aGlzLmlzRnVuY3Rpb24oZSkmJih0aGlzLl9jdXJ2ZT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuZGVmYXVsdEFyZyh0LDEwMjQpKSx0aGlzLnNldE1hcChlKSl9LGUuZXh0ZW5kKGUuV2F2ZVNoYXBlcixlLlNpZ25hbEJhc2UpLGUuV2F2ZVNoYXBlci5wcm90b3R5cGUuc2V0TWFwPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLHI9dGhpcy5fY3VydmUubGVuZ3RoO3Q8cjt0Kyspe3ZhciBzPXQvKHItMSkqMi0xO3RoaXMuX2N1cnZlW3RdPWUocyx0KX1yZXR1cm4gdGhpcy5fc2hhcGVyLmN1cnZlPXRoaXMuX2N1cnZlLHRoaXN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLldhdmVTaGFwZXIucHJvdG90eXBlLFwiY3VydmVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NoYXBlci5jdXJ2ZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2N1cnZlPW5ldyBGbG9hdDMyQXJyYXkoZSksdGhpcy5fc2hhcGVyLmN1cnZlPXRoaXMuX2N1cnZlfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLldhdmVTaGFwZXIucHJvdG90eXBlLFwib3ZlcnNhbXBsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGV9LHNldDpmdW5jdGlvbihlKXtpZigtMT09PVtcIm5vbmVcIixcIjJ4XCIsXCI0eFwiXS5pbmRleE9mKGUpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9uZS5XYXZlU2hhcGVyOiBvdmVyc2FtcGxpbmcgbXVzdCBiZSBlaXRoZXIgJ25vbmUnLCAnMngnLCBvciAnNHgnXCIpO3RoaXMuX3NoYXBlci5vdmVyc2FtcGxlPWV9fSksZS5XYXZlU2hhcGVyLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9zaGFwZXIuZGlzY29ubmVjdCgpLHRoaXMuX3NoYXBlcj1udWxsLHRoaXMuX2N1cnZlPW51bGwsdGhpc30sZS5XYXZlU2hhcGVyfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBwcm9jZXNzb3JOYW1lcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuICAvKipcbiAgICogQGZvciBwNVxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHNhbXBsZSByYXRlLCBpbiBzYW1wbGVzIHBlciBzZWNvbmQsXG4gICAqIG9mIGFsbCBzb3VuZCBvYmplY3RzIGluIHRoaXMgYXVkaW8gY29udGV4dC4gSXQgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICogc2FtcGxpbmcgcmF0ZSBvZiB5b3VyIG9wZXJhdGluZyBzeXN0ZW0ncyBzb3VuZCBjYXJkLCBhbmQgaXQgaXMgbm90XG4gICAqIGN1cnJlbnRseSBwb3NzaWxlIHRvIGNoYW5nZS5cbiAgICogSXQgaXMgb2Z0ZW4gNDQxMDAsIG9yIHR3aWNlIHRoZSByYW5nZSBvZiBodW1hbiBoZWFyaW5nLlxuICAgKlxuICAgKiBAbWV0aG9kIHNhbXBsZVJhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBzYW1wbGVyYXRlIHNhbXBsZXMgcGVyIHNlY29uZFxuICAgKi9cblxuXG4gIHA1LnByb3RvdHlwZS5zYW1wbGVSYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlO1xuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgdGhlIGNsb3Nlc3QgTUlESSBub3RlIHZhbHVlIGZvclxuICAgKiAgYSBnaXZlbiBmcmVxdWVuY3kuXG4gICAqXG4gICAqICBAbWV0aG9kIGZyZXFUb01pZGlcbiAgICogIEBwYXJhbSAge051bWJlcn0gZnJlcXVlbmN5IEEgZnJlcWV1bmN5LCBmb3IgZXhhbXBsZSwgdGhlIFwiQVwiXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm92ZSBNaWRkbGUgQyBpcyA0NDBIelxuICAgKiAgQHJldHVybiB7TnVtYmVyfSAgIE1JREkgbm90ZSB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LnByb3RvdHlwZS5mcmVxVG9NaWRpID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgbWF0aGxvZzIgPSBNYXRoLmxvZyhmIC8gNDQwKSAvIE1hdGgubG9nKDIpO1xuICAgIHZhciBtID0gTWF0aC5yb3VuZCgxMiAqIG1hdGhsb2cyKSArIDY5O1xuICAgIHJldHVybiBtO1xuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgdGhlIGZyZXF1ZW5jeSB2YWx1ZSBvZiBhIE1JREkgbm90ZSB2YWx1ZS5cbiAgICogIEdlbmVyYWwgTUlESSB0cmVhdHMgbm90ZXMgYXMgaW50ZWdlcnMgd2hlcmUgbWlkZGxlIENcbiAgICogIGlzIDYwLCBDIyBpcyA2MSwgRCBpcyA2MiBldGMuIFVzZWZ1bCBmb3IgZ2VuZXJhdGluZ1xuICAgKiAgbXVzaWNhbCBmcmVxdWVuY2llcyB3aXRoIG9zY2lsbGF0b3JzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbWlkaVRvRnJlcVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBtaWRpTm90ZSBUaGUgbnVtYmVyIG9mIGEgTUlESSBub3RlXG4gICAqICBAcmV0dXJuIHtOdW1iZXJ9IEZyZXF1ZW5jeSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gTUlESSBub3RlXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBtaWRpTm90ZXMgPSBbNjAsIDY0LCA2NywgNzJdO1xuICAgKiAgbGV0IG5vdGVJbmRleCA9IDA7XG4gICAqICBsZXQgbWlkaVZhbCwgZnJlcTtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChzdGFydFNvdW5kKTtcbiAgICogICAgb3NjID0gbmV3IHA1LlRyaU9zYygpO1xuICAgKiAgICBlbnYgPSBuZXcgcDUuRW52ZWxvcGUoKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAxMCwgMjApO1xuICAgKiAgICBpZiAobWlkaVZhbCkge1xuICAgKiAgICAgIHRleHQoJ01JREk6ICcgKyBtaWRpVmFsLCAxMCwgNDApO1xuICAgKiAgICAgIHRleHQoJ0ZyZXE6ICcgKyBmcmVxLCAxMCwgNjApO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzdGFydFNvdW5kKCkge1xuICAgKiAgICAvLyBzZWUgYWxzbzogdXNlclN0YXJ0QXVkaW8oKTtcbiAgICogICAgb3NjLnN0YXJ0KCk7XG4gICAqXG4gICAqICAgIG1pZGlWYWwgPSBtaWRpTm90ZXNbbm90ZUluZGV4ICUgbWlkaU5vdGVzLmxlbmd0aF07XG4gICAqICAgIGZyZXEgPSBtaWRpVG9GcmVxKG1pZGlWYWwpO1xuICAgKiAgICBvc2MuZnJlcShmcmVxKTtcbiAgICogICAgZW52LnJhbXAob3NjLCAwLCAxLjAsIDApO1xuICAgKlxuICAgKiAgICBub3RlSW5kZXgrKztcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICB2YXIgbWlkaVRvRnJlcSA9IHA1LnByb3RvdHlwZS5taWRpVG9GcmVxID0gZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gNDQwICogTWF0aC5wb3coMiwgKG0gLSA2OSkgLyAxMi4wKTtcbiAgfTsgXG5cblxuICB2YXIgbm90ZVRvRnJlcSA9IGZ1bmN0aW9uIG5vdGVUb0ZyZXEobm90ZSkge1xuICAgIGlmICh0eXBlb2Ygbm90ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBub3RlO1xuICAgIH1cblxuICAgIHZhciB3aG9sZU5vdGVzID0ge1xuICAgICAgQTogMjEsXG4gICAgICBCOiAyMyxcbiAgICAgIEM6IDI0LFxuICAgICAgRDogMjYsXG4gICAgICBFOiAyOCxcbiAgICAgIEY6IDI5LFxuICAgICAgRzogMzFcbiAgICB9O1xuICAgIHZhciB2YWx1ZSA9IHdob2xlTm90ZXNbbm90ZVswXS50b1VwcGVyQ2FzZSgpXTtcbiAgICB2YXIgb2N0YXZlID0gfn5ub3RlLnNsaWNlKC0xKTtcbiAgICB2YWx1ZSArPSAxMiAqIChvY3RhdmUgLSAxKTtcblxuICAgIHN3aXRjaCAobm90ZVsxXSkge1xuICAgICAgY2FzZSAnIyc6XG4gICAgICAgIHZhbHVlICs9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiJzpcbiAgICAgICAgdmFsdWUgLT0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtaWRpVG9GcmVxKHZhbHVlKTtcbiAgfTtcbiAgLyoqXG4gICAqICBMaXN0IHRoZSBTb3VuZEZpbGUgZm9ybWF0cyB0aGF0IHlvdSB3aWxsIGluY2x1ZGUuIExvYWRTb3VuZFxuICAgKiAgd2lsbCBzZWFyY2ggeW91ciBkaXJlY3RvcnkgZm9yIHRoZXNlIGV4dGVuc2lvbnMsIGFuZCB3aWxsIHBpY2tcbiAgICogIGEgZm9ybWF0IHRoYXQgaXMgY29tcGF0YWJsZSB3aXRoIHRoZSBjbGllbnQncyB3ZWIgYnJvd3Nlci5cbiAgICogIDxhIGhyZWY9XCJodHRwOi8vbWVkaWEuaW8vXCI+SGVyZTwvYT4gaXMgYSBmcmVlIG9ubGluZSBmaWxlXG4gICAqICBjb252ZXJ0ZXIuXG4gICAqXG4gICAqICBAbWV0aG9kIHNvdW5kRm9ybWF0c1xuICAgKiAgQHBhcmFtIHtTdHJpbmd9IFsuLi5mb3JtYXRzXSBpLmUuICdtcDMnLCAnd2F2JywgJ29nZydcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgLy8gc2V0IHRoZSBnbG9iYWwgc291bmQgZm9ybWF0c1xuICAgKiAgICBzb3VuZEZvcm1hdHMoJ21wMycsICdvZ2cnKTtcbiAgICpcbiAgICogICAgLy8gbG9hZCBlaXRoZXIgYmVhdGJveC5tcDMsIG9yIC5vZ2csIGRlcGVuZGluZyBvbiBicm93c2VyXG4gICAqICAgIG15U291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Ym94Lm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgICAgIHRleHQoJ3NvdW5kIGxvYWRlZCEgdGFwIHRvIHBsYXknLCAxMCwgMjAsIHdpZHRoIC0gMjApO1xuICAgKiAgICAgICBjbnYubW91c2VQcmVzc2VkKGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgIG15U291bmQucGxheSgpO1xuICAgKiAgICAgICB9KTtcbiAgICogICAgIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5wcm90b3R5cGUuc291bmRGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuICAgIHA1c291bmQuZXh0ZW5zaW9ucyA9IFtdOyBcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmd1bWVudHNbaV0gPSBhcmd1bWVudHNbaV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKFsnbXAzJywgJ3dhdicsICdvZ2cnLCAnbTRhJywgJ2FhYyddLmluZGV4T2YoYXJndW1lbnRzW2ldKSA+IC0xKSB7XG4gICAgICAgIHA1c291bmQuZXh0ZW5zaW9ucy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbaV0gKyAnIGlzIG5vdCBhIHZhbGlkIHNvdW5kIGZvcm1hdCEnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwNS5wcm90b3R5cGUuZGlzcG9zZVNvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcDVzb3VuZC5zb3VuZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBwNXNvdW5kLnNvdW5kQXJyYXlbaV0uZGlzcG9zZSgpO1xuICAgIH1cbiAgfTsgXG5cblxuICBwNS5wcm90b3R5cGUucmVnaXN0ZXJNZXRob2QoJ3JlbW92ZScsIHA1LnByb3RvdHlwZS5kaXNwb3NlU291bmQpO1xuXG4gIHA1LnByb3RvdHlwZS5fY2hlY2tGaWxlRm9ybWF0cyA9IGZ1bmN0aW9uIChwYXRocykge1xuICAgIHZhciBwYXRoOyBcblxuICAgIGlmICh0eXBlb2YgcGF0aHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXRoID0gcGF0aHM7IFxuXG4gICAgICB2YXIgZXh0VGVzdCA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTsgXG5cbiAgICAgIGlmIChbJ21wMycsICd3YXYnLCAnb2dnJywgJ200YScsICdhYWMnXS5pbmRleE9mKGV4dFRlc3QpID4gLTEpIHtcbiAgICAgICAgaWYgKHA1LnByb3RvdHlwZS5pc0ZpbGVTdXBwb3J0ZWQoZXh0VGVzdCkpIHtcbiAgICAgICAgICBwYXRoID0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcGF0aFNwbGl0ID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgIHZhciBwYXRoQ29yZSA9IHBhdGhTcGxpdFtwYXRoU3BsaXQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHA1c291bmQuZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHA1c291bmQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0ZWQgPSBwNS5wcm90b3R5cGUuaXNGaWxlU3VwcG9ydGVkKGV4dGVuc2lvbik7XG5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgcGF0aENvcmUgPSAnJztcblxuICAgICAgICAgICAgICBpZiAocGF0aFNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHBhdGhDb3JlICs9IHBhdGhTcGxpdFswXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHBhdGhTcGxpdC5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhdGhTcGxpdFtpXTtcbiAgICAgICAgICAgICAgICBwYXRoQ29yZSArPSAnLicgKyBwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGF0aCA9IHBhdGhDb3JlICs9ICcuJztcbiAgICAgICAgICAgICAgcGF0aCA9IHBhdGggKz0gZXh0ZW5zaW9uO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHA1c291bmQuZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHA1c291bmQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0ZWQgPSBwNS5wcm90b3R5cGUuaXNGaWxlU3VwcG9ydGVkKGV4dGVuc2lvbik7XG5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgcGF0aCA9IHBhdGggKyAnLicgKyBleHRlbnNpb247XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gXG4gICAgZWxzZSBpZiAoX3R5cGVvZihwYXRocykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gcGF0aHNbaV0uc3BsaXQoJy4nKS5wb3AoKTtcbiAgICAgICAgICB2YXIgc3VwcG9ydGVkID0gcDUucHJvdG90eXBlLmlzRmlsZVN1cHBvcnRlZChleHRlbnNpb24pO1xuXG4gICAgICAgICAgaWYgKHN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcbiAgLyoqXG4gICAqICBVc2VkIGJ5IE9zYyBhbmQgRW52ZWxvcGUgdG8gY2hhaW4gc2lnbmFsIG1hdGhcbiAgICovXG5cblxuICBwNS5wcm90b3R5cGUuX21hdGhDaGFpbiA9IGZ1bmN0aW9uIChvLCBtYXRoLCB0aGlzQ2hhaW4sIG5leHRDaGFpbiwgdHlwZSkge1xuICAgIGZvciAodmFyIGkgaW4gby5tYXRoT3BzKSB7XG4gICAgICBpZiAoby5tYXRoT3BzW2ldIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICBvLm1hdGhPcHNbaV0uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzQ2hhaW4gPSBpO1xuXG4gICAgICAgIGlmICh0aGlzQ2hhaW4gPCBvLm1hdGhPcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG5leHRDaGFpbiA9IG8ubWF0aE9wc1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBvLm1hdGhPcHNbdGhpc0NoYWluIC0gMV0uZGlzY29ubmVjdCgpO1xuICAgIG8ubWF0aE9wc1t0aGlzQ2hhaW4gLSAxXS5jb25uZWN0KG1hdGgpO1xuICAgIG1hdGguY29ubmVjdChuZXh0Q2hhaW4pO1xuICAgIG8ubWF0aE9wc1t0aGlzQ2hhaW5dID0gbWF0aDtcbiAgICByZXR1cm4gbztcbiAgfTsgXG5cblxuICBmdW5jdGlvbiBjb252ZXJ0VG9XYXYoYXVkaW9CdWZmZXIpIHtcbiAgICB2YXIgbGVmdENoYW5uZWwsIHJpZ2h0Q2hhbm5lbDtcbiAgICBsZWZ0Q2hhbm5lbCA9IGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDApOyBcblxuICAgIGlmIChhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzID4gMSkge1xuICAgICAgcmlnaHRDaGFubmVsID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0Q2hhbm5lbCA9IGxlZnRDaGFubmVsO1xuICAgIH1cblxuICAgIHZhciBpbnRlcmxlYXZlZCA9IGludGVybGVhdmUobGVmdENoYW5uZWwsIHJpZ2h0Q2hhbm5lbCk7IFxuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyB3aW5kb3cuQXJyYXlCdWZmZXIoNDQgKyBpbnRlcmxlYXZlZC5sZW5ndGggKiAyKTtcbiAgICB2YXIgdmlldyA9IG5ldyB3aW5kb3cuRGF0YVZpZXcoYnVmZmVyKTsgXG5cbiAgICB3cml0ZVVURkJ5dGVzKHZpZXcsIDAsICdSSUZGJyk7XG4gICAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBpbnRlcmxlYXZlZC5sZW5ndGggKiAyLCB0cnVlKTtcbiAgICB3cml0ZVVURkJ5dGVzKHZpZXcsIDgsICdXQVZFJyk7IFxuXG4gICAgd3JpdGVVVEZCeXRlcyh2aWV3LCAxMiwgJ2ZtdCAnKTtcbiAgICB2aWV3LnNldFVpbnQzMigxNiwgMTYsIHRydWUpO1xuICAgIHZpZXcuc2V0VWludDE2KDIwLCAxLCB0cnVlKTsgXG5cbiAgICB2aWV3LnNldFVpbnQxNigyMiwgMiwgdHJ1ZSk7XG4gICAgdmlldy5zZXRVaW50MzIoMjQsIHA1c291bmQuYXVkaW9jb250ZXh0LnNhbXBsZVJhdGUsIHRydWUpO1xuICAgIHZpZXcuc2V0VWludDMyKDI4LCBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlICogNCwgdHJ1ZSk7XG4gICAgdmlldy5zZXRVaW50MTYoMzIsIDQsIHRydWUpO1xuICAgIHZpZXcuc2V0VWludDE2KDM0LCAxNiwgdHJ1ZSk7IFxuXG4gICAgd3JpdGVVVEZCeXRlcyh2aWV3LCAzNiwgJ2RhdGEnKTtcbiAgICB2aWV3LnNldFVpbnQzMig0MCwgaW50ZXJsZWF2ZWQubGVuZ3RoICogMiwgdHJ1ZSk7IFxuXG4gICAgdmFyIGxuZyA9IGludGVybGVhdmVkLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSA0NDtcbiAgICB2YXIgdm9sdW1lID0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG5nOyBpKyspIHtcbiAgICAgIHZpZXcuc2V0SW50MTYoaW5kZXgsIGludGVybGVhdmVkW2ldICogKDB4N0ZGRiAqIHZvbHVtZSksIHRydWUpO1xuICAgICAgaW5kZXggKz0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlldztcbiAgfSBcblxuXG4gIGZ1bmN0aW9uIGludGVybGVhdmUobGVmdENoYW5uZWwsIHJpZ2h0Q2hhbm5lbCkge1xuICAgIHZhciBsZW5ndGggPSBsZWZ0Q2hhbm5lbC5sZW5ndGggKyByaWdodENoYW5uZWwubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XG4gICAgdmFyIGlucHV0SW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDspIHtcbiAgICAgIHJlc3VsdFtpbmRleCsrXSA9IGxlZnRDaGFubmVsW2lucHV0SW5kZXhdO1xuICAgICAgcmVzdWx0W2luZGV4KytdID0gcmlnaHRDaGFubmVsW2lucHV0SW5kZXhdO1xuICAgICAgaW5wdXRJbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZVVURkJ5dGVzKHZpZXcsIG9mZnNldCwgc3RyaW5nKSB7XG4gICAgdmFyIGxuZyA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxuZzsgaSsrKSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIHN0cmluZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlQnVmZmVyU2l6ZShpZGVhbEJ1ZmZlclNpemUpIHtcbiAgICB2YXIgYnVmZmVyU2l6ZSA9IGlkZWFsQnVmZmVyU2l6ZTsgXG5cbiAgICB2YXIgdGVtcEF1ZGlvV29ya2xldE5vZGUgPSBuZXcgQXVkaW9Xb3JrbGV0Tm9kZShwNXNvdW5kLmF1ZGlvY29udGV4dCwgcHJvY2Vzc29yTmFtZXMuc291bmRGaWxlUHJvY2Vzc29yKTtcblxuICAgIGlmICh0ZW1wQXVkaW9Xb3JrbGV0Tm9kZSBpbnN0YW5jZW9mIFNjcmlwdFByb2Nlc3Nvck5vZGUpIHtcbiAgICAgIGJ1ZmZlclNpemUgPSB0ZW1wQXVkaW9Xb3JrbGV0Tm9kZS5idWZmZXJTaXplO1xuICAgIH1cblxuICAgIHRlbXBBdWRpb1dvcmtsZXROb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICB0ZW1wQXVkaW9Xb3JrbGV0Tm9kZSA9IG51bGw7XG4gICAgcmV0dXJuIGJ1ZmZlclNpemU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbnZlcnRUb1dhdjogY29udmVydFRvV2F2LFxuICAgIG1pZGlUb0ZyZXE6IG1pZGlUb0ZyZXEsXG4gICAgbm90ZVRvRnJlcTogbm90ZVRvRnJlcSxcbiAgICBzYWZlQnVmZmVyU2l6ZTogc2FmZUJ1ZmZlclNpemVcbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDkpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oaSl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGkuQWRkPWZ1bmN0aW9uKHQpe3RoaXMuY3JlYXRlSW5zT3V0cygyLDApLHRoaXMuX3N1bT10aGlzLmlucHV0WzBdPXRoaXMuaW5wdXRbMV09dGhpcy5vdXRwdXQ9bmV3IGkuR2Fpbix0aGlzLl9wYXJhbT10aGlzLmlucHV0WzFdPW5ldyBpLlNpZ25hbCh0KSx0aGlzLl9wYXJhbS5jb25uZWN0KHRoaXMuX3N1bSl9LGkuZXh0ZW5kKGkuQWRkLGkuU2lnbmFsKSxpLkFkZC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBpLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fc3VtLmRpc3Bvc2UoKSx0aGlzLl9zdW09bnVsbCx0aGlzLl9wYXJhbS5kaXNwb3NlKCksdGhpcy5fcGFyYW09bnVsbCx0aGlzfSxpLkFkZH0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKHQpe3JldHVybiB0LlR5cGU9e0RlZmF1bHQ6XCJudW1iZXJcIixUaW1lOlwidGltZVwiLEZyZXF1ZW5jeTpcImZyZXF1ZW5jeVwiLFRyYW5zcG9ydFRpbWU6XCJ0cmFuc3BvcnRUaW1lXCIsVGlja3M6XCJ0aWNrc1wiLE5vcm1hbFJhbmdlOlwibm9ybWFsUmFuZ2VcIixBdWRpb1JhbmdlOlwiYXVkaW9SYW5nZVwiLERlY2liZWxzOlwiZGJcIixJbnRlcnZhbDpcImludGVydmFsXCIsQlBNOlwiYnBtXCIsUG9zaXRpdmU6XCJwb3NpdGl2ZVwiLENlbnRzOlwiY2VudHNcIixEZWdyZWVzOlwiZGVncmVlc1wiLE1JREk6XCJtaWRpXCIsQmFyc0JlYXRzU2l4dGVlbnRoczpcImJhcnNCZWF0c1NpeHRlZW50aHNcIixTYW1wbGVzOlwic2FtcGxlc1wiLEhlcnR6OlwiaGVydHpcIixOb3RlOlwibm90ZVwiLE1pbGxpc2Vjb25kczpcIm1pbGxpc2Vjb25kc1wiLFNlY29uZHM6XCJzZWNvbmRzXCIsTm90YXRpb246XCJub3RhdGlvblwifSx0LnByb3RvdHlwZS50b1NlY29uZHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaXNOdW1iZXIoZSk/ZTp0aGlzLmlzVW5kZWYoZSk/dGhpcy5ub3coKTp0aGlzLmlzU3RyaW5nKGUpP25ldyB0LlRpbWUoZSkudG9TZWNvbmRzKCk6ZSBpbnN0YW5jZW9mIHQuVGltZUJhc2U/ZS50b1NlY29uZHMoKTp2b2lkIDB9LHQucHJvdG90eXBlLnRvRnJlcXVlbmN5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmlzTnVtYmVyKGUpP2U6dGhpcy5pc1N0cmluZyhlKXx8dGhpcy5pc1VuZGVmKGUpP25ldyB0LkZyZXF1ZW5jeShlKS52YWx1ZU9mKCk6ZSBpbnN0YW5jZW9mIHQuVGltZUJhc2U/ZS50b0ZyZXF1ZW5jeSgpOnZvaWQgMH0sdC5wcm90b3R5cGUudG9UaWNrcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pc051bWJlcihlKXx8dGhpcy5pc1N0cmluZyhlKT9uZXcgdC5UcmFuc3BvcnRUaW1lKGUpLnRvVGlja3MoKTp0aGlzLmlzVW5kZWYoZSk/dC5UcmFuc3BvcnQudGlja3M6ZSBpbnN0YW5jZW9mIHQuVGltZUJhc2U/ZS50b1RpY2tzKCk6dm9pZCAwfSx0fSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oMjIpLF9fd2VicGFja19yZXF1aXJlX18oOCldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihpKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gd2luZG93LkdhaW5Ob2RlJiYhQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluJiYoQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluPUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2Fpbk5vZGUpLGkuR2Fpbj1mdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsW1wiZ2FpblwiLFwidW5pdHNcIl0saS5HYWluLmRlZmF1bHRzKTt0aGlzLmlucHV0PXRoaXMub3V0cHV0PXRoaXMuX2dhaW5Ob2RlPXRoaXMuY29udGV4dC5jcmVhdGVHYWluKCksdGhpcy5nYWluPW5ldyBpLlBhcmFtKHtwYXJhbTp0aGlzLl9nYWluTm9kZS5nYWluLHVuaXRzOnQudW5pdHMsdmFsdWU6dC5nYWluLGNvbnZlcnQ6dC5jb252ZXJ0fSksdGhpcy5fcmVhZE9ubHkoXCJnYWluXCIpfSxpLmV4dGVuZChpLkdhaW4pLGkuR2Fpbi5kZWZhdWx0cz17Z2FpbjoxLGNvbnZlcnQ6ITB9LGkuR2Fpbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2kuUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9nYWluTm9kZS5kaXNjb25uZWN0KCksdGhpcy5fZ2Fpbk5vZGU9bnVsbCx0aGlzLl93cml0YWJsZShcImdhaW5cIiksdGhpcy5nYWluLmRpc3Bvc2UoKSx0aGlzLmdhaW49bnVsbH0saS5wcm90b3R5cGUuY3JlYXRlSW5zT3V0cz1mdW5jdGlvbih0LG4pezE9PT10P3RoaXMuaW5wdXQ9bmV3IGkuR2FpbjoxPHQmJih0aGlzLmlucHV0PW5ldyBBcnJheSh0KSksMT09PW4/dGhpcy5vdXRwdXQ9bmV3IGkuR2FpbjoxPG4mJih0aGlzLm91dHB1dD1uZXcgQXJyYXkodCkpfSxpLkdhaW59KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVjb3JkZXJQcm9jZXNzb3I6ICdyZWNvcmRlci1wcm9jZXNzb3InLFxuICBzb3VuZEZpbGVQcm9jZXNzb3I6ICdzb3VuZC1maWxlLXByb2Nlc3NvcicsXG4gIGFtcGxpdHVkZVByb2Nlc3NvcjogJ2FtcGxpdHVkZS1wcm9jZXNzb3InXG59O1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBDdXN0b21FcnJvciA9IGZ1bmN0aW9uIEN1c3RvbUVycm9yKG5hbWUsIGVycm9yVHJhY2UsIGZhaWxlZFBhdGgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgdmFyIHRlbXBTdGFjaywgc3BsaXRTdGFjaztcbiAgICBlcnIubmFtZSA9IG5hbWU7XG4gICAgZXJyLm9yaWdpbmFsU3RhY2sgPSBlcnIuc3RhY2sgKyBlcnJvclRyYWNlO1xuICAgIHRlbXBTdGFjayA9IGVyci5zdGFjayArIGVycm9yVHJhY2U7XG4gICAgZXJyLmZhaWxlZFBhdGggPSBmYWlsZWRQYXRoOyBcblxuICAgIHZhciBzcGxpdFN0YWNrID0gdGVtcFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICBzcGxpdFN0YWNrID0gc3BsaXRTdGFjay5maWx0ZXIoZnVuY3Rpb24gKGxuKSB7XG4gICAgICByZXR1cm4gIWxuLm1hdGNoKC8ocDUufG5hdGl2ZSBjb2RlfGdsb2JhbEluaXQpL2cpO1xuICAgIH0pO1xuICAgIGVyci5zdGFjayA9IHNwbGl0U3RhY2suam9pbignXFxuJyk7XG4gICAgcmV0dXJuIGVycjsgXG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbUVycm9yO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKG8pe2Z1bmN0aW9uIHQoZSx0LG4pe2lmKGUuaW5wdXQpQXJyYXkuaXNBcnJheShlLmlucHV0KT8oby5wcm90b3R5cGUuaXNVbmRlZihuKSYmKG49MCksdGhpcy5jb25uZWN0KGUuaW5wdXRbbl0pKTp0aGlzLmNvbm5lY3QoZS5pbnB1dCx0LG4pO2Vsc2UgdHJ5e2UgaW5zdGFuY2VvZiBBdWRpb05vZGU/aS5jYWxsKHRoaXMsZSx0LG4pOmkuY2FsbCh0aGlzLGUsdCl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiZXJyb3IgY29ubmVjdGluZyB0byBub2RlOiBcIitlK1wiXFxuXCIrdCl9fXZhciBpLHI7cmV0dXJuIXdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIkF1ZGlvQ29udGV4dFwiKSYmd2luZG93Lmhhc093blByb3BlcnR5KFwid2Via2l0QXVkaW9Db250ZXh0XCIpJiYod2luZG93LkF1ZGlvQ29udGV4dD13aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSxvLkNvbnRleHQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIG8uRW1pdHRlci5jYWxsKHRoaXMpLHQ9dHx8bmV3IHdpbmRvdy5BdWRpb0NvbnRleHQsdGhpcy5fY29udGV4dD10LHRoaXMuX2NvbnRleHQpdGhpcy5fZGVmaW5lUHJvcGVydHkodGhpcy5fY29udGV4dCxlKTt0aGlzLl9sYXRlbmN5SGludD1cImludGVyYWN0aXZlXCIsdGhpcy5fbG9va0FoZWFkPS4xLHRoaXMuX3VwZGF0ZUludGVydmFsPXRoaXMuX2xvb2tBaGVhZC8zLHRoaXMuX2NvbXB1dGVkVXBkYXRlSW50ZXJ2YWw9MCx0aGlzLl93b3JrZXI9dGhpcy5fY3JlYXRlV29ya2VyKCksdGhpcy5fY29uc3RhbnRzPXt9fSxvLmV4dGVuZChvLkNvbnRleHQsby5FbWl0dGVyKSxvLkVtaXR0ZXIubWl4aW4oby5Db250ZXh0KSxvLkNvbnRleHQucHJvdG90eXBlLl9kZWZpbmVQcm9wZXJ0eT1mdW5jdGlvbihlLG4pe3RoaXMuaXNVbmRlZih0aGlzW25dKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsbix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZVtuXT9lW25dLmJpbmQoZSk6ZVtuXX0sc2V0OmZ1bmN0aW9uKHQpe2Vbbl09dH19KX0sby5Db250ZXh0LnByb3RvdHlwZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGV4dC5jdXJyZW50VGltZX0sby5Db250ZXh0LnByb3RvdHlwZS5fY3JlYXRlV29ya2VyPWZ1bmN0aW9uKCl7d2luZG93LlVSTD13aW5kb3cuVVJMfHx3aW5kb3cud2Via2l0VVJMO3ZhciB0PW5ldyBCbG9iKFtcInZhciB0aW1lb3V0VGltZSA9IFwiKygxZTMqdGhpcy5fdXBkYXRlSW50ZXJ2YWwpLnRvRml4ZWQoMSkrXCI7c2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpe1xcdHRpbWVvdXRUaW1lID0gcGFyc2VJbnQobXNnLmRhdGEpO307ZnVuY3Rpb24gdGljaygpe1xcdHNldFRpbWVvdXQodGljaywgdGltZW91dFRpbWUpO1xcdHNlbGYucG9zdE1lc3NhZ2UoJ3RpY2snKTt9dGljaygpO1wiXSksZT1VUkwuY3JlYXRlT2JqZWN0VVJMKHQpLG49bmV3IFdvcmtlcihlKTtyZXR1cm4gbi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGZ1bmN0aW9uKCl7dGhpcy5lbWl0KFwidGlja1wiKX0uYmluZCh0aGlzKSksbi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ub3coKTtpZih0aGlzLmlzTnVtYmVyKHRoaXMuX2xhc3RVcGRhdGUpKXt2YXIgZT10LXRoaXMuX2xhc3RVcGRhdGU7dGhpcy5fY29tcHV0ZWRVcGRhdGVJbnRlcnZhbD1NYXRoLm1heChlLC45Nyp0aGlzLl9jb21wdXRlZFVwZGF0ZUludGVydmFsKX10aGlzLl9sYXN0VXBkYXRlPXR9LmJpbmQodGhpcykpLG59LG8uQ29udGV4dC5wcm90b3R5cGUuZ2V0Q29uc3RhbnQ9ZnVuY3Rpb24odCl7aWYodGhpcy5fY29uc3RhbnRzW3RdKXJldHVybiB0aGlzLl9jb25zdGFudHNbdF07Zm9yKHZhciBlPXRoaXMuX2NvbnRleHQuY3JlYXRlQnVmZmVyKDEsMTI4LHRoaXMuX2NvbnRleHQuc2FtcGxlUmF0ZSksbj1lLmdldENoYW5uZWxEYXRhKDApLG89MDtvPG4ubGVuZ3RoO28rKyluW29dPXQ7dmFyIGk9dGhpcy5fY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtyZXR1cm4gaS5jaGFubmVsQ291bnQ9MSxpLmNoYW5uZWxDb3VudE1vZGU9XCJleHBsaWNpdFwiLGkuYnVmZmVyPWUsaS5sb29wPSEwLGkuc3RhcnQoMCksdGhpcy5fY29uc3RhbnRzW3RdPWl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLkNvbnRleHQucHJvdG90eXBlLFwibGFnXCIse2dldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NvbXB1dGVkVXBkYXRlSW50ZXJ2YWwtdGhpcy5fdXBkYXRlSW50ZXJ2YWw7cmV0dXJuIHQ9TWF0aC5tYXgodCwwKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoby5Db250ZXh0LnByb3RvdHlwZSxcImxvb2tBaGVhZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbG9va0FoZWFkfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fbG9va0FoZWFkPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG8uQ29udGV4dC5wcm90b3R5cGUsXCJ1cGRhdGVJbnRlcnZhbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdXBkYXRlSW50ZXJ2YWx9LHNldDpmdW5jdGlvbih0KXt0aGlzLl91cGRhdGVJbnRlcnZhbD1NYXRoLm1heCh0LG8ucHJvdG90eXBlLmJsb2NrVGltZSksdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKE1hdGgubWF4KDFlMyp0LDEpKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoby5Db250ZXh0LnByb3RvdHlwZSxcImxhdGVuY3lIaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sYXRlbmN5SGludH0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7aWYodGhpcy5fbGF0ZW5jeUhpbnQ9dCx0aGlzLmlzU3RyaW5nKHQpKXN3aXRjaCh0KXtjYXNlXCJpbnRlcmFjdGl2ZVwiOmU9LjEsdGhpcy5fY29udGV4dC5sYXRlbmN5SGludD10O2JyZWFrO2Nhc2VcInBsYXliYWNrXCI6ZT0uOCx0aGlzLl9jb250ZXh0LmxhdGVuY3lIaW50PXQ7YnJlYWs7Y2FzZVwiYmFsYW5jZWRcIjplPS4yNSx0aGlzLl9jb250ZXh0LmxhdGVuY3lIaW50PXQ7YnJlYWs7Y2FzZVwiZmFzdGVzdFwiOmU9LjAxfXRoaXMubG9va0FoZWFkPWUsdGhpcy51cGRhdGVJbnRlcnZhbD1lLzN9fSksby5zdXBwb3J0ZWQ/KGk9QXVkaW9Ob2RlLnByb3RvdHlwZS5jb25uZWN0LHI9QXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNjb25uZWN0LEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdCE9PXQmJihBdWRpb05vZGUucHJvdG90eXBlLmNvbm5lY3Q9dCxBdWRpb05vZGUucHJvdG90eXBlLmRpc2Nvbm5lY3Q9ZnVuY3Rpb24oZSx0LG4pe2lmKGUmJmUuaW5wdXQmJkFycmF5LmlzQXJyYXkoZS5pbnB1dCkpby5wcm90b3R5cGUuaXNVbmRlZihuKSYmKG49MCksdGhpcy5kaXNjb25uZWN0KGUuaW5wdXRbbl0sdCxuKTtlbHNlIGlmKGUmJmUuaW5wdXQpdGhpcy5kaXNjb25uZWN0KGUuaW5wdXQsdCxuKTtlbHNlIHRyeXtyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJlcnJvciBkaXNjb25uZWN0aW5nIG5vZGU6IFwiK2UrXCJcXG5cIit0KX19KSxvLmNvbnRleHQ9bmV3IG8uQ29udGV4dCk6Y29uc29sZS53YXJuKFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgVG9uZS5qc1wiKSxvLkNvbnRleHR9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXyg3KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLF9fd2VicGFja19yZXF1aXJlX18oMildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihpKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gaS5TY2FsZT1mdW5jdGlvbih0LGUpe3RoaXMuX291dHB1dE1pbj10aGlzLmRlZmF1bHRBcmcodCwwKSx0aGlzLl9vdXRwdXRNYXg9dGhpcy5kZWZhdWx0QXJnKGUsMSksdGhpcy5fc2NhbGU9dGhpcy5pbnB1dD1uZXcgaS5NdWx0aXBseSgxKSx0aGlzLl9hZGQ9dGhpcy5vdXRwdXQ9bmV3IGkuQWRkKDApLHRoaXMuX3NjYWxlLmNvbm5lY3QodGhpcy5fYWRkKSx0aGlzLl9zZXRSYW5nZSgpfSxpLmV4dGVuZChpLlNjYWxlLGkuU2lnbmFsQmFzZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGkuU2NhbGUucHJvdG90eXBlLFwibWluXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vdXRwdXRNaW59LHNldDpmdW5jdGlvbih0KXt0aGlzLl9vdXRwdXRNaW49dCx0aGlzLl9zZXRSYW5nZSgpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLlNjYWxlLnByb3RvdHlwZSxcIm1heFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3V0cHV0TWF4fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fb3V0cHV0TWF4PXQsdGhpcy5fc2V0UmFuZ2UoKX19KSxpLlNjYWxlLnByb3RvdHlwZS5fc2V0UmFuZ2U9ZnVuY3Rpb24oKXt0aGlzLl9hZGQudmFsdWU9dGhpcy5fb3V0cHV0TWluLHRoaXMuX3NjYWxlLnZhbHVlPXRoaXMuX291dHB1dE1heC10aGlzLl9vdXRwdXRNaW59LGkuU2NhbGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gaS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX2FkZC5kaXNwb3NlKCksdGhpcy5fYWRkPW51bGwsdGhpcy5fc2NhbGUuZGlzcG9zZSgpLHRoaXMuX3NjYWxlPW51bGwsdGhpc30saS5TY2FsZX0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLF9fd2VicGFja19yZXF1aXJlX18oMjQpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24obyl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIG8uVGltZWxpbmVTaWduYWw9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLFtcInZhbHVlXCIsXCJ1bml0c1wiXSxvLlNpZ25hbC5kZWZhdWx0cyk7dGhpcy5fZXZlbnRzPW5ldyBvLlRpbWVsaW5lKDEwKSxvLlNpZ25hbC5hcHBseSh0aGlzLGUpLGUucGFyYW09dGhpcy5fcGFyYW0sby5QYXJhbS5jYWxsKHRoaXMsZSksdGhpcy5faW5pdGlhbD10aGlzLl9mcm9tVW5pdHModGhpcy5fcGFyYW0udmFsdWUpfSxvLmV4dGVuZChvLlRpbWVsaW5lU2lnbmFsLG8uUGFyYW0pLG8uVGltZWxpbmVTaWduYWwuVHlwZT17TGluZWFyOlwibGluZWFyXCIsRXhwb25lbnRpYWw6XCJleHBvbmVudGlhbFwiLFRhcmdldDpcInRhcmdldFwiLEN1cnZlOlwiY3VydmVcIixTZXQ6XCJzZXRcIn0sT2JqZWN0LmRlZmluZVByb3BlcnR5KG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5ub3coKSx0PXRoaXMuZ2V0VmFsdWVBdFRpbWUoZSk7cmV0dXJuIHRoaXMuX3RvVW5pdHModCl9LHNldDpmdW5jdGlvbihlKXt2YXIgdD10aGlzLl9mcm9tVW5pdHMoZSk7dGhpcy5faW5pdGlhbD10LHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKCksdGhpcy5fcGFyYW0udmFsdWU9dH19KSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUF0VGltZT1mdW5jdGlvbihlLHQpe3JldHVybiBlPXRoaXMuX2Zyb21Vbml0cyhlKSx0PXRoaXMudG9TZWNvbmRzKHQpLHRoaXMuX2V2ZW50cy5hZGQoe3R5cGU6by5UaW1lbGluZVNpZ25hbC5UeXBlLlNldCx2YWx1ZTplLHRpbWU6dH0pLHRoaXMuX3BhcmFtLnNldFZhbHVlQXRUaW1lKGUsdCksdGhpc30sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT10aGlzLl9mcm9tVW5pdHMoZSksdD10aGlzLnRvU2Vjb25kcyh0KSx0aGlzLl9ldmVudHMuYWRkKHt0eXBlOm8uVGltZWxpbmVTaWduYWwuVHlwZS5MaW5lYXIsdmFsdWU6ZSx0aW1lOnR9KSx0aGlzLl9wYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShlLHQpLHRoaXN9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWU9ZnVuY3Rpb24oZSx0KXt0PXRoaXMudG9TZWNvbmRzKHQpO3ZhciBpPXRoaXMuX3NlYXJjaEJlZm9yZSh0KTtpJiYwPT09aS52YWx1ZSYmdGhpcy5zZXRWYWx1ZUF0VGltZSh0aGlzLl9taW5PdXRwdXQsaS50aW1lKSxlPXRoaXMuX2Zyb21Vbml0cyhlKTt2YXIgbj1NYXRoLm1heChlLHRoaXMuX21pbk91dHB1dCk7cmV0dXJuIHRoaXMuX2V2ZW50cy5hZGQoe3R5cGU6by5UaW1lbGluZVNpZ25hbC5UeXBlLkV4cG9uZW50aWFsLHZhbHVlOm4sdGltZTp0fSksZTx0aGlzLl9taW5PdXRwdXQ/KHRoaXMuX3BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fbWluT3V0cHV0LHQtdGhpcy5zYW1wbGVUaW1lKSx0aGlzLnNldFZhbHVlQXRUaW1lKDAsdCkpOnRoaXMuX3BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUoZSx0KSx0aGlzfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRUYXJnZXRBdFRpbWU9ZnVuY3Rpb24oZSx0LGkpe3JldHVybiBlPXRoaXMuX2Zyb21Vbml0cyhlKSxlPU1hdGgubWF4KHRoaXMuX21pbk91dHB1dCxlKSxpPU1hdGgubWF4KHRoaXMuX21pbk91dHB1dCxpKSx0PXRoaXMudG9TZWNvbmRzKHQpLHRoaXMuX2V2ZW50cy5hZGQoe3R5cGU6by5UaW1lbGluZVNpZ25hbC5UeXBlLlRhcmdldCx2YWx1ZTplLHRpbWU6dCxjb25zdGFudDppfSksdGhpcy5fcGFyYW0uc2V0VGFyZ2V0QXRUaW1lKGUsdCxpKSx0aGlzfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUN1cnZlQXRUaW1lPWZ1bmN0aW9uKGUsdCxpLG4pe249dGhpcy5kZWZhdWx0QXJnKG4sMSk7Zm9yKHZhciBhPW5ldyBBcnJheShlLmxlbmd0aCksbD0wO2w8YS5sZW5ndGg7bCsrKWFbbF09dGhpcy5fZnJvbVVuaXRzKGVbbF0pKm47dD10aGlzLnRvU2Vjb25kcyh0KSxpPXRoaXMudG9TZWNvbmRzKGkpLHRoaXMuX2V2ZW50cy5hZGQoe3R5cGU6by5UaW1lbGluZVNpZ25hbC5UeXBlLkN1cnZlLHZhbHVlOmEsdGltZTp0LGR1cmF0aW9uOml9KSx0aGlzLl9wYXJhbS5zZXRWYWx1ZUF0VGltZShhWzBdLHQpO2Zvcih2YXIgcz0xO3M8YS5sZW5ndGg7cysrKXt2YXIgcj10K3MvKGEubGVuZ3RoLTEpKmk7dGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoYVtzXSxyKX1yZXR1cm4gdGhpc30sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzPWZ1bmN0aW9uKGUpe3JldHVybiBlPXRoaXMudG9TZWNvbmRzKGUpLHRoaXMuX2V2ZW50cy5jYW5jZWwoZSksdGhpcy5fcGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGUpLHRoaXN9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFJhbXBQb2ludD1mdW5jdGlvbihlKXtlPXRoaXMudG9TZWNvbmRzKGUpO3ZhciB0PXRoaXMuX3RvVW5pdHModGhpcy5nZXRWYWx1ZUF0VGltZShlKSksaT10aGlzLl9zZWFyY2hCZWZvcmUoZSk7aWYoaSYmaS50aW1lPT09ZSl0aGlzLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhlK3RoaXMuc2FtcGxlVGltZSk7ZWxzZSBpZihpJiZpLnR5cGU9PT1vLlRpbWVsaW5lU2lnbmFsLlR5cGUuQ3VydmUmJmkudGltZStpLmR1cmF0aW9uPmUpdGhpcy5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoZSksdGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0LGUpO2Vsc2V7dmFyIG49dGhpcy5fc2VhcmNoQWZ0ZXIoZSk7biYmKHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGUpLG4udHlwZT09PW8uVGltZWxpbmVTaWduYWwuVHlwZS5MaW5lYXI/dGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0LGUpOm4udHlwZT09PW8uVGltZWxpbmVTaWduYWwuVHlwZS5FeHBvbmVudGlhbCYmdGhpcy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHQsZSkpLHRoaXMuc2V0VmFsdWVBdFRpbWUodCxlKX1yZXR1cm4gdGhpc30sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWVCZXR3ZWVuPWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gdGhpcy5zZXRSYW1wUG9pbnQodCksdGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShlLGkpLHRoaXN9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVCZXR3ZWVuPWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gdGhpcy5zZXRSYW1wUG9pbnQodCksdGhpcy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKGUsaSksdGhpc30sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX3NlYXJjaEJlZm9yZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fZXZlbnRzLmdldChlKX0sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX3NlYXJjaEFmdGVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9ldmVudHMuZ2V0QWZ0ZXIoZSl9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lPWZ1bmN0aW9uKGUpe2U9dGhpcy50b1NlY29uZHMoZSk7dmFyIHQ9dGhpcy5fc2VhcmNoQWZ0ZXIoZSksaT10aGlzLl9zZWFyY2hCZWZvcmUoZSksbj10aGlzLl9pbml0aWFsO2lmKG51bGw9PT1pKW49dGhpcy5faW5pdGlhbDtlbHNlIGlmKGkudHlwZT09PW8uVGltZWxpbmVTaWduYWwuVHlwZS5UYXJnZXQpe3ZhciBhLGw9dGhpcy5fZXZlbnRzLmdldEJlZm9yZShpLnRpbWUpO2E9bnVsbD09PWw/dGhpcy5faW5pdGlhbDpsLnZhbHVlLG49dGhpcy5fZXhwb25lbnRpYWxBcHByb2FjaChpLnRpbWUsYSxpLnZhbHVlLGkuY29uc3RhbnQsZSl9ZWxzZSBuPWkudHlwZT09PW8uVGltZWxpbmVTaWduYWwuVHlwZS5DdXJ2ZT90aGlzLl9jdXJ2ZUludGVycG9sYXRlKGkudGltZSxpLnZhbHVlLGkuZHVyYXRpb24sZSk6bnVsbD09PXQ/aS52YWx1ZTp0LnR5cGU9PT1vLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyP3RoaXMuX2xpbmVhckludGVycG9sYXRlKGkudGltZSxpLnZhbHVlLHQudGltZSx0LnZhbHVlLGUpOnQudHlwZT09PW8uVGltZWxpbmVTaWduYWwuVHlwZS5FeHBvbmVudGlhbD90aGlzLl9leHBvbmVudGlhbEludGVycG9sYXRlKGkudGltZSxpLnZhbHVlLHQudGltZSx0LnZhbHVlLGUpOmkudmFsdWU7cmV0dXJuIG59LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNvbm5lY3Q9by5TaWduYWxCYXNlLnByb3RvdHlwZS5jb25uZWN0LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9leHBvbmVudGlhbEFwcHJvYWNoPWZ1bmN0aW9uKGUsdCxpLG4sYSl7cmV0dXJuIGkrKHQtaSkqTWF0aC5leHAoLShhLWUpL24pfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fbGluZWFySW50ZXJwb2xhdGU9ZnVuY3Rpb24oZSx0LGksbixhKXtyZXR1cm4gdCsoYS1lKS8oaS1lKSoobi10KX0sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX2V4cG9uZW50aWFsSW50ZXJwb2xhdGU9ZnVuY3Rpb24oZSx0LGksbixhKXtyZXR1cm4odD1NYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsdCkpKk1hdGgucG93KG4vdCwoYS1lKS8oaS1lKSl9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9jdXJ2ZUludGVycG9sYXRlPWZ1bmN0aW9uKGUsdCxpLG4pe3ZhciBhPXQubGVuZ3RoO2lmKGUraTw9bilyZXR1cm4gdFthLTFdO2lmKG48PWUpcmV0dXJuIHRbMF07dmFyIGw9KG4tZSkvaSxzPU1hdGguZmxvb3IoKGEtMSkqbCkscj1NYXRoLmNlaWwoKGEtMSkqbCksbz10W3NdLHA9dFtyXTtyZXR1cm4gcj09PXM/bzp0aGlzLl9saW5lYXJJbnRlcnBvbGF0ZShzLG8scixwLGwqKGEtMSkpfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7by5TaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSxvLlBhcmFtLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fZXZlbnRzLmRpc3Bvc2UoKSx0aGlzLl9ldmVudHM9bnVsbH0sby5UaW1lbGluZVNpZ25hbH0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBFZmZlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuICAvKipcbiAgICogIDxwPkEgcDUuRmlsdGVyIHVzZXMgYSBXZWIgQXVkaW8gQmlxdWFkIEZpbHRlciB0byBmaWx0ZXJcbiAgICogIHRoZSBmcmVxdWVuY3kgcmVzcG9uc2Ugb2YgYW4gaW5wdXQgc291cmNlLiBTdWJjbGFzc2VzXG4gICAqICBpbmNsdWRlOjwvcD5cbiAgICogIDxhIGhyZWY9XCIvcmVmZXJlbmNlLyMvcDUuTG93UGFzc1wiPjxjb2RlPnA1Lkxvd1Bhc3M8L2NvZGU+PC9hPjpcbiAgICogIEFsbG93cyBmcmVxdWVuY2llcyBiZWxvdyB0aGUgY3V0b2ZmIGZyZXF1ZW5jeSB0byBwYXNzIHRocm91Z2gsXG4gICAqICBhbmQgYXR0ZW51YXRlcyBmcmVxdWVuY2llcyBhYm92ZSB0aGUgY3V0b2ZmLjxici8+XG4gICAqICA8YSBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LkhpZ2hQYXNzXCI+PGNvZGU+cDUuSGlnaFBhc3M8L2NvZGU+PC9hPjpcbiAgICogIFRoZSBvcHBvc2l0ZSBvZiBhIGxvd3Bhc3MgZmlsdGVyLiA8YnIvPlxuICAgKiAgPGEgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5CYW5kUGFzc1wiPjxjb2RlPnA1LkJhbmRQYXNzPC9jb2RlPjwvYT46XG4gICAqICBBbGxvd3MgYSByYW5nZSBvZiBmcmVxdWVuY2llcyB0byBwYXNzIHRocm91Z2ggYW5kIGF0dGVudWF0ZXNcbiAgICogIHRoZSBmcmVxdWVuY2llcyBiZWxvdyBhbmQgYWJvdmUgdGhpcyBmcmVxdWVuY3kgcmFuZ2UuPGJyLz5cbiAgICpcbiAgICogIFRoZSA8Y29kZT4ucmVzKCk8L2NvZGU+IG1ldGhvZCBjb250cm9scyBlaXRoZXIgd2lkdGggb2YgdGhlXG4gICAqICBiYW5kcGFzcywgb3IgcmVzb25hbmNlIG9mIHRoZSBsb3cvaGlnaHBhc3MgY3V0b2ZmIGZyZXF1ZW5jeS5cbiAgICpcbiAgICogIFRoaXMgY2xhc3MgZXh0ZW5kcyA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0XCI+cDUuRWZmZWN0PC9hPi5cbiAgICogIE1ldGhvZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9hbXBcIj5hbXAoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY2hhaW5cIj5jaGFpbigpPC9hPixcbiAgICogIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZHJ5d2V0XCI+ZHJ5d2V0KCk8L2E+LCA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Nvbm5lY3RcIj5jb25uZWN0KCk8L2E+LCBhbmRcbiAgICogIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZGlzY29ubmVjdFwiPmRpc2Nvbm5lY3QoKTwvYT4gYXJlIGF2YWlsYWJsZS5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5GaWx0ZXJcbiAgICogIEBleHRlbmRzIHA1LkVmZmVjdFxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge1N0cmluZ30gW3R5cGVdICdsb3dwYXNzJyAoZGVmYXVsdCksICdoaWdocGFzcycsICdiYW5kcGFzcydcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAqICBsZXQgZmZ0LCBub2lzZSwgZmlsdGVyO1xuICAqXG4gICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLDEwMCk7XG4gICogICAgY252Lm1vdXNlUHJlc3NlZChtYWtlTm9pc2UpO1xuICAqICAgIGZpbGwoMjU1LCAwLCAyNTUpO1xuICAqXG4gICogICAgZmlsdGVyID0gbmV3IHA1LkJhbmRQYXNzKCk7XG4gICogICAgbm9pc2UgPSBuZXcgcDUuTm9pc2UoKTtcbiAgKiAgICBub2lzZS5kaXNjb25uZWN0KCk7XG4gICogICAgbm9pc2UuY29ubmVjdChmaWx0ZXIpO1xuICAqXG4gICogICAgZmZ0ID0gbmV3IHA1LkZGVCgpO1xuICAqICB9XG4gICpcbiAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICpcbiAgKiAgICAvLyBzZXQgdGhlIEJhbmRQYXNzIGZyZXF1ZW5jeSBiYXNlZCBvbiBtb3VzZVhcbiAgKiAgICBsZXQgZnJlcSA9IG1hcChtb3VzZVgsIDAsIHdpZHRoLCAyMCwgMTAwMDApO1xuICAqICAgIGZyZXEgPSBjb25zdHJhaW4oZnJlcSwgMCwgMjIwNTApO1xuICAqICAgIGZpbHRlci5mcmVxKGZyZXEpO1xuICAqICAgIC8vIGdpdmUgdGhlIGZpbHRlciBhIG5hcnJvdyBiYW5kIChsb3dlciByZXMgPSB3aWRlciBiYW5kcGFzcylcbiAgKiAgICBmaWx0ZXIucmVzKDUwKTtcbiAgKlxuICAqICAgIC8vIGRyYXcgZmlsdGVyZWQgc3BlY3RydW1cbiAgKiAgICBsZXQgc3BlY3RydW0gPSBmZnQuYW5hbHl6ZSgpO1xuICAqICAgIG5vU3Ryb2tlKCk7XG4gICogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjdHJ1bS5sZW5ndGg7IGkrKykge1xuICAqICAgICAgbGV0IHggPSBtYXAoaSwgMCwgc3BlY3RydW0ubGVuZ3RoLCAwLCB3aWR0aCk7XG4gICogICAgICBsZXQgaCA9IC1oZWlnaHQgKyBtYXAoc3BlY3RydW1baV0sIDAsIDI1NSwgaGVpZ2h0LCAwKTtcbiAgKiAgICAgIHJlY3QoeCwgaGVpZ2h0LCB3aWR0aC9zcGVjdHJ1bS5sZW5ndGgsIGgpO1xuICAqICAgIH1cbiAgKiAgICBpZiAoIW5vaXNlLnN0YXJ0ZWQpIHtcbiAgKiAgICAgIHRleHQoJ3RhcCBoZXJlIGFuZCBkcmFnIHRvIGNoYW5nZSBmcmVxdWVuY3knLCAxMCwgMjAsIHdpZHRoIC0gMjApO1xuICAqICAgIH0gZWxzZSB7XG4gICogICAgICB0ZXh0KCdGcmVxdWVuY3k6ICcgKyByb3VuZChmcmVxKSsnSHonLCAyMCwgMjAsIHdpZHRoIC0gMjApO1xuICAqICAgIH1cbiAgKiAgfVxuICAqXG4gICogIGZ1bmN0aW9uIG1ha2VOb2lzZSgpIHtcbiAgKiAgICAvLyBzZWUgYWxzbzogYHVzZXJTdGFydEF1ZGlvKClgXG4gICogICAgbm9pc2Uuc3RhcnQoKTtcbiAgKiAgICBub2lzZS5hbXAoMC41LCAwLjIpO1xuICAqICB9XG4gICpcbiAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgKiAgICBub2lzZS5hbXAoMCwgMC4yKTtcbiAgKiAgfVxuICAqXG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuRmlsdGVyID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBFZmZlY3QuY2FsbCh0aGlzKTsgXG5cbiAgICAvKipcbiAgICAgICogIFRoZSBwNS5GaWx0ZXIgaXMgYnVpbHQgd2l0aCBhXG4gICAgICAqICA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI0JpcXVhZEZpbHRlck5vZGVcIj5cbiAgICAgICogIFdlYiBBdWRpbyBCaXF1YWRGaWx0ZXIgTm9kZTwvYT4uXG4gICAgICAqXG4gICAgICAqICBAcHJvcGVydHkge0RlbGF5Tm9kZX0gYmlxdWFkRmlsdGVyXG4gICAgKi9cblxuICAgIHRoaXMuYmlxdWFkID0gdGhpcy5hYy5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5iaXF1YWQpO1xuICAgIHRoaXMuYmlxdWFkLmNvbm5lY3QodGhpcy53ZXQpO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHRoaXMuc2V0VHlwZSh0eXBlKTtcbiAgICB9IFxuXG5cbiAgICB0aGlzLl9vbiA9IHRydWU7XG4gICAgdGhpcy5fdW50b2dnbGVkVHlwZSA9IHRoaXMuYmlxdWFkLnR5cGU7XG4gIH07XG5cbiAgcDUuRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWZmZWN0LnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiAgRmlsdGVyIGFuIGF1ZGlvIHNpZ25hbCBhY2NvcmRpbmcgdG8gYSBzZXRcbiAgICogIG9mIGZpbHRlciBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcHJvY2Vzc1xuICAgKiAgQHBhcmFtICB7T2JqZWN0fSBTaWduYWwgIEFuIG9iamVjdCB0aGF0IG91dHB1dHMgYXVkaW9cbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbZnJlcV0gRnJlcXVlbmN5IGluIEh6LCBmcm9tIDEwIHRvIDIyMDUwXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3Jlc10gUmVzb25hbmNlL1dpZHRoIG9mIHRoZSBmaWx0ZXIgZnJlcXVlbmN5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAwLjAwMSB0byAxMDAwXG4gICAqL1xuXG4gIHA1LkZpbHRlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIGZyZXEsIHJlcywgdGltZSkge1xuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICAgIHRoaXMuc2V0KGZyZXEsIHJlcywgdGltZSk7XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBmcmVxdWVuY3kgYW5kIHRoZSByZXNvbmFuY2Ugb2YgdGhlIGZpbHRlci5cbiAgICpcbiAgICogIEBtZXRob2QgIHNldFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxXSBGcmVxdWVuY3kgaW4gSHosIGZyb20gMTAgdG8gMjIwNTBcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbcmVzXSAgUmVzb25hbmNlIChRKSBmcm9tIDAuMDAxIHRvIDEwMDBcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgcDUuRmlsdGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZnJlcSwgcmVzLCB0aW1lKSB7XG4gICAgaWYgKGZyZXEpIHtcbiAgICAgIHRoaXMuZnJlcShmcmVxLCB0aW1lKTtcbiAgICB9XG5cbiAgICBpZiAocmVzKSB7XG4gICAgICB0aGlzLnJlcyhyZXMsIHRpbWUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIGZpbHRlciBmcmVxdWVuY3ksIGluIEh6LCBmcm9tIDEwIHRvIDIyMDUwICh0aGUgcmFuZ2Ugb2ZcbiAgICogIGh1bWFuIGhlYXJpbmcsIGFsdGhvdWdoIGluIHJlYWxpdHkgbW9zdCBwZW9wbGUgaGVhciBpbiBhIG5hcnJvd2VyXG4gICAqICByYW5nZSkuXG4gICAqXG4gICAqICBAbWV0aG9kICBmcmVxXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IGZyZXEgRmlsdGVyIEZyZXF1ZW5jeVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gc2NoZWR1bGUgdGhpcyBldmVudCB0byBoYXBwZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgZnJvbSBub3dcbiAgICogIEByZXR1cm4ge051bWJlcn0gdmFsdWUgIFJldHVybnMgdGhlIGN1cnJlbnQgZnJlcXVlbmN5IHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuRmlsdGVyLnByb3RvdHlwZS5mcmVxID0gZnVuY3Rpb24gKGZyZXEsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmIChmcmVxIDw9IDApIHtcbiAgICAgIGZyZXEgPSAxO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZnJlcSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuYmlxdWFkLmZyZXF1ZW5jeS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMuYmlxdWFkLmZyZXF1ZW5jeS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKGZyZXEsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmIChmcmVxKSB7XG4gICAgICBmcmVxLmNvbm5lY3QodGhpcy5iaXF1YWQuZnJlcXVlbmN5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXF1YWQuZnJlcXVlbmN5LnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogIENvbnRyb2xzIGVpdGhlciB3aWR0aCBvZiBhIGJhbmRwYXNzIGZyZXF1ZW5jeSxcbiAgICogIG9yIHRoZSByZXNvbmFuY2Ugb2YgYSBsb3cvaGlnaHBhc3MgY3V0b2ZmIGZyZXF1ZW5jeS5cbiAgICpcbiAgICogIEBtZXRob2QgIHJlc1xuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IHJlcyAgUmVzb25hbmNlL1dpZHRoIG9mIGZpbHRlciBmcmVxXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBmcm9tIDAuMDAxIHRvIDEwMDBcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqICBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzIHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuRmlsdGVyLnByb3RvdHlwZS5yZXMgPSBmdW5jdGlvbiAocmVzLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuYmlxdWFkLlEudmFsdWUgPSByZXM7XG4gICAgICB0aGlzLmJpcXVhZC5RLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5iaXF1YWQuUS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShyZXMsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmIChyZXMpIHtcbiAgICAgIHJlcy5jb25uZWN0KHRoaXMuYmlxdWFkLlEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpcXVhZC5RLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogQ29udHJvbHMgdGhlIGdhaW4gYXR0cmlidXRlIG9mIGEgQmlxdWFkIEZpbHRlci5cbiAgICogVGhpcyBpcyBkaXN0aW5jdGx5IGRpZmZlcmVudCBmcm9tIC5hbXAoKSB3aGljaCBpcyBpbmhlcml0ZWQgZnJvbSBwNS5FZmZlY3RcbiAgICogLmFtcCgpIGNvbnRyb2xzIHRoZSB2b2x1bWUgdmlhIHRoZSBvdXRwdXQgZ2FpbiBub2RlXG4gICAqIHA1LkZpbHRlci5nYWluKCkgY29udHJvbHMgdGhlIGdhaW4gcGFyYW1ldGVyIG9mIGEgQmlxdWFkIEZpbHRlciBub2RlLlxuICAgKlxuICAgKiBAbWV0aG9kIGdhaW5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBnYWluXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgY3VycmVudCBvciB1cGRhdGVkIGdhaW4gdmFsdWVcbiAgICovXG5cblxuICBwNS5GaWx0ZXIucHJvdG90eXBlLmdhaW4gPSBmdW5jdGlvbiAoZ2FpbiwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiBnYWluID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5iaXF1YWQuZ2Fpbi52YWx1ZSA9IGdhaW47XG4gICAgICB0aGlzLmJpcXVhZC5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5iaXF1YWQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShnYWluLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoZ2Fpbikge1xuICAgICAgZ2Fpbi5jb25uZWN0KHRoaXMuYmlxdWFkLmdhaW4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpcXVhZC5nYWluLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogVG9nZ2xlIGZ1bmN0aW9uLiBTd2l0Y2hlcyBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgdHlwZSBhbmQgYWxscGFzc1xuICAgKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBbVG9nZ2xlIHZhbHVlXVxuICAgKi9cblxuXG4gIHA1LkZpbHRlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX29uID0gIXRoaXMuX29uO1xuXG4gICAgaWYgKHRoaXMuX29uID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmJpcXVhZC50eXBlID0gdGhpcy5fdW50b2dnbGVkVHlwZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29uID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5iaXF1YWQudHlwZSA9ICdhbGxwYXNzJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fb247XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSB0eXBlIG9mIGEgcDUuRmlsdGVyLiBQb3NzaWJsZSB0eXBlcyBpbmNsdWRlOlxuICAgKiAgXCJsb3dwYXNzXCIgKGRlZmF1bHQpLCBcImhpZ2hwYXNzXCIsIFwiYmFuZHBhc3NcIixcbiAgICogIFwibG93c2hlbGZcIiwgXCJoaWdoc2hlbGZcIiwgXCJwZWFraW5nXCIsIFwibm90Y2hcIixcbiAgICogIFwiYWxscGFzc1wiLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0VHlwZVxuICAgKiAgQHBhcmFtIHtTdHJpbmd9IHRcbiAgICovXG5cblxuICBwNS5GaWx0ZXIucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbiAodCkge1xuICAgIHRoaXMuYmlxdWFkLnR5cGUgPSB0O1xuICAgIHRoaXMuX3VudG9nZ2xlZFR5cGUgPSB0aGlzLmJpcXVhZC50eXBlO1xuICB9O1xuXG4gIHA1LkZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcyk7XG5cbiAgICBpZiAodGhpcy5iaXF1YWQpIHtcbiAgICAgIHRoaXMuYmlxdWFkLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmJpcXVhZDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgQ29uc3RydWN0b3I6IDxjb2RlPm5ldyBwNS5Mb3dQYXNzKCk8L2NvZGU+IEZpbHRlci5cbiAgICogIFRoaXMgaXMgdGhlIHNhbWUgYXMgY3JlYXRpbmcgYSBwNS5GaWx0ZXIgYW5kIHRoZW4gY2FsbGluZ1xuICAgKiAgaXRzIG1ldGhvZCA8Y29kZT5zZXRUeXBlKCdsb3dwYXNzJyk8L2NvZGU+LlxuICAgKiAgU2VlIHA1LkZpbHRlciBmb3IgbWV0aG9kcy5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5Mb3dQYXNzXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBleHRlbmRzIHA1LkZpbHRlclxuICAgKi9cblxuXG4gIHA1Lkxvd1Bhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcDUuRmlsdGVyLmNhbGwodGhpcywgJ2xvd3Bhc3MnKTtcbiAgfTtcblxuICBwNS5Mb3dQYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocDUuRmlsdGVyLnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiAgQ29uc3RydWN0b3I6IDxjb2RlPm5ldyBwNS5IaWdoUGFzcygpPC9jb2RlPiBGaWx0ZXIuXG4gICAqICBUaGlzIGlzIHRoZSBzYW1lIGFzIGNyZWF0aW5nIGEgcDUuRmlsdGVyIGFuZCB0aGVuIGNhbGxpbmdcbiAgICogIGl0cyBtZXRob2QgPGNvZGU+c2V0VHlwZSgnaGlnaHBhc3MnKTwvY29kZT4uXG4gICAqICBTZWUgcDUuRmlsdGVyIGZvciBtZXRob2RzLlxuICAgKlxuICAgKiAgQGNsYXNzIHA1LkhpZ2hQYXNzXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBleHRlbmRzIHA1LkZpbHRlclxuICAgKi9cblxuICBwNS5IaWdoUGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwNS5GaWx0ZXIuY2FsbCh0aGlzLCAnaGlnaHBhc3MnKTtcbiAgfTtcblxuICBwNS5IaWdoUGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHA1LkZpbHRlci5wcm90b3R5cGUpO1xuICAvKipcbiAgICogIENvbnN0cnVjdG9yOiA8Y29kZT5uZXcgcDUuQmFuZFBhc3MoKTwvY29kZT4gRmlsdGVyLlxuICAgKiAgVGhpcyBpcyB0aGUgc2FtZSBhcyBjcmVhdGluZyBhIHA1LkZpbHRlciBhbmQgdGhlbiBjYWxsaW5nXG4gICAqICBpdHMgbWV0aG9kIDxjb2RlPnNldFR5cGUoJ2JhbmRwYXNzJyk8L2NvZGU+LlxuICAgKiAgU2VlIHA1LkZpbHRlciBmb3IgbWV0aG9kcy5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5CYW5kUGFzc1xuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXh0ZW5kcyBwNS5GaWx0ZXJcbiAgICovXG5cbiAgcDUuQmFuZFBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcDUuRmlsdGVyLmNhbGwodGhpcywgJ2JhbmRwYXNzJyk7XG4gIH07XG5cbiAgcDUuQmFuZFBhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5GaWx0ZXIucHJvdG90eXBlKTtcbiAgcmV0dXJuIHA1LkZpbHRlcjtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXyg3KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLF9fd2VicGFja19yZXF1aXJlX18oOSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihuKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gbi5TdWJ0cmFjdD1mdW5jdGlvbih0KXt0aGlzLmNyZWF0ZUluc091dHMoMiwwKSx0aGlzLl9zdW09dGhpcy5pbnB1dFswXT10aGlzLm91dHB1dD1uZXcgbi5HYWluLHRoaXMuX25lZz1uZXcgbi5OZWdhdGUsdGhpcy5fcGFyYW09dGhpcy5pbnB1dFsxXT1uZXcgbi5TaWduYWwodCksdGhpcy5fcGFyYW0uY2hhaW4odGhpcy5fbmVnLHRoaXMuX3N1bSl9LG4uZXh0ZW5kKG4uU3VidHJhY3Qsbi5TaWduYWwpLG4uU3VidHJhY3QucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gbi5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX25lZy5kaXNwb3NlKCksdGhpcy5fbmVnPW51bGwsdGhpcy5fc3VtLmRpc2Nvbm5lY3QoKSx0aGlzLl9zdW09bnVsbCx0aGlzLl9wYXJhbS5kaXNwb3NlKCksdGhpcy5fcGFyYW09bnVsbCx0aGlzfSxuLlN1YnRyYWN0fSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG5nbG9iYWwuVE9ORV9TSUxFTkNFX1ZFUlNJT05fTE9HR0lORyA9IHRydWU7XG4hKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygzNSksIF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKFN0YXJ0QXVkaW9Db250ZXh0LCBDb250ZXh0LCBUb25lKSB7XG4gIHZhciBhdWRpb2NvbnRleHQgPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpOyBcblxuICBUb25lLmNvbnRleHQuZGlzcG9zZSgpO1xuICBUb25lLnNldENvbnRleHQoYXVkaW9jb250ZXh0KTtcbiAgLyoqXG4gICAqIDxwPlJldHVybnMgdGhlIEF1ZGlvIENvbnRleHQgZm9yIHRoaXMgc2tldGNoLiBVc2VmdWwgZm9yIHVzZXJzXG4gICAqIHdobyB3b3VsZCBsaWtlIHRvIGRpZyBkZWVwZXIgaW50byB0aGUgPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9XG4gICAqICdodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvJz5XZWIgQXVkaW8gQVBJXG4gICAqIDwvYT4uPC9wPlxuICAgKlxuICAgKiA8cD5Tb21lIGJyb3dzZXJzIHJlcXVpcmUgdXNlcnMgdG8gc3RhcnRBdWRpb0NvbnRleHRcbiAgICogd2l0aCBhIHVzZXIgZ2VzdHVyZSwgc3VjaCBhcyB0b3VjaFN0YXJ0ZWQgaW4gdGhlIGV4YW1wbGUgYmVsb3cuPC9wPlxuICAgKlxuICAgKiBAZm9yIHA1XG4gICAqIEBtZXRob2QgZ2V0QXVkaW9Db250ZXh0XG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgQXVkaW9Db250ZXh0IGZvciB0aGlzIHNrZXRjaFxuICAgKiBAZXhhbXBsZVxuICAgKiA8ZGl2Pjxjb2RlPlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyNTUpO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICpcbiAgICogICAgaWYgKGdldEF1ZGlvQ29udGV4dCgpLnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICogICAgICB0ZXh0KCdjbGljayB0byBzdGFydCBhdWRpbycsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICogICAgfSBlbHNlIHtcbiAgICogICAgICB0ZXh0KCdhdWRpbyBpcyBlbmFibGVkJywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiB0b3VjaFN0YXJ0ZWQoKSB7XG4gICAqICAgIGlmIChnZXRBdWRpb0NvbnRleHQoKS5zdGF0ZSAhPT0gJ3J1bm5pbmcnKSB7XG4gICAqICAgICAgZ2V0QXVkaW9Db250ZXh0KCkucmVzdW1lKCk7XG4gICAqICAgIH1cbiAgICogICAgdmFyIHN5bnRoID0gbmV3IHA1Lk1vbm9TeW50aCgpO1xuICAgKiAgICBzeW50aC5wbGF5KCdBNCcsIDAuNSwgMCwgMC4yKTtcbiAgICogIH1cbiAgICpcbiAgICogPC9kaXY+PC9jb2RlPlxuICAgKi9cblxuICBwNS5wcm90b3R5cGUuZ2V0QXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhdWRpb2NvbnRleHQ7XG4gIH07XG4gIC8qKlxuICAgKiAgPHA+SXQgaXMgbm90IG9ubHkgYSBnb29kIHByYWN0aWNlIHRvIGdpdmUgdXNlcnMgY29udHJvbCBvdmVyIHN0YXJ0aW5nXG4gICAqICBhdWRpby4gVGhpcyBwb2xpY3kgaXMgZW5mb3JjZWQgYnkgbWFueSB3ZWIgYnJvd3NlcnMsIGluY2x1ZGluZyBpT1MgYW5kXG4gICAqICA8YSBocmVmPVwiaHR0cHM6Ly9nb28uZ2wvN0s3V0x1XCIgdGl0bGU9XCJHb29nbGUgQ2hyb21lJ3MgYXV0b3BsYXlcbiAgICogIHBvbGljeVwiPkdvb2dsZSBDaHJvbWU8L2E+LCB3aGljaCBjcmVhdGUgdGhlIFdlYiBBdWRpbyBBUEknc1xuICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHRcIlxuICAgKiAgdGl0bGU9XCJBdWRpbyBDb250ZXh0IEAgTUROXCI+QXVkaW8gQ29udGV4dDwvYT5cbiAgICogIGluIGEgc3VzcGVuZGVkIHN0YXRlLjwvcD5cbiAgICpcbiAgICogIDxwPkluIHRoZXNlIGJyb3dzZXItc3BlY2lmaWMgcG9saWNpZXMsIHNvdW5kIHdpbGwgbm90IHBsYXkgdW50aWwgYSB1c2VyXG4gICAqICBpbnRlcmFjdGlvbiBldmVudCAoaS5lLiA8Y29kZT5tb3VzZVByZXNzZWQoKTwvY29kZT4pIGV4cGxpY2l0bHkgcmVzdW1lc1xuICAgKiAgdGhlIEF1ZGlvQ29udGV4dCwgb3Igc3RhcnRzIGFuIGF1ZGlvIG5vZGUuIFRoaXMgY2FuIGJlIGFjY29tcGxpc2hlZCBieVxuICAgKiAgY2FsbGluZyA8Y29kZT5zdGFydCgpPC9jb2RlPiBvbiBhIDxjb2RlPnA1Lk9zY2lsbGF0b3I8L2NvZGU+LFxuICAgKiAgPGNvZGU+IHBsYXkoKTwvY29kZT4gb24gYSA8Y29kZT5wNS5Tb3VuZEZpbGU8L2NvZGU+LCBvciBzaW1wbHlcbiAgICogIDxjb2RlPnVzZXJTdGFydEF1ZGlvKCk8L2NvZGU+LjwvcD5cbiAgICpcbiAgICogIDxwPjxjb2RlPnVzZXJTdGFydEF1ZGlvKCk8L2NvZGU+IHN0YXJ0cyB0aGUgQXVkaW9Db250ZXh0IG9uIGEgdXNlclxuICAgKiAgZ2VzdHVyZS4gVGhlIGRlZmF1bHQgYmVoYXZpb3Igd2lsbCBlbmFibGUgYXVkaW8gb24gYW55XG4gICAqICBtb3VzZVVwIG9yIHRvdWNoRW5kIGV2ZW50LiBJdCBjYW4gYWxzbyBiZSBwbGFjZWQgaW4gYSBzcGVjaWZpY1xuICAgKiAgaW50ZXJhY3Rpb24gZnVuY3Rpb24sIHN1Y2ggYXMgPGNvZGU+bW91c2VQcmVzc2VkKCk8L2NvZGU+IGFzIGluIHRoZVxuICAgKiAgZXhhbXBsZSBiZWxvdy4gVGhpcyBtZXRob2QgdXRpbGl6ZXNcbiAgICogIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vdGFtYmllbi9TdGFydEF1ZGlvQ29udGV4dFwiPlN0YXJ0QXVkaW9Db250ZXh0XG4gICAqICA8L2E+LCBhIGxpYnJhcnkgYnkgWW90YW0gTWFubiAoTUlUIExpY2VuY2UsIDIwMTYpLjwvcD5cbiAgICogIEBwYXJhbSAge0VsZW1lbnR8QXJyYXl9ICAgW2VsZW1lbnQocyldIFRoaXMgYXJndW1lbnQgY2FuIGJlIGFuIEVsZW1lbnQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWxlY3RvciBTdHJpbmcsIE5vZGVMaXN0LCBwNS5FbGVtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5IEVsZW1lbnQsIG9yIGFuIEFycmF5IG9mIGFueSBvZiB0aG9zZS5cbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZSBBdWRpb0NvbnRleHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBzdGFydGVkXG4gICAqICBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBBdWRpb0NvbnRleHQgc3RhdGUgaXMgJ3J1bm5pbmcnXG4gICAqICBAbWV0aG9kIHVzZXJTdGFydEF1ZGlvXG4gICAqICBAZm9yIHA1XG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICAvLyBtaW1pY3MgdGhlIGF1dG9wbGF5IHBvbGljeVxuICAgKiAgICBnZXRBdWRpb0NvbnRleHQoKS5zdXNwZW5kKCk7XG4gICAqXG4gICAqICAgIGxldCBteVN5bnRoID0gbmV3IHA1Lk1vbm9TeW50aCgpO1xuICAgKlxuICAgKiAgICAvLyBUaGlzIHdvbid0IHBsYXkgdW50aWwgdGhlIGNvbnRleHQgaGFzIHJlc3VtZWRcbiAgICogICAgbXlTeW50aC5wbGF5KCdBNicpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSLCBDRU5URVIpO1xuICAgKiAgICB0ZXh0KGdldEF1ZGlvQ29udGV4dCgpLnN0YXRlLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBtb3VzZVByZXNzZWQoKSB7XG4gICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUucHJvdG90eXBlLnVzZXJTdGFydEF1ZGlvID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuICAgIHZhciBlbHQgPSBlbGVtZW50cztcblxuICAgIGlmIChlbGVtZW50cyBpbnN0YW5jZW9mIHA1LkVsZW1lbnQpIHtcbiAgICAgIGVsdCA9IGVsZW1lbnRzLmVsdDtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgQXJyYXkgJiYgZWxlbWVudHNbMF0gaW5zdGFuY2VvZiBwNS5FbGVtZW50KSB7XG4gICAgICBlbHQgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuZWx0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0YXJ0QXVkaW9Db250ZXh0KGF1ZGlvY29udGV4dCwgZWx0LCBjYWxsYmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIGF1ZGlvY29udGV4dDtcbn0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG59LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygzNCkpKVxuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihvKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gby5FbWl0dGVyPWZ1bmN0aW9uKCl7dGhpcy5fZXZlbnRzPXt9fSxvLmV4dGVuZChvLkVtaXR0ZXIpLG8uRW1pdHRlci5wcm90b3R5cGUub249ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9dC5zcGxpdCgvXFxXKy8pLHI9MDtyPGkubGVuZ3RoO3IrKyl7dmFyIG49aVtyXTt0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkobil8fCh0aGlzLl9ldmVudHNbbl09W10pLHRoaXMuX2V2ZW50c1tuXS5wdXNoKGUpfXJldHVybiB0aGlzfSxvLkVtaXR0ZXIucHJvdG90eXBlLm9mZj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgaT10LnNwbGl0KC9cXFcrLykscj0wO3I8aS5sZW5ndGg7cisrKWlmKHQ9aVtyXSx0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkodCkpaWYoby5wcm90b3R5cGUuaXNVbmRlZihlKSl0aGlzLl9ldmVudHNbdF09W107ZWxzZSBmb3IodmFyIG49dGhpcy5fZXZlbnRzW3RdLHM9MDtzPG4ubGVuZ3RoO3MrKyluW3NdPT09ZSYmbi5zcGxpY2UocywxKTtyZXR1cm4gdGhpc30sby5FbWl0dGVyLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQpe2lmKHRoaXMuX2V2ZW50cyl7dmFyIGU9QXJyYXkuYXBwbHkobnVsbCxhcmd1bWVudHMpLnNsaWNlKDEpO2lmKHRoaXMuX2V2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0KSlmb3IodmFyIGk9dGhpcy5fZXZlbnRzW3RdLHI9MCxuPWkubGVuZ3RoO3I8bjtyKyspaVtyXS5hcHBseSh0aGlzLGUpfXJldHVybiB0aGlzfSxvLkVtaXR0ZXIubWl4aW49ZnVuY3Rpb24odCl7dmFyIGU9W1wib25cIixcIm9mZlwiLFwiZW1pdFwiXTt0Ll9ldmVudHM9e307Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciByPWVbaV0sbj1vLkVtaXR0ZXIucHJvdG90eXBlW3JdO3Rbcl09bn19LG8uRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBvLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fZXZlbnRzPW51bGwsdGhpc30sby5FbWl0dGVyfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oYyl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGMuU2lnbmFsQmFzZT1mdW5jdGlvbigpe30sYy5leHRlbmQoYy5TaWduYWxCYXNlKSxjLlNpZ25hbEJhc2UucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oZSxuLGEpe3JldHVybiBjLlNpZ25hbCYmYy5TaWduYWw9PT1lLmNvbnN0cnVjdG9yfHxjLlBhcmFtJiZjLlBhcmFtPT09ZS5jb25zdHJ1Y3Rvcnx8Yy5UaW1lbGluZVNpZ25hbCYmYy5UaW1lbGluZVNpZ25hbD09PWUuY29uc3RydWN0b3I/KGUuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKSxlLl9wYXJhbS52YWx1ZT0wLGUub3ZlcnJpZGRlbj0hMCk6ZSBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0mJihlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKSxlLnZhbHVlPTApLGMucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzLGUsbixhKSx0aGlzfSxjLlNpZ25hbEJhc2V9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyMSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihvKXtyZXR1cm4gby5UaW1lPWZ1bmN0aW9uKHQsZSl7aWYoISh0aGlzIGluc3RhbmNlb2Ygby5UaW1lKSlyZXR1cm4gbmV3IG8uVGltZSh0LGUpO3RoaXMuX3BsdXNOb3c9ITEsby5UaW1lQmFzZS5jYWxsKHRoaXMsdCxlKX0sby5leHRlbmQoby5UaW1lLG8uVGltZUJhc2UpLG8uVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnM9T2JqZWN0LmNyZWF0ZShvLlRpbWVCYXNlLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyksby5UaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucy5xdWFudGl6ZT17cmVnZXhwOi9eQC8sbWV0aG9kOmZ1bmN0aW9uKHQpe3JldHVybiBvLlRyYW5zcG9ydC5uZXh0U3ViZGl2aXNpb24odCgpKX19LG8uVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMubm93PXtyZWdleHA6L15cXCsvLG1ldGhvZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcGx1c05vdz0hMCx0KCl9fSxvLlRpbWUucHJvdG90eXBlLnF1YW50aXplPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU9dGhpcy5kZWZhdWx0QXJnKGUsMSksdGhpcy5fZXhwcj1mdW5jdGlvbih0LGUsbyl7cmV0dXJuIHQ9dCgpLGU9ZS50b1NlY29uZHMoKSx0KyhNYXRoLnJvdW5kKHQvZSkqZS10KSpvfS5iaW5kKHRoaXMsdGhpcy5fZXhwcixuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0KSxlKSx0aGlzfSxvLlRpbWUucHJvdG90eXBlLmFkZE5vdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wbHVzTm93PSEwLHRoaXN9LG8uVGltZS5wcm90b3R5cGUuX2RlZmF1bHRFeHByPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BsdXNOb3c9ITAsdGhpcy5fbm9PcH0sby5UaW1lLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKHQpe3JldHVybiBvLlRpbWVCYXNlLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcyx0KSx0aGlzLl9wbHVzTm93PXQuX3BsdXNOb3csdGhpc30sby5UaW1lLnByb3RvdHlwZS50b05vdGF0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy50b1NlY29uZHMoKSxlPXRoaXMuX3RvTm90YXRpb25IZWxwZXIodCxbXCIxbVwiLFwiMm5cIixcIjRuXCIsXCI4blwiLFwiMTZuXCIsXCIzMm5cIixcIjY0blwiLFwiMTI4blwiXSksbz10aGlzLl90b05vdGF0aW9uSGVscGVyKHQsW1wiMW1cIixcIjJuXCIsXCIydFwiLFwiNG5cIixcIjR0XCIsXCI4blwiLFwiOHRcIixcIjE2blwiLFwiMTZ0XCIsXCIzMm5cIixcIjMydFwiLFwiNjRuXCIsXCI2NHRcIixcIjEyOG5cIl0pO3JldHVybiBvLnNwbGl0KFwiK1wiKS5sZW5ndGg8ZS5zcGxpdChcIitcIikubGVuZ3RoP286ZX0sby5UaW1lLnByb3RvdHlwZS5fdG9Ob3RhdGlvbkhlbHBlcj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbz10aGlzLl9ub3RhdGlvblRvVW5pdHMoZVtlLmxlbmd0aC0xXSksbj1cIlwiLGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIHI9dGhpcy5fbm90YXRpb25Ub1VuaXRzKGVbaV0pLHM9dC9yO2lmKDEtcyUxPDFlLTYmJihzKz0xZS02KSwwPChzPU1hdGguZmxvb3IocykpKXtpZihuKz0xPT09cz9lW2ldOnMudG9TdHJpbmcoKStcIipcIitlW2ldLCh0LT1zKnIpPG8pYnJlYWs7bis9XCIgKyBcIn19cmV0dXJuXCJcIj09PW4mJihuPVwiMFwiKSxufSxvLlRpbWUucHJvdG90eXBlLl9ub3RhdGlvblRvVW5pdHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuX3ByaW1hcnlFeHByZXNzaW9ucyxvPVtlLm4sZS50LGUubV0sbj0wO248by5sZW5ndGg7bisrKXt2YXIgaT1vW25dLHI9dC5tYXRjaChpLnJlZ2V4cCk7aWYocilyZXR1cm4gaS5tZXRob2QuY2FsbCh0aGlzLHJbMV0pfX0sby5UaW1lLnByb3RvdHlwZS50b0JhcnNCZWF0c1NpeHRlZW50aHM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9iZWF0c1RvVW5pdHMoMSksZT10aGlzLnRvU2Vjb25kcygpL3Qsbz1NYXRoLmZsb29yKGUvdGhpcy5fdGltZVNpZ25hdHVyZSgpKSxuPWUlMSo0O3JldHVybiBlPU1hdGguZmxvb3IoZSkldGhpcy5fdGltZVNpZ25hdHVyZSgpLDM8KG49bi50b1N0cmluZygpKS5sZW5ndGgmJihuPXBhcnNlRmxvYXQobikudG9GaXhlZCgzKSksW28sZSxuXS5qb2luKFwiOlwiKX0sby5UaW1lLnByb3RvdHlwZS50b1RpY2tzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fYmVhdHNUb1VuaXRzKDEpLGU9dGhpcy52YWx1ZU9mKCkvdDtyZXR1cm4gTWF0aC5mbG9vcihlKm8uVHJhbnNwb3J0LlBQUSl9LG8uVGltZS5wcm90b3R5cGUudG9TYW1wbGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9TZWNvbmRzKCkqdGhpcy5jb250ZXh0LnNhbXBsZVJhdGV9LG8uVGltZS5wcm90b3R5cGUudG9GcmVxdWVuY3k9ZnVuY3Rpb24oKXtyZXR1cm4gMS90aGlzLnRvU2Vjb25kcygpfSxvLlRpbWUucHJvdG90eXBlLnRvU2Vjb25kcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlT2YoKX0sby5UaW1lLnByb3RvdHlwZS50b01pbGxpc2Vjb25kcz1mdW5jdGlvbigpe3JldHVybiAxZTMqdGhpcy50b1NlY29uZHMoKX0sby5UaW1lLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2V4cHIoKSsodGhpcy5fcGx1c05vdz90aGlzLm5vdygpOjApfSxvLlRpbWV9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihuKXtyZXR1cm4gbi5UaW1lQmFzZT1mdW5jdGlvbihlLHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG4uVGltZUJhc2UpKXJldHVybiBuZXcgbi5UaW1lQmFzZShlLHQpO2lmKHRoaXMuX2V4cHI9dGhpcy5fbm9PcCxlIGluc3RhbmNlb2Ygbi5UaW1lQmFzZSl0aGlzLmNvcHkoZSk7ZWxzZSBpZighdGhpcy5pc1VuZGVmKHQpfHx0aGlzLmlzTnVtYmVyKGUpKXt0PXRoaXMuZGVmYXVsdEFyZyh0LHRoaXMuX2RlZmF1bHRVbml0cyk7dmFyIHI9dGhpcy5fcHJpbWFyeUV4cHJlc3Npb25zW3RdLm1ldGhvZDt0aGlzLl9leHByPXIuYmluZCh0aGlzLGUpfWVsc2UgdGhpcy5pc1N0cmluZyhlKT90aGlzLnNldChlKTp0aGlzLmlzVW5kZWYoZSkmJih0aGlzLl9leHByPXRoaXMuX2RlZmF1bHRFeHByKCkpfSxuLmV4dGVuZChuLlRpbWVCYXNlKSxuLlRpbWVCYXNlLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2V4cHI9dGhpcy5fcGFyc2VFeHByU3RyaW5nKGUpLHRoaXN9LG4uVGltZUJhc2UucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuY29weSh0aGlzKSxlfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGUpe3ZhciB0PWUuX2V4cHIoKTtyZXR1cm4gdGhpcy5zZXQodCl9LG4uVGltZUJhc2UucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnM9e246e3JlZ2V4cDovXihcXGQrKW4vaSxtZXRob2Q6ZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT0oZT1wYXJzZUludChlKSk/dGhpcy5fYmVhdHNUb1VuaXRzKHRoaXMuX3RpbWVTaWduYXR1cmUoKSk6dGhpcy5fYmVhdHNUb1VuaXRzKDQvZSl9fSx0OntyZWdleHA6L14oXFxkKyl0L2ksbWV0aG9kOmZ1bmN0aW9uKGUpe3JldHVybiBlPXBhcnNlSW50KGUpLHRoaXMuX2JlYXRzVG9Vbml0cyg4LygzKnBhcnNlSW50KGUpKSl9fSxtOntyZWdleHA6L14oXFxkKyltL2ksbWV0aG9kOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VJbnQoZSkqdGhpcy5fdGltZVNpZ25hdHVyZSgpKX19LGk6e3JlZ2V4cDovXihcXGQrKWkvaSxtZXRob2Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3RpY2tzVG9Vbml0cyhwYXJzZUludChlKSl9fSxoejp7cmVnZXhwOi9eKFxcZCsoPzpcXC5cXGQrKT8paHovaSxtZXRob2Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2ZyZXF1ZW5jeVRvVW5pdHMocGFyc2VGbG9hdChlKSl9fSx0cjp7cmVnZXhwOi9eKFxcZCsoPzpcXC5cXGQrKT8pOihcXGQrKD86XFwuXFxkKyk/KTo/KFxcZCsoPzpcXC5cXGQrKT8pPy8sbWV0aG9kOmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0wO3JldHVybiBlJiZcIjBcIiE9PWUmJihuKz10aGlzLl9iZWF0c1RvVW5pdHModGhpcy5fdGltZVNpZ25hdHVyZSgpKnBhcnNlRmxvYXQoZSkpKSx0JiZcIjBcIiE9PXQmJihuKz10aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VGbG9hdCh0KSkpLHImJlwiMFwiIT09ciYmKG4rPXRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHIpLzQpKSxufX0sczp7cmVnZXhwOi9eKFxcZCsoPzpcXC5cXGQrKT9zKS8sbWV0aG9kOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9zZWNvbmRzVG9Vbml0cyhwYXJzZUZsb2F0KGUpKX19LHNhbXBsZXM6e3JlZ2V4cDovXihcXGQrKXNhbXBsZXMvLG1ldGhvZDpmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSkvdGhpcy5jb250ZXh0LnNhbXBsZVJhdGV9fSxkZWZhdWx0OntyZWdleHA6L14oXFxkKyg/OlxcLlxcZCspPykvLG1ldGhvZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fcHJpbWFyeUV4cHJlc3Npb25zW3RoaXMuX2RlZmF1bHRVbml0c10ubWV0aG9kLmNhbGwodGhpcyxlKX19fSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fYmluYXJ5RXhwcmVzc2lvbnM9e1wiK1wiOntyZWdleHA6L15cXCsvLHByZWNlZGVuY2U6MixtZXRob2Q6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSgpK3QoKX19LFwiLVwiOntyZWdleHA6L15cXC0vLHByZWNlZGVuY2U6MixtZXRob2Q6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSgpLXQoKX19LFwiKlwiOntyZWdleHA6L15cXCovLHByZWNlZGVuY2U6MSxtZXRob2Q6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSgpKnQoKX19LFwiL1wiOntyZWdleHA6L15cXC8vLHByZWNlZGVuY2U6MSxtZXRob2Q6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSgpL3QoKX19fSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucz17bmVnOntyZWdleHA6L15cXC0vLG1ldGhvZDpmdW5jdGlvbihlKXtyZXR1cm4tZSgpfX19LG4uVGltZUJhc2UucHJvdG90eXBlLl9zeW50YXhHbHVlPXtcIihcIjp7cmVnZXhwOi9eXFwoL30sXCIpXCI6e3JlZ2V4cDovXlxcKS99fSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fdG9rZW5pemU9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PS0xLHI9W107MDxlLmxlbmd0aDspe3ZhciBuPWkoZT1lLnRyaW0oKSx0aGlzKTtyLnB1c2gobiksZT1lLnN1YnN0cihuLnZhbHVlLmxlbmd0aCl9ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgcj1bXCJfYmluYXJ5RXhwcmVzc2lvbnNcIixcIl91bmFyeUV4cHJlc3Npb25zXCIsXCJfcHJpbWFyeUV4cHJlc3Npb25zXCIsXCJfc3ludGF4R2x1ZVwiXSxuPTA7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXRbcltuXV07Zm9yKHZhciBzIGluIGkpe3ZhciBvPWlbc10scD1vLnJlZ2V4cCxhPWUubWF0Y2gocCk7aWYobnVsbCE9PWEpcmV0dXJue21ldGhvZDpvLm1ldGhvZCxwcmVjZWRlbmNlOm8ucHJlY2VkZW5jZSxyZWdleHA6by5yZWdleHAsdmFsdWU6YVswXX19fXRocm93IG5ldyBTeW50YXhFcnJvcihcIlRvbmUuVGltZUJhc2U6IFVuZXhwZWN0ZWQgdG9rZW4gXCIrZSl9cmV0dXJue25leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gclsrK3RdfSxwZWVrOmZ1bmN0aW9uKCl7cmV0dXJuIHJbdCsxXX19fSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fbWF0Y2hHcm91cD1mdW5jdGlvbihlLHQscil7aWYoIXRoaXMuaXNVbmRlZihlKSlmb3IodmFyIG4gaW4gdCl7dmFyIGk9dFtuXTtpZihpLnJlZ2V4cC50ZXN0KGUudmFsdWUpKXtpZih0aGlzLmlzVW5kZWYocikpcmV0dXJuIGk7aWYoaS5wcmVjZWRlbmNlPT09cilyZXR1cm4gaX19cmV0dXJuITF9LG4uVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZUJpbmFyeT1mdW5jdGlvbihlLHQpe3ZhciByO3RoaXMuaXNVbmRlZih0KSYmKHQ9Mikscj10PDA/dGhpcy5fcGFyc2VVbmFyeShlKTp0aGlzLl9wYXJzZUJpbmFyeShlLHQtMSk7Zm9yKHZhciBuPWUucGVlaygpO24mJnRoaXMuX21hdGNoR3JvdXAobix0aGlzLl9iaW5hcnlFeHByZXNzaW9ucyx0KTspcj0obj1lLm5leHQoKSkubWV0aG9kLmJpbmQodGhpcyxyLHRoaXMuX3BhcnNlQmluYXJ5KGUsdC0xKSksbj1lLnBlZWsoKTtyZXR1cm4gcn0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX3BhcnNlVW5hcnk9ZnVuY3Rpb24oZSl7dmFyIHQscjt0PWUucGVlaygpO3ZhciBuPXRoaXMuX21hdGNoR3JvdXAodCx0aGlzLl91bmFyeUV4cHJlc3Npb25zKTtyZXR1cm4gbj8odD1lLm5leHQoKSxyPXRoaXMuX3BhcnNlVW5hcnkoZSksbi5tZXRob2QuYmluZCh0aGlzLHIpKTp0aGlzLl9wYXJzZVByaW1hcnkoZSl9LG4uVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZVByaW1hcnk9ZnVuY3Rpb24oZSl7dmFyIHQscjtpZih0PWUucGVlaygpLHRoaXMuaXNVbmRlZih0KSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUb25lLlRpbWVCYXNlOiBVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uXCIpO2lmKHRoaXMuX21hdGNoR3JvdXAodCx0aGlzLl9wcmltYXJ5RXhwcmVzc2lvbnMpKXt2YXIgbj0odD1lLm5leHQoKSkudmFsdWUubWF0Y2godC5yZWdleHApO3JldHVybiB0Lm1ldGhvZC5iaW5kKHRoaXMsblsxXSxuWzJdLG5bM10pfWlmKHQmJlwiKFwiPT09dC52YWx1ZSl7aWYoZS5uZXh0KCkscj10aGlzLl9wYXJzZUJpbmFyeShlKSwhKHQ9ZS5uZXh0KCkpfHxcIilcIiE9PXQudmFsdWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiRXhwZWN0ZWQgKVwiKTtyZXR1cm4gcn10aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUb25lLlRpbWVCYXNlOiBDYW5ub3QgcHJvY2VzcyB0b2tlbiBcIit0LnZhbHVlKX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX3BhcnNlRXhwclN0cmluZz1mdW5jdGlvbihlKXt0aGlzLmlzU3RyaW5nKGUpfHwoZT1lLnRvU3RyaW5nKCkpO3ZhciB0PXRoaXMuX3Rva2VuaXplKGUpO3JldHVybiB0aGlzLl9wYXJzZUJpbmFyeSh0KX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX25vT3A9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX2RlZmF1bHRFeHByPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25vT3B9LG4uVGltZUJhc2UucHJvdG90eXBlLl9kZWZhdWx0VW5pdHM9XCJzXCIsbi5UaW1lQmFzZS5wcm90b3R5cGUuX2ZyZXF1ZW5jeVRvVW5pdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIDEvZX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cz1mdW5jdGlvbihlKXtyZXR1cm4gNjAvbi5UcmFuc3BvcnQuYnBtLnZhbHVlKmV9LG4uVGltZUJhc2UucHJvdG90eXBlLl9zZWNvbmRzVG9Vbml0cz1mdW5jdGlvbihlKXtyZXR1cm4gZX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX3RpY2tzVG9Vbml0cz1mdW5jdGlvbihlKXtyZXR1cm4gZSoodGhpcy5fYmVhdHNUb1VuaXRzKDEpL24uVHJhbnNwb3J0LlBQUSl9LG4uVGltZUJhc2UucHJvdG90eXBlLl90aW1lU2lnbmF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIG4uVHJhbnNwb3J0LnRpbWVTaWduYXR1cmV9LG4uVGltZUJhc2UucHJvdG90eXBlLl9wdXNoRXhwcj1mdW5jdGlvbihlLHQscil7cmV0dXJuIGUgaW5zdGFuY2VvZiBuLlRpbWVCYXNlfHwoZT1uZXcgdGhpcy5jb25zdHJ1Y3RvcihlLHIpKSx0aGlzLl9leHByPXRoaXMuX2JpbmFyeUV4cHJlc3Npb25zW3RdLm1ldGhvZC5iaW5kKHRoaXMsdGhpcy5fZXhwcixlLl9leHByKSx0aGlzfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fcHVzaEV4cHIoZSxcIitcIix0KX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX3B1c2hFeHByKGUsXCItXCIsdCl9LG4uVGltZUJhc2UucHJvdG90eXBlLm11bHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fcHVzaEV4cHIoZSxcIipcIix0KX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX3B1c2hFeHByKGUsXCIvXCIsdCl9LG4uVGltZUJhc2UucHJvdG90eXBlLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXhwcigpfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fZXhwcj1udWxsfSxuLlRpbWVCYXNlfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oOCldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gYS5QYXJhbT1mdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsW1wicGFyYW1cIixcInVuaXRzXCIsXCJjb252ZXJ0XCJdLGEuUGFyYW0uZGVmYXVsdHMpO3RoaXMuX3BhcmFtPXRoaXMuaW5wdXQ9dC5wYXJhbSx0aGlzLnVuaXRzPXQudW5pdHMsdGhpcy5jb252ZXJ0PXQuY29udmVydCx0aGlzLm92ZXJyaWRkZW49ITEsdGhpcy5fbGZvPW51bGwsdGhpcy5pc09iamVjdCh0Lmxmbyk/dGhpcy52YWx1ZT10Lmxmbzp0aGlzLmlzVW5kZWYodC52YWx1ZSl8fCh0aGlzLnZhbHVlPXQudmFsdWUpfSxhLmV4dGVuZChhLlBhcmFtKSxhLlBhcmFtLmRlZmF1bHRzPXt1bml0czphLlR5cGUuRGVmYXVsdCxjb252ZXJ0OiEwLHBhcmFtOnZvaWQgMH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGEuUGFyYW0ucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RvVW5pdHModGhpcy5fcGFyYW0udmFsdWUpfSxzZXQ6ZnVuY3Rpb24odCl7aWYodGhpcy5pc09iamVjdCh0KSl7aWYodGhpcy5pc1VuZGVmKGEuTEZPKSl0aHJvdyBuZXcgRXJyb3IoXCJJbmNsdWRlICdUb25lLkxGTycgdG8gdXNlIGFuIExGTyBhcyBhIFBhcmFtIHZhbHVlLlwiKTt0aGlzLl9sZm8mJnRoaXMuX2xmby5kaXNwb3NlKCksdGhpcy5fbGZvPW5ldyBhLkxGTyh0KS5zdGFydCgpLHRoaXMuX2xmby5jb25uZWN0KHRoaXMuaW5wdXQpfWVsc2V7dmFyIGU9dGhpcy5fZnJvbVVuaXRzKHQpO3RoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKSx0aGlzLl9wYXJhbS52YWx1ZT1lfX19KSxhLlBhcmFtLnByb3RvdHlwZS5fZnJvbVVuaXRzPWZ1bmN0aW9uKHQpe2lmKCF0aGlzLmNvbnZlcnQmJiF0aGlzLmlzVW5kZWYodGhpcy5jb252ZXJ0KSlyZXR1cm4gdDtzd2l0Y2godGhpcy51bml0cyl7Y2FzZSBhLlR5cGUuVGltZTpyZXR1cm4gdGhpcy50b1NlY29uZHModCk7Y2FzZSBhLlR5cGUuRnJlcXVlbmN5OnJldHVybiB0aGlzLnRvRnJlcXVlbmN5KHQpO2Nhc2UgYS5UeXBlLkRlY2liZWxzOnJldHVybiB0aGlzLmRiVG9HYWluKHQpO2Nhc2UgYS5UeXBlLk5vcm1hbFJhbmdlOnJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0LDApLDEpO2Nhc2UgYS5UeXBlLkF1ZGlvUmFuZ2U6cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHQsLTEpLDEpO2Nhc2UgYS5UeXBlLlBvc2l0aXZlOnJldHVybiBNYXRoLm1heCh0LDApO2RlZmF1bHQ6cmV0dXJuIHR9fSxhLlBhcmFtLnByb3RvdHlwZS5fdG9Vbml0cz1mdW5jdGlvbih0KXtpZighdGhpcy5jb252ZXJ0JiYhdGhpcy5pc1VuZGVmKHRoaXMuY29udmVydCkpcmV0dXJuIHQ7c3dpdGNoKHRoaXMudW5pdHMpe2Nhc2UgYS5UeXBlLkRlY2liZWxzOnJldHVybiB0aGlzLmdhaW5Ub0RiKHQpO2RlZmF1bHQ6cmV0dXJuIHR9fSxhLlBhcmFtLnByb3RvdHlwZS5fbWluT3V0cHV0PTFlLTUsYS5QYXJhbS5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD10aGlzLl9mcm9tVW5pdHModCksKGU9dGhpcy50b1NlY29uZHMoZSkpPD10aGlzLm5vdygpK3RoaXMuYmxvY2tUaW1lP3RoaXMuX3BhcmFtLnZhbHVlPXQ6dGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUodCxlKSx0aGlzfSxhLlBhcmFtLnByb3RvdHlwZS5zZXRSYW1wUG9pbnQ9ZnVuY3Rpb24odCl7dD10aGlzLmRlZmF1bHRBcmcodCx0aGlzLm5vdygpKTt2YXIgZT10aGlzLl9wYXJhbS52YWx1ZTtyZXR1cm4gMD09PWUmJihlPXRoaXMuX21pbk91dHB1dCksdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUoZSx0KSx0aGlzfSxhLlBhcmFtLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZT1mdW5jdGlvbih0LGUpe3JldHVybiB0PXRoaXMuX2Zyb21Vbml0cyh0KSx0aGlzLl9wYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0LHRoaXMudG9TZWNvbmRzKGUpKSx0aGlzfSxhLlBhcmFtLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9dGhpcy5fZnJvbVVuaXRzKHQpLHQ9TWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LHQpLHRoaXMuX3BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodCx0aGlzLnRvU2Vjb25kcyhlKSksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZT1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIGk9dGhpcy50b1NlY29uZHMoaSksdGhpcy5zZXRSYW1wUG9pbnQoaSksdGhpcy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHQsaSt0aGlzLnRvU2Vjb25kcyhlKSksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWU9ZnVuY3Rpb24odCxlLGkpe3JldHVybiBpPXRoaXMudG9TZWNvbmRzKGkpLHRoaXMuc2V0UmFtcFBvaW50KGkpLHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodCxpK3RoaXMudG9TZWNvbmRzKGUpKSx0aGlzfSxhLlBhcmFtLnByb3RvdHlwZS5zZXRUYXJnZXRBdFRpbWU9ZnVuY3Rpb24odCxlLGkpe3JldHVybiB0PXRoaXMuX2Zyb21Vbml0cyh0KSx0PU1hdGgubWF4KHRoaXMuX21pbk91dHB1dCx0KSxpPU1hdGgubWF4KHRoaXMuX21pbk91dHB1dCxpKSx0aGlzLl9wYXJhbS5zZXRUYXJnZXRBdFRpbWUodCx0aGlzLnRvU2Vjb25kcyhlKSxpKSx0aGlzfSxhLlBhcmFtLnByb3RvdHlwZS5zZXRWYWx1ZUN1cnZlQXRUaW1lPWZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIGE9MDthPHQubGVuZ3RoO2ErKyl0W2FdPXRoaXMuX2Zyb21Vbml0cyh0W2FdKTtyZXR1cm4gdGhpcy5fcGFyYW0uc2V0VmFsdWVDdXJ2ZUF0VGltZSh0LHRoaXMudG9TZWNvbmRzKGUpLHRoaXMudG9TZWNvbmRzKGkpKSx0aGlzfSxhLlBhcmFtLnByb3RvdHlwZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLnRvU2Vjb25kcyh0KSksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUucmFtcFRvPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gZT10aGlzLmRlZmF1bHRBcmcoZSwwKSx0aGlzLnVuaXRzPT09YS5UeXBlLkZyZXF1ZW5jeXx8dGhpcy51bml0cz09PWEuVHlwZS5CUE18fHRoaXMudW5pdHM9PT1hLlR5cGUuRGVjaWJlbHM/dGhpcy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlKHQsZSxpKTp0aGlzLmxpbmVhclJhbXBUb1ZhbHVlKHQsZSxpKSx0aGlzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5QYXJhbS5wcm90b3R5cGUsXCJsZm9cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xmb319KSxhLlBhcmFtLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGEucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9wYXJhbT1udWxsLHRoaXMuX2xmbyYmKHRoaXMuX2xmby5kaXNwb3NlKCksdGhpcy5fbGZvPW51bGwpLHRoaXN9LGEuUGFyYW19KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIEFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbiAgdmFyIE11bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4gIHZhciBTY2FsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuICAvKipcbiAgICogIDxwPkNyZWF0ZXMgYSBzaWduYWwgdGhhdCBvc2NpbGxhdGVzIGJldHdlZW4gLTEuMCBhbmQgMS4wLlxuICAgKiAgQnkgZGVmYXVsdCwgdGhlIG9zY2lsbGF0aW9uIHRha2VzIHRoZSBmb3JtIG9mIGEgc2ludXNvaWRhbFxuICAgKiAgc2hhcGUgKCdzaW5lJykuIEFkZGl0aW9uYWwgdHlwZXMgaW5jbHVkZSAndHJpYW5nbGUnLFxuICAgKiAgJ3Nhd3Rvb3RoJyBhbmQgJ3NxdWFyZScuIFRoZSBmcmVxdWVuY3kgZGVmYXVsdHMgdG9cbiAgICogIDQ0MCBvc2NpbGxhdGlvbnMgcGVyIHNlY29uZCAoNDQwSHosIGVxdWFsIHRvIHRoZSBwaXRjaCBvZiBhblxuICAgKiAgJ0EnIG5vdGUpLjwvcD5cbiAgICpcbiAgICogIDxwPlNldCB0aGUgdHlwZSBvZiBvc2NpbGxhdGlvbiB3aXRoIHNldFR5cGUoKSwgb3IgYnkgaW5zdGFudGlhdGluZyBhXG4gICAqICBzcGVjaWZpYyBvc2NpbGxhdG9yOiA8YSBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LlNpbk9zY1wiPnA1LlNpbk9zYzwvYT4sIDxhXG4gICAqICBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LlRyaU9zY1wiPnA1LlRyaU9zYzwvYT4sIDxhXG4gICAqICBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LlNxck9zY1wiPnA1LlNxck9zYzwvYT4sIG9yIDxhXG4gICAqICBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LlNhd09zY1wiPnA1LlNhd09zYzwvYT4uXG4gICAqICA8L3A+XG4gICAqXG4gICAqICBAY2xhc3MgcDUuT3NjaWxsYXRvclxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyZXFdIGZyZXF1ZW5jeSBkZWZhdWx0cyB0byA0NDBIelxuICAgKiAgQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSB0eXBlIG9mIG9zY2lsbGF0b3IuIE9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICdzaW5lJyAoZGVmYXVsdCksICd0cmlhbmdsZScsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICdzYXd0b290aCcsICdzcXVhcmUnXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBvc2MsIHBsYXlpbmcsIGZyZXEsIGFtcDtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5T3NjaWxsYXRvcik7XG4gICAqICAgIG9zYyA9IG5ldyBwNS5Pc2NpbGxhdG9yKCdzaW5lJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMClcbiAgICogICAgZnJlcSA9IGNvbnN0cmFpbihtYXAobW91c2VYLCAwLCB3aWR0aCwgMTAwLCA1MDApLCAxMDAsIDUwMCk7XG4gICAqICAgIGFtcCA9IGNvbnN0cmFpbihtYXAobW91c2VZLCBoZWlnaHQsIDAsIDAsIDEpLCAwLCAxKTtcbiAgICpcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKiAgICB0ZXh0KCdmcmVxOiAnICsgZnJlcSwgMjAsIDQwKTtcbiAgICogICAgdGV4dCgnYW1wOiAnICsgYW1wLCAyMCwgNjApO1xuICAgKlxuICAgKiAgICBpZiAocGxheWluZykge1xuICAgKiAgICAgIC8vIHNtb290aCB0aGUgdHJhbnNpdGlvbnMgYnkgMC4xIHNlY29uZHNcbiAgICogICAgICBvc2MuZnJlcShmcmVxLCAwLjEpO1xuICAgKiAgICAgIG9zYy5hbXAoYW1wLCAwLjEpO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5T3NjaWxsYXRvcigpIHtcbiAgICogICAgLy8gc3RhcnRpbmcgYW4gb3NjaWxsYXRvciBvbiBhIHVzZXIgZ2VzdHVyZSB3aWxsIGVuYWJsZSBhdWRpb1xuICAgKiAgICAvLyBpbiBicm93c2VycyB0aGF0IGhhdmUgYSBzdHJpY3QgYXV0b3BsYXkgcG9saWN5LlxuICAgKiAgICAvLyBTZWUgYWxzbzogdXNlclN0YXJ0QXVkaW8oKTtcbiAgICogICAgb3NjLnN0YXJ0KCk7XG4gICAqICAgIHBsYXlpbmcgPSB0cnVlO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgLy8gcmFtcCBhbXBsaXR1ZGUgdG8gMCBvdmVyIDAuNSBzZWNvbmRzXG4gICAqICAgIG9zYy5hbXAoMCwgMC41KTtcbiAgICogICAgcGxheWluZyA9IGZhbHNlO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPiA8L2Rpdj5cbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yID0gZnVuY3Rpb24gKGZyZXEsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIGZyZXEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZiA9IHR5cGU7XG4gICAgICB0eXBlID0gZnJlcTtcbiAgICAgIGZyZXEgPSBmO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBmID0gdHlwZTtcbiAgICAgIHR5cGUgPSBmcmVxO1xuICAgICAgZnJlcSA9IGY7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7IFxuXG4gICAgdGhpcy5waGFzZUFtb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9zY2lsbGF0b3IgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgdGhpcy5mID0gZnJlcSB8fCA0NDAuMDsgXG5cbiAgICB0aGlzLm9zY2lsbGF0b3IudHlwZSA9IHR5cGUgfHwgJ3NpbmUnO1xuICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUodGhpcy5mLCBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZSk7IFxuXG4gICAgdGhpcy5vdXRwdXQgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5fZnJlcU1vZHMgPSBbXTsgXG5cbiAgICB0aGlzLm91dHB1dC5nYWluLnZhbHVlID0gMC41O1xuICAgIHRoaXMub3V0cHV0LmdhaW4uc2V0VmFsdWVBdFRpbWUoMC41LCBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgdGhpcy5vc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5vdXRwdXQpOyBcblxuICAgIHRoaXMucGFuUG9zaXRpb24gPSAwLjA7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gcDVzb3VuZC5pbnB1dDsgXG5cbiAgICB0aGlzLnBhbm5lciA9IG5ldyBwNS5QYW5uZXIodGhpcy5vdXRwdXQsIHRoaXMuY29ubmVjdGlvbiwgMSk7IFxuXG4gICAgdGhpcy5tYXRoT3BzID0gW3RoaXMub3V0cHV0XTsgXG5cbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqICBTdGFydCBhbiBvc2NpbGxhdG9yLlxuICAgKlxuICAgKiAgU3RhcnRpbmcgYW4gb3NjaWxsYXRvciBvbiBhIHVzZXIgZ2VzdHVyZSB3aWxsIGVuYWJsZSBhdWRpbyBpbiBicm93c2Vyc1xuICAgKiAgdGhhdCBoYXZlIGEgc3RyaWN0IGF1dG9wbGF5IHBvbGljeSwgaW5jbHVkaW5nIENocm9tZSBhbmQgbW9zdCBtb2JpbGVcbiAgICogIGRldmljZXMuIFNlZSBhbHNvOiBgdXNlclN0YXJ0QXVkaW8oKWAuXG4gICAqXG4gICAqICBAbWV0aG9kICBzdGFydFxuICAgKiAgQGZvciBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt0aW1lXSBzdGFydFRpbWUgaW4gc2Vjb25kcyBmcm9tIG5vdy5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW2ZyZXF1ZW5jeV0gZnJlcXVlbmN5IGluIEh6LlxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIGYpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLnN0b3Aobm93KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgdmFyIGZyZXEgPSBmIHx8IHRoaXMuZjtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5vc2NpbGxhdG9yLnR5cGU7IFxuXG4gICAgICBpZiAodGhpcy5vc2NpbGxhdG9yKSB7XG4gICAgICAgIHRoaXMub3NjaWxsYXRvci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9zY2lsbGF0b3I7XG4gICAgICB9IFxuXG5cbiAgICAgIHRoaXMub3NjaWxsYXRvciA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWUgPSBNYXRoLmFicyhmcmVxKTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci50eXBlID0gdHlwZTsgXG5cbiAgICAgIHRoaXMub3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICAgIHRpbWUgPSB0aW1lIHx8IDA7XG4gICAgICB0aGlzLm9zY2lsbGF0b3Iuc3RhcnQodGltZSArIHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgIHRoaXMuZnJlcU5vZGUgPSB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5OyBcblxuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9mcmVxTW9kcykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ZyZXFNb2RzW2ldLmNvbm5lY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy5fZnJlcU1vZHNbaV0uY29ubmVjdCh0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTdG9wIGFuIG9zY2lsbGF0b3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyXG4gICAqICB0byBkZXRlcm1pbmUgaG93IGxvbmcgKGluIHNlY29uZHMgZnJvbSBub3cpIHVudGlsIHRoZVxuICAgKiAgb3NjaWxsYXRvciBzdG9wcy5cbiAgICpcbiAgICogIEBtZXRob2QgIHN0b3BcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBzZWNvbmRzRnJvbU5vdyBUaW1lLCBpbiBzZWNvbmRzIGZyb20gbm93LlxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHZhciB0ID0gdGltZSB8fCAwO1xuICAgICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLnN0b3AodCArIG5vdyk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBhbXBsaXR1ZGUgYmV0d2VlbiAwIGFuZCAxLjAuIE9yLCBwYXNzIGluIGFuIG9iamVjdFxuICAgKiAgc3VjaCBhcyBhbiBvc2NpbGxhdG9yIHRvIG1vZHVsYXRlIGFtcGxpdHVkZSB3aXRoIGFuIGF1ZGlvIHNpZ25hbC5cbiAgICpcbiAgICogIEBtZXRob2QgIGFtcFxuICAgKiAgQGZvciBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ8T2JqZWN0fSB2b2wgYmV0d2VlbiAwIGFuZCAxLjBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIG1vZHVsYXRpbmcgc2lnbmFsL29zY2lsbGF0b3JcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbcmFtcFRpbWVdIGNyZWF0ZSBhIGZhZGUgdGhhdCBsYXN0cyByYW1wVGltZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gc2NoZWR1bGUgdGhpcyBldmVudCB0byBoYXBwZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgZnJvbSBub3dcbiAgICogIEByZXR1cm4gIHtBdWRpb1BhcmFtfSBnYWluICBJZiBubyB2YWx1ZSBpcyBwcm92aWRlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5zIHRoZSBXZWIgQXVkaW8gQVBJXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXVkaW9QYXJhbSB0aGF0IGNvbnRyb2xzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBvc2NpbGxhdG9yJ3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYWluL2FtcGxpdHVkZS92b2x1bWUpXG4gICAqL1xuXG5cbiAgcDUuT3NjaWxsYXRvci5wcm90b3R5cGUuYW1wID0gZnVuY3Rpb24gKHZvbCwgcmFtcFRpbWUsIHRGcm9tTm93KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiB2b2wgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgcmFtcFRpbWUgPSByYW1wVGltZSB8fCAwO1xuICAgICAgdmFyIHRGcm9tTm93ID0gdEZyb21Ob3cgfHwgMDtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMub3V0cHV0LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodm9sLCBub3cgKyB0RnJvbU5vdyArIHJhbXBUaW1lKTtcbiAgICB9IGVsc2UgaWYgKHZvbCkge1xuICAgICAgdm9sLmNvbm5lY3Qoc2VsZi5vdXRwdXQuZ2Fpbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dC5nYWluO1xuICAgIH1cbiAgfTsgXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5mYWRlID0gcDUuT3NjaWxsYXRvci5wcm90b3R5cGUuYW1wO1xuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmdldEFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgZnJlcXVlbmN5IG9mIGFuIG9zY2lsbGF0b3IgdG8gYSB2YWx1ZS4gT3IsIHBhc3MgaW4gYW4gb2JqZWN0XG4gICAqICBzdWNoIGFzIGFuIG9zY2lsbGF0b3IgdG8gbW9kdWxhdGUgdGhlIGZyZXF1ZW5jeSB3aXRoIGFuIGF1ZGlvIHNpZ25hbC5cbiAgICpcbiAgICogIEBtZXRob2QgIGZyZXFcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtICB7TnVtYmVyfE9iamVjdH0gRnJlcXVlbmN5IEZyZXF1ZW5jeSBpbiBIelxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBtb2R1bGF0aW5nIHNpZ25hbC9vc2NpbGxhdG9yXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtyYW1wVGltZV0gUmFtcCB0aW1lIChpbiBzZWNvbmRzKVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIFNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdCB4IHNlY29uZHMgZnJvbSBub3dcbiAgICogIEByZXR1cm4gIHtBdWRpb1BhcmFtfSBGcmVxdWVuY3kgSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgdGhlIFdlYiBBdWRpbyBBUElcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXVkaW9QYXJhbSB0aGF0IGNvbnRyb2xzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgb3NjaWxsYXRvcidzIGZyZXF1ZW5jeVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgb3NjO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlPc2NpbGxhdG9yKTtcbiAgICogICAgb3NjID0gbmV3IHA1Lk9zY2lsbGF0b3IoMzAwKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5T3NjaWxsYXRvcigpIHtcbiAgICogICAgb3NjLnN0YXJ0KCk7XG4gICAqICAgIG9zYy5hbXAoMC41KTtcbiAgICogICAgLy8gc3RhcnQgYXQgNzAwSHpcbiAgICogICAgb3NjLmZyZXEoNzAwKTtcbiAgICogICAgLy8gcmFtcCB0byA2MEh6IG92ZXIgMC43IHNlY29uZHNcbiAgICogICAgb3NjLmZyZXEoNjAsIDAuNyk7XG4gICAqICAgIG9zYy5hbXAoMCwgMC4xLCAwLjcpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmZyZXEgPSBmdW5jdGlvbiAodmFsLCByYW1wVGltZSwgdEZyb21Ob3cpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgIHRoaXMuZiA9IHZhbDtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHZhciByYW1wVGltZSA9IHJhbXBUaW1lIHx8IDA7XG4gICAgICB2YXIgdEZyb21Ob3cgPSB0RnJvbU5vdyB8fCAwO1xuICAgICAgdmFyIHQgPSBub3cgKyB0RnJvbU5vdyArIHJhbXBUaW1lOyBcblxuICAgICAgaWYgKHJhbXBUaW1lID09PSAwKSB7XG4gICAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUodmFsLCB0RnJvbU5vdyArIG5vdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWwsIHRGcm9tTm93ICsgcmFtcFRpbWUgKyBub3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsLCB0RnJvbU5vdyArIHJhbXBUaW1lICsgbm93KTtcbiAgICAgICAgfVxuICAgICAgfSBcblxuXG4gICAgICBpZiAodGhpcy5waGFzZUFtb3VudCkge1xuICAgICAgICB0aGlzLnBoYXNlKHRoaXMucGhhc2VBbW91bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsKSB7XG4gICAgICBpZiAodmFsLm91dHB1dCkge1xuICAgICAgICB2YWwgPSB2YWwub3V0cHV0O1xuICAgICAgfVxuXG4gICAgICB2YWwuY29ubmVjdCh0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5KTsgXG5cbiAgICAgIHRoaXMuX2ZyZXFNb2RzLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3k7XG4gICAgfVxuICB9O1xuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmdldEZyZXEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHR5cGUgdG8gJ3NpbmUnLCAndHJpYW5nbGUnLCAnc2F3dG9vdGgnIG9yICdzcXVhcmUnLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0VHlwZVxuICAgKiAgQGZvciBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSAnc2luZScsICd0cmlhbmdsZScsICdzYXd0b290aCcgb3IgJ3NxdWFyZScuXG4gICAqL1xuXG5cbiAgcDUuT3NjaWxsYXRvci5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGhpcy5vc2NpbGxhdG9yLnR5cGUgPSB0eXBlO1xuICB9O1xuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3NjaWxsYXRvci50eXBlO1xuICB9O1xuICAvKipcbiAgICogIENvbm5lY3QgdG8gYSBwNS5zb3VuZCAvIFdlYiBBdWRpbyBvYmplY3QuXG4gICAqXG4gICAqICBAbWV0aG9kICBjb25uZWN0XG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBwYXJhbSAge09iamVjdH0gdW5pdCBBIHA1LnNvdW5kIG9yIFdlYiBBdWRpbyBvYmplY3RcbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICBpZiAoIXVuaXQpIHtcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QocDVzb3VuZC5pbnB1dCk7XG4gICAgfSBlbHNlIGlmICh1bml0Lmhhc093blByb3BlcnR5KCdpbnB1dCcpKSB7XG4gICAgICB0aGlzLnBhbm5lci5jb25uZWN0KHVuaXQuaW5wdXQpO1xuICAgICAgdGhpcy5jb25uZWN0aW9uID0gdW5pdC5pbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh1bml0KTtcbiAgICAgIHRoaXMuY29ubmVjdGlvbiA9IHVuaXQ7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIERpc2Nvbm5lY3QgYWxsIG91dHB1dHNcbiAgICpcbiAgICogIEBtZXRob2QgIGRpc2Nvbm5lY3RcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFubmVyKSB7XG4gICAgICB0aGlzLnBhbm5lci5kaXNjb25uZWN0KCk7XG5cbiAgICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgICB0aGlzLm91dHB1dC5jb25uZWN0KHRoaXMucGFubmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9zY01vZHMgPSBbXTtcbiAgfTtcbiAgLyoqXG4gICAqICBQYW4gYmV0d2VlbiBMZWZ0ICgtMSkgYW5kIFJpZ2h0ICgxKVxuICAgKlxuICAgKiAgQG1ldGhvZCAgcGFuXG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBwYXJhbSAge051bWJlcn0gcGFubmluZyBOdW1iZXIgYmV0d2VlbiAtMSBhbmQgMVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSB0aW1lRnJvbU5vdyBzY2hlZHVsZSB0aGlzIGV2ZW50IHRvIGhhcHBlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyBmcm9tIG5vd1xuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLnBhbiA9IGZ1bmN0aW9uIChwdmFsLCB0RnJvbU5vdykge1xuICAgIHRoaXMucGFuUG9zaXRpb24gPSBwdmFsO1xuICAgIHRoaXMucGFubmVyLnBhbihwdmFsLCB0RnJvbU5vdyk7XG4gIH07XG5cbiAgcDUuT3NjaWxsYXRvci5wcm90b3R5cGUuZ2V0UGFuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhblBvc2l0aW9uO1xuICB9OyBcblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gcDVzb3VuZC5zb3VuZEFycmF5LmluZGV4T2YodGhpcyk7XG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBpZiAodGhpcy5vc2NpbGxhdG9yKSB7XG4gICAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLnN0b3Aobm93KTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5wYW5uZXIgPSBudWxsO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbnVsbDtcbiAgICB9IFxuXG5cbiAgICBpZiAodGhpcy5vc2MyKSB7XG4gICAgICB0aGlzLm9zYzIuZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIHBoYXNlIG9mIGFuIG9zY2lsbGF0b3IgYmV0d2VlbiAwLjAgYW5kIDEuMC5cbiAgICogIEluIHRoaXMgaW1wbGVtZW50YXRpb24sIHBoYXNlIGlzIGEgZGVsYXkgdGltZVxuICAgKiAgYmFzZWQgb24gdGhlIG9zY2lsbGF0b3IncyBjdXJyZW50IGZyZXF1ZW5jeS5cbiAgICpcbiAgICogIEBtZXRob2QgIHBoYXNlXG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBwYXJhbSAge051bWJlcn0gcGhhc2UgZmxvYXQgYmV0d2VlbiAwLjAgYW5kIDEuMFxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLnBoYXNlID0gZnVuY3Rpb24gKHApIHtcbiAgICB2YXIgZGVsYXlBbXQgPSBwNS5wcm90b3R5cGUubWFwKHAsIDAsIDEuMCwgMCwgMSAvIHRoaXMuZik7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHRoaXMucGhhc2VBbW91bnQgPSBwO1xuXG4gICAgaWYgKCF0aGlzLmROb2RlKSB7XG4gICAgICB0aGlzLmROb2RlID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlRGVsYXkoKTsgXG5cbiAgICAgIHRoaXMub3NjaWxsYXRvci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLm9zY2lsbGF0b3IuY29ubmVjdCh0aGlzLmROb2RlKTtcbiAgICAgIHRoaXMuZE5vZGUuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgfSBcblxuXG4gICAgdGhpcy5kTm9kZS5kZWxheVRpbWUuc2V0VmFsdWVBdFRpbWUoZGVsYXlBbXQsIG5vdyk7XG4gIH07IFxuXG5cbiAgdmFyIHNpZ0NoYWluID0gZnVuY3Rpb24gc2lnQ2hhaW4obywgbWF0aE9iaiwgdGhpc0NoYWluLCBuZXh0Q2hhaW4sIHR5cGUpIHtcbiAgICB2YXIgY2hhaW5Tb3VyY2UgPSBvLm9zY2lsbGF0b3I7IFxuXG4gICAgZm9yICh2YXIgaSBpbiBvLm1hdGhPcHMpIHtcbiAgICAgIGlmIChvLm1hdGhPcHNbaV0gaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgICAgIGNoYWluU291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgby5tYXRoT3BzW2ldLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpc0NoYWluID0gaTsgXG5cbiAgICAgICAgaWYgKHRoaXNDaGFpbiA8IG8ubWF0aE9wcy5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgbmV4dENoYWluID0gby5tYXRoT3BzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzQ2hhaW4gPT09IG8ubWF0aE9wcy5sZW5ndGggLSAxKSB7XG4gICAgICBvLm1hdGhPcHMucHVzaChuZXh0Q2hhaW4pO1xuICAgIH0gXG5cblxuICAgIGlmIChpID4gMCkge1xuICAgICAgY2hhaW5Tb3VyY2UgPSBvLm1hdGhPcHNbaSAtIDFdO1xuICAgIH1cblxuICAgIGNoYWluU291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICBjaGFpblNvdXJjZS5jb25uZWN0KG1hdGhPYmopO1xuICAgIG1hdGhPYmouY29ubmVjdChuZXh0Q2hhaW4pO1xuICAgIG8ubWF0aE9wc1t0aGlzQ2hhaW5dID0gbWF0aE9iajtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgLyoqXG4gICAqICBBZGQgYSB2YWx1ZSB0byB0aGUgcDUuT3NjaWxsYXRvcidzIG91dHB1dCBhbXBsaXR1ZGUsXG4gICAqICBhbmQgcmV0dXJuIHRoZSBvc2NpbGxhdG9yLiBDYWxsaW5nIHRoaXMgbWV0aG9kIGFnYWluXG4gICAqICB3aWxsIG92ZXJyaWRlIHRoZSBpbml0aWFsIGFkZCgpIHdpdGggYSBuZXcgdmFsdWUuXG4gICAqXG4gICAqICBAbWV0aG9kICBhZGRcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBDb25zdGFudCBudW1iZXIgdG8gYWRkXG4gICAqICBAcmV0dXJuIHtwNS5Pc2NpbGxhdG9yfSBPc2NpbGxhdG9yIFJldHVybnMgdGhpcyBvc2NpbGxhdG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggc2NhbGVkIG91dHB1dFxuICAgKlxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB2YXIgYWRkID0gbmV3IEFkZChudW0pO1xuICAgIHZhciB0aGlzQ2hhaW4gPSB0aGlzLm1hdGhPcHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV4dENoYWluID0gdGhpcy5vdXRwdXQ7XG4gICAgcmV0dXJuIHNpZ0NoYWluKHRoaXMsIGFkZCwgdGhpc0NoYWluLCBuZXh0Q2hhaW4sIEFkZCk7XG4gIH07XG4gIC8qKlxuICAgKiAgTXVsdGlwbHkgdGhlIHA1Lk9zY2lsbGF0b3IncyBvdXRwdXQgYW1wbGl0dWRlXG4gICAqICBieSBhIGZpeGVkIHZhbHVlIChpLmUuIHR1cm4gaXQgdXAhKS4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiAgYWdhaW4gd2lsbCBvdmVycmlkZSB0aGUgaW5pdGlhbCBtdWx0KCkgd2l0aCBhIG5ldyB2YWx1ZS5cbiAgICpcbiAgICogIEBtZXRob2QgIG11bHRcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBDb25zdGFudCBudW1iZXIgdG8gbXVsdGlwbHlcbiAgICogIEByZXR1cm4ge3A1Lk9zY2lsbGF0b3J9IE9zY2lsbGF0b3IgUmV0dXJucyB0aGlzIG9zY2lsbGF0b3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBtdWx0aXBsaWVkIG91dHB1dFxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLm11bHQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdmFyIG11bHQgPSBuZXcgTXVsdChudW0pO1xuICAgIHZhciB0aGlzQ2hhaW4gPSB0aGlzLm1hdGhPcHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV4dENoYWluID0gdGhpcy5vdXRwdXQ7XG4gICAgcmV0dXJuIHNpZ0NoYWluKHRoaXMsIG11bHQsIHRoaXNDaGFpbiwgbmV4dENoYWluLCBNdWx0KTtcbiAgfTtcbiAgLyoqXG4gICAqICBTY2FsZSB0aGlzIG9zY2lsbGF0b3IncyBhbXBsaXR1ZGUgdmFsdWVzIHRvIGEgZ2l2ZW5cbiAgICogIHJhbmdlLCBhbmQgcmV0dXJuIHRoZSBvc2NpbGxhdG9yLiBDYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqICBhZ2FpbiB3aWxsIG92ZXJyaWRlIHRoZSBpbml0aWFsIHNjYWxlKCkgd2l0aCBuZXcgdmFsdWVzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2NhbGVcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBpbk1pbiAgaW5wdXQgcmFuZ2UgbWludW11bVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBpbk1heCAgaW5wdXQgcmFuZ2UgbWF4aW11bVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBvdXRNaW4gaW5wdXQgcmFuZ2UgbWludW11bVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBvdXRNYXggaW5wdXQgcmFuZ2UgbWF4aW11bVxuICAgKiAgQHJldHVybiB7cDUuT3NjaWxsYXRvcn0gT3NjaWxsYXRvciBSZXR1cm5zIHRoaXMgb3NjaWxsYXRvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHNjYWxlZCBvdXRwdXRcbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4KSB7XG4gICAgdmFyIG1hcE91dE1pbiwgbWFwT3V0TWF4O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIG1hcE91dE1pbiA9IHA1LnByb3RvdHlwZS5tYXAob3V0TWluLCBpbk1pbiwgaW5NYXgsIDAsIDEpIC0gMC41O1xuICAgICAgbWFwT3V0TWF4ID0gcDUucHJvdG90eXBlLm1hcChvdXRNYXgsIGluTWluLCBpbk1heCwgMCwgMSkgLSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcE91dE1pbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIG1hcE91dE1heCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGUgPSBuZXcgU2NhbGUobWFwT3V0TWluLCBtYXBPdXRNYXgpO1xuICAgIHZhciB0aGlzQ2hhaW4gPSB0aGlzLm1hdGhPcHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV4dENoYWluID0gdGhpcy5vdXRwdXQ7XG4gICAgcmV0dXJuIHNpZ0NoYWluKHRoaXMsIHNjYWxlLCB0aGlzQ2hhaW4sIG5leHRDaGFpbiwgU2NhbGUpOyBcbiAgfTsgXG5cbiAgLyoqXG4gICAqICBDb25zdHJ1Y3RvcjogPGNvZGU+bmV3IHA1LlNpbk9zYygpPC9jb2RlPi5cbiAgICogIFRoaXMgY3JlYXRlcyBhIFNpbmUgV2F2ZSBPc2NpbGxhdG9yIGFuZCBpc1xuICAgKiAgZXF1aXZhbGVudCB0byA8Y29kZT4gbmV3IHA1Lk9zY2lsbGF0b3IoJ3NpbmUnKVxuICAgKiAgPC9jb2RlPiBvciBjcmVhdGluZyBhIHA1Lk9zY2lsbGF0b3IgYW5kIHRoZW4gY2FsbGluZ1xuICAgKiAgaXRzIG1ldGhvZCA8Y29kZT5zZXRUeXBlKCdzaW5lJyk8L2NvZGU+LlxuICAgKiAgU2VlIHA1Lk9zY2lsbGF0b3IgZm9yIG1ldGhvZHMuXG4gICAqXG4gICAqICBAY2xhc3MgIHA1LlNpbk9zY1xuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXh0ZW5kcyBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyZXFdIFNldCB0aGUgZnJlcXVlbmN5XG4gICAqL1xuXG5cbiAgcDUuU2luT3NjID0gZnVuY3Rpb24gKGZyZXEpIHtcbiAgICBwNS5Pc2NpbGxhdG9yLmNhbGwodGhpcywgZnJlcSwgJ3NpbmUnKTtcbiAgfTtcblxuICBwNS5TaW5Pc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiAgQ29uc3RydWN0b3I6IDxjb2RlPm5ldyBwNS5UcmlPc2MoKTwvY29kZT4uXG4gICAqICBUaGlzIGNyZWF0ZXMgYSBUcmlhbmdsZSBXYXZlIE9zY2lsbGF0b3IgYW5kIGlzXG4gICAqICBlcXVpdmFsZW50IHRvIDxjb2RlPm5ldyBwNS5Pc2NpbGxhdG9yKCd0cmlhbmdsZScpXG4gICAqICA8L2NvZGU+IG9yIGNyZWF0aW5nIGEgcDUuT3NjaWxsYXRvciBhbmQgdGhlbiBjYWxsaW5nXG4gICAqICBpdHMgbWV0aG9kIDxjb2RlPnNldFR5cGUoJ3RyaWFuZ2xlJyk8L2NvZGU+LlxuICAgKiAgU2VlIHA1Lk9zY2lsbGF0b3IgZm9yIG1ldGhvZHMuXG4gICAqXG4gICAqICBAY2xhc3MgIHA1LlRyaU9zY1xuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXh0ZW5kcyBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyZXFdIFNldCB0aGUgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHA1LlRyaU9zYyA9IGZ1bmN0aW9uIChmcmVxKSB7XG4gICAgcDUuT3NjaWxsYXRvci5jYWxsKHRoaXMsIGZyZXEsICd0cmlhbmdsZScpO1xuICB9O1xuXG4gIHA1LlRyaU9zYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqICBDb25zdHJ1Y3RvcjogPGNvZGU+bmV3IHA1LlNhd09zYygpPC9jb2RlPi5cbiAgICogIFRoaXMgY3JlYXRlcyBhIFNhd1Rvb3RoIFdhdmUgT3NjaWxsYXRvciBhbmQgaXNcbiAgICogIGVxdWl2YWxlbnQgdG8gPGNvZGU+IG5ldyBwNS5Pc2NpbGxhdG9yKCdzYXd0b290aCcpXG4gICAqICA8L2NvZGU+IG9yIGNyZWF0aW5nIGEgcDUuT3NjaWxsYXRvciBhbmQgdGhlbiBjYWxsaW5nXG4gICAqICBpdHMgbWV0aG9kIDxjb2RlPnNldFR5cGUoJ3Nhd3Rvb3RoJyk8L2NvZGU+LlxuICAgKiAgU2VlIHA1Lk9zY2lsbGF0b3IgZm9yIG1ldGhvZHMuXG4gICAqXG4gICAqICBAY2xhc3MgIHA1LlNhd09zY1xuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXh0ZW5kcyBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyZXFdIFNldCB0aGUgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHA1LlNhd09zYyA9IGZ1bmN0aW9uIChmcmVxKSB7XG4gICAgcDUuT3NjaWxsYXRvci5jYWxsKHRoaXMsIGZyZXEsICdzYXd0b290aCcpO1xuICB9O1xuXG4gIHA1LlNhd09zYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqICBDb25zdHJ1Y3RvcjogPGNvZGU+bmV3IHA1LlNxck9zYygpPC9jb2RlPi5cbiAgICogIFRoaXMgY3JlYXRlcyBhIFNxdWFyZSBXYXZlIE9zY2lsbGF0b3IgYW5kIGlzXG4gICAqICBlcXVpdmFsZW50IHRvIDxjb2RlPiBuZXcgcDUuT3NjaWxsYXRvcignc3F1YXJlJylcbiAgICogIDwvY29kZT4gb3IgY3JlYXRpbmcgYSBwNS5Pc2NpbGxhdG9yIGFuZCB0aGVuIGNhbGxpbmdcbiAgICogIGl0cyBtZXRob2QgPGNvZGU+c2V0VHlwZSgnc3F1YXJlJyk8L2NvZGU+LlxuICAgKiAgU2VlIHA1Lk9zY2lsbGF0b3IgZm9yIG1ldGhvZHMuXG4gICAqXG4gICAqICBAY2xhc3MgIHA1LlNxck9zY1xuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXh0ZW5kcyBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyZXFdIFNldCB0aGUgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHA1LlNxck9zYyA9IGZ1bmN0aW9uIChmcmVxKSB7XG4gICAgcDUuT3NjaWxsYXRvci5jYWxsKHRoaXMsIGZyZXEsICdzcXVhcmUnKTtcbiAgfTtcblxuICBwNS5TcXJPc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZSk7XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oOCldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihpKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gaS5UaW1lbGluZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsW1wibWVtb3J5XCJdLGkuVGltZWxpbmUuZGVmYXVsdHMpO3RoaXMuX3RpbWVsaW5lPVtdLHRoaXMuX3RvUmVtb3ZlPVtdLHRoaXMuX2l0ZXJhdGluZz0hMSx0aGlzLm1lbW9yeT1lLm1lbW9yeX0saS5leHRlbmQoaS5UaW1lbGluZSksaS5UaW1lbGluZS5kZWZhdWx0cz17bWVtb3J5OjEvMH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGkuVGltZWxpbmUucHJvdG90eXBlLFwibGVuZ3RoXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90aW1lbGluZS5sZW5ndGh9fSksaS5UaW1lbGluZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUpe2lmKHRoaXMuaXNVbmRlZihlLnRpbWUpKXRocm93IG5ldyBFcnJvcihcIlRvbmUuVGltZWxpbmU6IGV2ZW50cyBtdXN0IGhhdmUgYSB0aW1lIGF0dHJpYnV0ZVwiKTtpZih0aGlzLl90aW1lbGluZS5sZW5ndGgpe3ZhciBpPXRoaXMuX3NlYXJjaChlLnRpbWUpO3RoaXMuX3RpbWVsaW5lLnNwbGljZShpKzEsMCxlKX1lbHNlIHRoaXMuX3RpbWVsaW5lLnB1c2goZSk7aWYodGhpcy5sZW5ndGg+dGhpcy5tZW1vcnkpe3ZhciB0PXRoaXMubGVuZ3RoLXRoaXMubWVtb3J5O3RoaXMuX3RpbWVsaW5lLnNwbGljZSgwLHQpfXJldHVybiB0aGlzfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oZSl7aWYodGhpcy5faXRlcmF0aW5nKXRoaXMuX3RvUmVtb3ZlLnB1c2goZSk7ZWxzZXt2YXIgaT10aGlzLl90aW1lbGluZS5pbmRleE9mKGUpOy0xIT09aSYmdGhpcy5fdGltZWxpbmUuc3BsaWNlKGksMSl9cmV0dXJuIHRoaXN9LGkuVGltZWxpbmUucHJvdG90eXBlLmdldD1mdW5jdGlvbihlKXt2YXIgaT10aGlzLl9zZWFyY2goZSk7cmV0dXJuLTEhPT1pP3RoaXMuX3RpbWVsaW5lW2ldOm51bGx9LGkuVGltZWxpbmUucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGltZWxpbmVbMF19LGkuVGltZWxpbmUucHJvdG90eXBlLnNoaWZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RpbWVsaW5lLnNoaWZ0KCl9LGkuVGltZWxpbmUucHJvdG90eXBlLmdldEFmdGVyPWZ1bmN0aW9uKGUpe3ZhciBpPXRoaXMuX3NlYXJjaChlKTtyZXR1cm4gaSsxPHRoaXMuX3RpbWVsaW5lLmxlbmd0aD90aGlzLl90aW1lbGluZVtpKzFdOm51bGx9LGkuVGltZWxpbmUucHJvdG90eXBlLmdldEJlZm9yZT1mdW5jdGlvbihlKXt2YXIgaT10aGlzLl90aW1lbGluZS5sZW5ndGg7aWYoMDxpJiZ0aGlzLl90aW1lbGluZVtpLTFdLnRpbWU8ZSlyZXR1cm4gdGhpcy5fdGltZWxpbmVbaS0xXTt2YXIgdD10aGlzLl9zZWFyY2goZSk7cmV0dXJuIDA8PXQtMT90aGlzLl90aW1lbGluZVt0LTFdOm51bGx9LGkuVGltZWxpbmUucHJvdG90eXBlLmNhbmNlbD1mdW5jdGlvbihlKXtpZigxPHRoaXMuX3RpbWVsaW5lLmxlbmd0aCl7dmFyIGk9dGhpcy5fc2VhcmNoKGUpO2lmKDA8PWkpaWYodGhpcy5fdGltZWxpbmVbaV0udGltZT09PWUpe2Zvcih2YXIgdD1pOzA8PXQmJnRoaXMuX3RpbWVsaW5lW3RdLnRpbWU9PT1lO3QtLSlpPXQ7dGhpcy5fdGltZWxpbmU9dGhpcy5fdGltZWxpbmUuc2xpY2UoMCxpKX1lbHNlIHRoaXMuX3RpbWVsaW5lPXRoaXMuX3RpbWVsaW5lLnNsaWNlKDAsaSsxKTtlbHNlIHRoaXMuX3RpbWVsaW5lPVtdfWVsc2UgMT09PXRoaXMuX3RpbWVsaW5lLmxlbmd0aCYmdGhpcy5fdGltZWxpbmVbMF0udGltZT49ZSYmKHRoaXMuX3RpbWVsaW5lPVtdKTtyZXR1cm4gdGhpc30saS5UaW1lbGluZS5wcm90b3R5cGUuY2FuY2VsQmVmb3JlPWZ1bmN0aW9uKGUpe2lmKHRoaXMuX3RpbWVsaW5lLmxlbmd0aCl7dmFyIGk9dGhpcy5fc2VhcmNoKGUpOzA8PWkmJih0aGlzLl90aW1lbGluZT10aGlzLl90aW1lbGluZS5zbGljZShpKzEpKX1yZXR1cm4gdGhpc30saS5UaW1lbGluZS5wcm90b3R5cGUuX3NlYXJjaD1mdW5jdGlvbihlKXt2YXIgaT0wLHQ9dGhpcy5fdGltZWxpbmUubGVuZ3RoLG49dDtpZigwPHQmJnRoaXMuX3RpbWVsaW5lW3QtMV0udGltZTw9ZSlyZXR1cm4gdC0xO2Zvcig7aTxuOyl7dmFyIHI9TWF0aC5mbG9vcihpKyhuLWkpLzIpLHM9dGhpcy5fdGltZWxpbmVbcl0saD10aGlzLl90aW1lbGluZVtyKzFdO2lmKHMudGltZT09PWUpe2Zvcih2YXIgbD1yO2w8dGhpcy5fdGltZWxpbmUubGVuZ3RoO2wrKyl7dGhpcy5fdGltZWxpbmVbbF0udGltZT09PWUmJihyPWwpfXJldHVybiByfWlmKHMudGltZTxlJiZoLnRpbWU+ZSlyZXR1cm4gcjtzLnRpbWU+ZT9uPXI6cy50aW1lPGUmJihpPXIrMSl9cmV0dXJuLTF9LGkuVGltZWxpbmUucHJvdG90eXBlLl9pdGVyYXRlPWZ1bmN0aW9uKGUsaSx0KXt0aGlzLl9pdGVyYXRpbmc9ITAsaT10aGlzLmRlZmF1bHRBcmcoaSwwKSx0PXRoaXMuZGVmYXVsdEFyZyh0LHRoaXMuX3RpbWVsaW5lLmxlbmd0aC0xKTtmb3IodmFyIG49aTtuPD10O24rKyllKHRoaXMuX3RpbWVsaW5lW25dKTtpZih0aGlzLl9pdGVyYXRpbmc9ITEsMDx0aGlzLl90b1JlbW92ZS5sZW5ndGgpe2Zvcih2YXIgcj0wO3I8dGhpcy5fdG9SZW1vdmUubGVuZ3RoO3IrKyl7dmFyIHM9dGhpcy5fdGltZWxpbmUuaW5kZXhPZih0aGlzLl90b1JlbW92ZVtyXSk7LTEhPT1zJiZ0aGlzLl90aW1lbGluZS5zcGxpY2UocywxKX10aGlzLl90b1JlbW92ZT1bXX19LGkuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2l0ZXJhdGUoZSksdGhpc30saS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEJlZm9yZT1mdW5jdGlvbihlLGkpe3ZhciB0PXRoaXMuX3NlYXJjaChlKTtyZXR1cm4tMSE9PXQmJnRoaXMuX2l0ZXJhdGUoaSwwLHQpLHRoaXN9LGkuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hBZnRlcj1mdW5jdGlvbihlLGkpe3ZhciB0PXRoaXMuX3NlYXJjaChlKTtyZXR1cm4gdGhpcy5faXRlcmF0ZShpLHQrMSksdGhpc30saS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEZyb209ZnVuY3Rpb24oZSxpKXtmb3IodmFyIHQ9dGhpcy5fc2VhcmNoKGUpOzA8PXQmJnRoaXMuX3RpbWVsaW5lW3RdLnRpbWU+PWU7KXQtLTtyZXR1cm4gdGhpcy5faXRlcmF0ZShpLHQrMSksdGhpc30saS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEF0VGltZT1mdW5jdGlvbihpLHQpe3ZhciBlPXRoaXMuX3NlYXJjaChpKTtyZXR1cm4tMSE9PWUmJnRoaXMuX2l0ZXJhdGUoZnVuY3Rpb24oZSl7ZS50aW1lPT09aSYmdChlKX0sMCxlKSx0aGlzfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7aS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX3RpbWVsaW5lPW51bGwsdGhpcy5fdG9SZW1vdmU9bnVsbH0saS5UaW1lbGluZX0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLF9fd2VicGFja19yZXF1aXJlX18oMildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gdC5OZWdhdGU9ZnVuY3Rpb24oKXt0aGlzLl9tdWx0aXBseT10aGlzLmlucHV0PXRoaXMub3V0cHV0PW5ldyB0Lk11bHRpcGx5KC0xKX0sdC5leHRlbmQodC5OZWdhdGUsdC5TaWduYWxCYXNlKSx0Lk5lZ2F0ZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiB0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fbXVsdGlwbHkuZGlzcG9zZSgpLHRoaXMuX211bHRpcGx5PW51bGwsdGhpc30sdC5OZWdhdGV9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLF9fd2VicGFja19yZXF1aXJlX18oNSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gZS5HcmVhdGVyVGhhblplcm89ZnVuY3Rpb24oKXt0aGlzLl90aHJlc2g9dGhpcy5vdXRwdXQ9bmV3IGUuV2F2ZVNoYXBlcihmdW5jdGlvbihlKXtyZXR1cm4gZTw9MD8wOjF9LDEyNyksdGhpcy5fc2NhbGU9dGhpcy5pbnB1dD1uZXcgZS5NdWx0aXBseSgxZTQpLHRoaXMuX3NjYWxlLmNvbm5lY3QodGhpcy5fdGhyZXNoKX0sZS5leHRlbmQoZS5HcmVhdGVyVGhhblplcm8sZS5TaWduYWxCYXNlKSxlLkdyZWF0ZXJUaGFuWmVyby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fc2NhbGUuZGlzcG9zZSgpLHRoaXMuX3NjYWxlPW51bGwsdGhpcy5fdGhyZXNoLmRpc3Bvc2UoKSx0aGlzLl90aHJlc2g9bnVsbCx0aGlzfSxlLkdyZWF0ZXJUaGFuWmVyb30pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKG8pe1widXNlIHN0cmljdFwiO3JldHVybiBvLkNsb2NrPWZ1bmN0aW9uKCl7by5FbWl0dGVyLmNhbGwodGhpcyk7dmFyIHQ9dGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cyxbXCJjYWxsYmFja1wiLFwiZnJlcXVlbmN5XCJdLG8uQ2xvY2suZGVmYXVsdHMpO3RoaXMuY2FsbGJhY2s9dC5jYWxsYmFjayx0aGlzLl9uZXh0VGljaz0wLHRoaXMuX2xhc3RTdGF0ZT1vLlN0YXRlLlN0b3BwZWQsdGhpcy5mcmVxdWVuY3k9bmV3IG8uVGltZWxpbmVTaWduYWwodC5mcmVxdWVuY3ksby5UeXBlLkZyZXF1ZW5jeSksdGhpcy5fcmVhZE9ubHkoXCJmcmVxdWVuY3lcIiksdGhpcy50aWNrcz0wLHRoaXMuX3N0YXRlPW5ldyBvLlRpbWVsaW5lU3RhdGUoby5TdGF0ZS5TdG9wcGVkKSx0aGlzLl9ib3VuZExvb3A9dGhpcy5fbG9vcC5iaW5kKHRoaXMpLHRoaXMuY29udGV4dC5vbihcInRpY2tcIix0aGlzLl9ib3VuZExvb3ApfSxvLmV4dGVuZChvLkNsb2NrLG8uRW1pdHRlciksby5DbG9jay5kZWZhdWx0cz17Y2FsbGJhY2s6by5ub09wLGZyZXF1ZW5jeToxLGxvb2tBaGVhZDpcImF1dG9cIn0sT2JqZWN0LmRlZmluZVByb3BlcnR5KG8uQ2xvY2sucHJvdG90eXBlLFwic3RhdGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRoaXMubm93KCkpfX0pLG8uQ2xvY2sucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9dGhpcy50b1NlY29uZHModCksdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodCkhPT1vLlN0YXRlLlN0YXJ0ZWQmJnRoaXMuX3N0YXRlLmFkZCh7c3RhdGU6by5TdGF0ZS5TdGFydGVkLHRpbWU6dCxvZmZzZXQ6ZX0pLHRoaXN9LG8uQ2xvY2sucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dGhpcy50b1NlY29uZHModCksdGhpcy5fc3RhdGUuY2FuY2VsKHQpLHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKG8uU3RhdGUuU3RvcHBlZCx0KSx0aGlzfSxvLkNsb2NrLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbih0KXtyZXR1cm4gdD10aGlzLnRvU2Vjb25kcyh0KSx0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0KT09PW8uU3RhdGUuU3RhcnRlZCYmdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoby5TdGF0ZS5QYXVzZWQsdCksdGhpc30sby5DbG9jay5wcm90b3R5cGUuX2xvb3A9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub3coKSt0aGlzLmNvbnRleHQubG9va0FoZWFkK3RoaXMuY29udGV4dC51cGRhdGVJbnRlcnZhbCsyKnRoaXMuY29udGV4dC5sYWc7dD50aGlzLl9uZXh0VGljayYmdGhpcy5fc3RhdGU7KXt2YXIgZT10aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLl9uZXh0VGljayk7aWYoZSE9PXRoaXMuX2xhc3RTdGF0ZSl7dGhpcy5fbGFzdFN0YXRlPWU7dmFyIGk9dGhpcy5fc3RhdGUuZ2V0KHRoaXMuX25leHRUaWNrKTtlPT09by5TdGF0ZS5TdGFydGVkPyh0aGlzLl9uZXh0VGljaz1pLnRpbWUsdGhpcy5pc1VuZGVmKGkub2Zmc2V0KXx8KHRoaXMudGlja3M9aS5vZmZzZXQpLHRoaXMuZW1pdChcInN0YXJ0XCIsaS50aW1lLHRoaXMudGlja3MpKTplPT09by5TdGF0ZS5TdG9wcGVkPyh0aGlzLnRpY2tzPTAsdGhpcy5lbWl0KFwic3RvcFwiLGkudGltZSkpOmU9PT1vLlN0YXRlLlBhdXNlZCYmdGhpcy5lbWl0KFwicGF1c2VcIixpLnRpbWUpfXZhciBzPXRoaXMuX25leHRUaWNrO3RoaXMuZnJlcXVlbmN5JiYodGhpcy5fbmV4dFRpY2srPTEvdGhpcy5mcmVxdWVuY3kuZ2V0VmFsdWVBdFRpbWUodGhpcy5fbmV4dFRpY2spLGU9PT1vLlN0YXRlLlN0YXJ0ZWQmJih0aGlzLmNhbGxiYWNrKHMpLHRoaXMudGlja3MrKykpfX0sby5DbG9jay5wcm90b3R5cGUuZ2V0U3RhdGVBdFRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dGhpcy50b1NlY29uZHModCksdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodCl9LG8uQ2xvY2sucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtvLkVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLmNvbnRleHQub2ZmKFwidGlja1wiLHRoaXMuX2JvdW5kTG9vcCksdGhpcy5fd3JpdGFibGUoXCJmcmVxdWVuY3lcIiksdGhpcy5mcmVxdWVuY3kuZGlzcG9zZSgpLHRoaXMuZnJlcXVlbmN5PW51bGwsdGhpcy5fYm91bmRMb29wPW51bGwsdGhpcy5fbmV4dFRpY2s9MS8wLHRoaXMuY2FsbGJhY2s9bnVsbCx0aGlzLl9zdGF0ZS5kaXNwb3NlKCksdGhpcy5fc3RhdGU9bnVsbH0sby5DbG9ja30pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgQXVkaW9Wb2ljZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG4gIHZhciBub3RlVG9GcmVxID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5ub3RlVG9GcmVxO1xuXG4gIHZhciBERUZBVUxUX1NVU1RBSU4gPSAwLjE1O1xuICAvKipcbiAgICAqICBBIE1vbm9TeW50aCBpcyB1c2VkIGFzIGEgc2luZ2xlIHZvaWNlIGZvciBzb3VuZCBzeW50aGVzaXMuXG4gICAgKiAgVGhpcyBpcyBhIGNsYXNzIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgUG9seVN5bnRoXG4gICAgKiAgY2xhc3MuIEN1c3RvbSBzeW50aGV0aXNlcnMgc2hvdWxkIGJlIGJ1aWx0IGluaGVyaXRpbmcgZnJvbVxuICAgICogIHRoaXMgY2xhc3MuXG4gICAgKlxuICAgICogIEBjbGFzcyBwNS5Nb25vU3ludGhcbiAgICAqICBAY29uc3RydWN0b3JcbiAgICAqICBAZXhhbXBsZVxuICAgICogIDxkaXY+PGNvZGU+XG4gICAgKiAgbGV0IG1vbm9TeW50aDtcbiAgICAqXG4gICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheVN5bnRoKTtcbiAgICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICAqICAgIHRleHRBbGlnbihDRU5URVIpO1xuICAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAgKlxuICAgICogICAgbW9ub1N5bnRoID0gbmV3IHA1Lk1vbm9TeW50aCgpO1xuICAgICogIH1cbiAgICAqXG4gICAgKiAgZnVuY3Rpb24gcGxheVN5bnRoKCkge1xuICAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICAqXG4gICAgKiAgICBsZXQgbm90ZSA9IHJhbmRvbShbJ0ZiNCcsICdHNCddKTtcbiAgICAqICAgIC8vIG5vdGUgdmVsb2NpdHkgKHZvbHVtZSwgZnJvbSAwIHRvIDEpXG4gICAgKiAgICBsZXQgdmVsb2NpdHkgPSByYW5kb20oKTtcbiAgICAqICAgIC8vIHRpbWUgZnJvbSBub3cgKGluIHNlY29uZHMpXG4gICAgKiAgICBsZXQgdGltZSA9IDA7XG4gICAgKiAgICAvLyBub3RlIGR1cmF0aW9uIChpbiBzZWNvbmRzKVxuICAgICogICAgbGV0IGR1ciA9IDEvNjtcbiAgICAqXG4gICAgKiAgICBtb25vU3ludGgucGxheShub3RlLCB2ZWxvY2l0eSwgdGltZSwgZHVyKTtcbiAgICAqICB9XG4gICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgICoqL1xuXG4gIHA1Lk1vbm9TeW50aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBBdWRpb1ZvaWNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5vc2NpbGxhdG9yID0gbmV3IHA1Lk9zY2lsbGF0b3IoKTtcbiAgICB0aGlzLmVudiA9IG5ldyBwNS5FbnZlbG9wZSgpO1xuICAgIHRoaXMuZW52LnNldFJhbmdlKDEsIDApO1xuICAgIHRoaXMuZW52LnNldEV4cCh0cnVlKTsgXG5cbiAgICB0aGlzLnNldEFEU1IoMC4wMiwgMC4yNSwgMC4wNSwgMC4zNSk7IFxuXG4gICAgdGhpcy5vc2NpbGxhdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLm9zY2lsbGF0b3IuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgdGhpcy5lbnYuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZW52LnNldElucHV0KHRoaXMub3V0cHV0LmdhaW4pOyBcblxuICAgIHRoaXMub3NjaWxsYXRvci5vdXRwdXQuZ2Fpbi52YWx1ZSA9IDEuMDtcbiAgICB0aGlzLm9zY2lsbGF0b3Iuc3RhcnQoKTtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTtcblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5BdWRpb1ZvaWNlLnByb3RvdHlwZSk7XG4gIC8qKlxuICAgICogIFBsYXkgdGVsbHMgdGhlIE1vbm9TeW50aCB0byBzdGFydCBwbGF5aW5nIGEgbm90ZS4gVGhpcyBtZXRob2Qgc2NoZWR1bGVzXG4gICAgKiAgdGhlIGNhbGxpbmcgb2YgLnRyaWdnZXJBdHRhY2sgYW5kIC50cmlnZ2VyUmVsZWFzZS5cbiAgICAqXG4gICAgKiAgQG1ldGhvZCBwbGF5XG4gICAgKiAgQGZvciBwNS5Nb25vU3ludGhcbiAgICAqICBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gbm90ZSB0aGUgbm90ZSB5b3Ugd2FudCB0byBwbGF5LCBzcGVjaWZpZWQgYXMgYVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3kgaW4gSGVydHogKE51bWJlcikgb3IgYXMgYSBtaWRpXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluIE5vdGUvT2N0YXZlIGZvcm1hdCAoXCJDNFwiLCBcIkViM1wiLi4uZXRjXCIpXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSA8YSBocmVmID0gXCJodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9JbnN0cnVtZW50c1wiPlxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb25lPC9hPi4gRGVmYXVsdHMgdG8gNDQwIGh6LlxuICAgICogIEBwYXJhbSAge051bWJlcn0gW3ZlbG9jaXR5XSB2ZWxvY2l0eSBvZiB0aGUgbm90ZSB0byBwbGF5IChyYW5naW5nIGZyb20gMCB0byAxKVxuICAgICogIEBwYXJhbSAge051bWJlcn0gW3NlY29uZHNGcm9tTm93XSAgdGltZSBmcm9tIG5vdyAoaW4gc2Vjb25kcykgYXQgd2hpY2ggdG8gcGxheVxuICAgICogIEBwYXJhbSAge051bWJlcn0gW3N1c3RhaW5UaW1lXSB0aW1lIHRvIHN1c3RhaW4gYmVmb3JlIHJlbGVhc2luZyB0aGUgZW52ZWxvcGUuIERlZmF1bHRzIHRvIDAuMTUgc2Vjb25kcy5cbiAgICAqICBAZXhhbXBsZVxuICAgICogIDxkaXY+PGNvZGU+XG4gICAgKiAgbGV0IG1vbm9TeW50aDtcbiAgICAqXG4gICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheVN5bnRoKTtcbiAgICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICAqICAgIHRleHRBbGlnbihDRU5URVIpO1xuICAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAgKlxuICAgICogICAgbW9ub1N5bnRoID0gbmV3IHA1Lk1vbm9TeW50aCgpO1xuICAgICogIH1cbiAgICAqXG4gICAgKiAgZnVuY3Rpb24gcGxheVN5bnRoKCkge1xuICAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICAqXG4gICAgKiAgICBsZXQgbm90ZSA9IHJhbmRvbShbJ0ZiNCcsICdHNCddKTtcbiAgICAqICAgIC8vIG5vdGUgdmVsb2NpdHkgKHZvbHVtZSwgZnJvbSAwIHRvIDEpXG4gICAgKiAgICBsZXQgdmVsb2NpdHkgPSByYW5kb20oKTtcbiAgICAqICAgIC8vIHRpbWUgZnJvbSBub3cgKGluIHNlY29uZHMpXG4gICAgKiAgICBsZXQgdGltZSA9IDA7XG4gICAgKiAgICAvLyBub3RlIGR1cmF0aW9uIChpbiBzZWNvbmRzKVxuICAgICogICAgbGV0IGR1ciA9IDEvNjtcbiAgICAqXG4gICAgKiAgICBtb25vU3ludGgucGxheShub3RlLCB2ZWxvY2l0eSwgdGltZSwgZHVyKTtcbiAgICAqICB9XG4gICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgICpcbiAgICAqL1xuXG4gIHA1Lk1vbm9TeW50aC5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChub3RlLCB2ZWxvY2l0eSwgc2Vjb25kc0Zyb21Ob3csIHN1c1RpbWUpIHtcbiAgICB0aGlzLnRyaWdnZXJBdHRhY2sobm90ZSwgdmVsb2NpdHksIH5+c2Vjb25kc0Zyb21Ob3cpO1xuICAgIHRoaXMudHJpZ2dlclJlbGVhc2Uofn5zZWNvbmRzRnJvbU5vdyArIChzdXNUaW1lIHx8IERFRkFVTFRfU1VTVEFJTikpO1xuICB9O1xuICAvKipcbiAgICAgKiAgVHJpZ2dlciB0aGUgQXR0YWNrLCBhbmQgRGVjYXkgcG9ydGlvbiBvZiB0aGUgRW52ZWxvcGUuXG4gICAgICogIFNpbWlsYXIgdG8gaG9sZGluZyBkb3duIGEga2V5IG9uIGEgcGlhbm8sIGJ1dCBpdCB3aWxsXG4gICAgICogIGhvbGQgdGhlIHN1c3RhaW4gbGV2ZWwgdW50aWwgeW91IGxldCBnby5cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gbm90ZSB0aGUgbm90ZSB5b3Ugd2FudCB0byBwbGF5LCBzcGVjaWZpZWQgYXMgYVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5IGluIEhlcnR6IChOdW1iZXIpIG9yIGFzIGEgbWlkaVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW4gTm90ZS9PY3RhdmUgZm9ybWF0IChcIkM0XCIsIFwiRWIzXCIuLi5ldGNcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSA8YSBocmVmID0gXCJodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9JbnN0cnVtZW50c1wiPlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG9uZTwvYT4uIERlZmF1bHRzIHRvIDQ0MCBoelxuICAgICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt2ZWxvY2l0eV0gdmVsb2NpdHkgb2YgdGhlIG5vdGUgdG8gcGxheSAocmFuZ2luZyBmcm9tIDAgdG8gMSlcbiAgICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbc2Vjb25kc0Zyb21Ob3ddICB0aW1lIGZyb20gbm93IChpbiBzZWNvbmRzKSBhdCB3aGljaCB0byBwbGF5XG4gICAgICogIEBtZXRob2QgIHRyaWdnZXJBdHRhY2tcbiAgICAgKiAgQGZvciBwNS5Nb25vU3ludGhcbiAgICAgKiAgQGV4YW1wbGVcbiAgICAgKiAgPGRpdj48Y29kZT5cbiAgICAgKiAgbGV0IG1vbm9TeW50aDtcbiAgICAgKlxuICAgICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHRyaWdnZXJBdHRhY2spO1xuICAgICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICAgKiAgICB0ZXh0KCd0YXAgaGVyZSBmb3IgYXR0YWNrLCBsZXQgZ28gdG8gcmVsZWFzZScsIDUsIDIwLCB3aWR0aCAtIDIwKTtcbiAgICAgKiAgICBtb25vU3ludGggPSBuZXcgcDUuTW9ub1N5bnRoKCk7XG4gICAgICogIH1cbiAgICAgKlxuICAgICAqICBmdW5jdGlvbiB0cmlnZ2VyQXR0YWNrKCkge1xuICAgICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAgICpcbiAgICAgKiAgICBtb25vU3ludGgudHJpZ2dlckF0dGFjayhcIkUzXCIpO1xuICAgICAqICB9XG4gICAgICpcbiAgICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICAgKiAgICBtb25vU3ludGgudHJpZ2dlclJlbGVhc2UoKTtcbiAgICAgKiAgfVxuICAgICAqICA8L2NvZGU+PC9kaXY+XG4gICAgICovXG5cblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAobm90ZSwgdmVsb2NpdHksIHNlY29uZHNGcm9tTm93KSB7XG4gICAgdmFyIHNlY29uZHNGcm9tTm93ID0gfn5zZWNvbmRzRnJvbU5vdztcbiAgICB2YXIgZnJlcSA9IG5vdGVUb0ZyZXEobm90ZSk7XG4gICAgdmFyIHZlbCA9IHZlbG9jaXR5IHx8IDAuMTtcbiAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcShmcmVxLCAwLCBzZWNvbmRzRnJvbU5vdyk7XG4gICAgdGhpcy5lbnYucmFtcCh0aGlzLm91dHB1dC5nYWluLCBzZWNvbmRzRnJvbU5vdywgdmVsKTtcbiAgfTtcbiAgLyoqXG4gICAgICogIFRyaWdnZXIgdGhlIHJlbGVhc2Ugb2YgdGhlIEVudmVsb3BlLiBUaGlzIGlzIHNpbWlsYXIgdG8gcmVsZWFzaW5nXG4gICAgICogIHRoZSBrZXkgb24gYSBwaWFubyBhbmQgbGV0dGluZyB0aGUgc291bmQgZmFkZSBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICogIHJlbGVhc2UgbGV2ZWwgYW5kIHJlbGVhc2UgdGltZS5cbiAgICAgKlxuICAgICAqICBAcGFyYW0gIHtOdW1iZXJ9IHNlY29uZHNGcm9tTm93IHRpbWUgdG8gdHJpZ2dlciB0aGUgcmVsZWFzZVxuICAgICAqICBAbWV0aG9kICB0cmlnZ2VyUmVsZWFzZVxuICAgICAqICBAZm9yIHA1Lk1vbm9TeW50aFxuICAgICAqICBAZXhhbXBsZVxuICAgICAqICA8ZGl2Pjxjb2RlPlxuICAgICAqICBsZXQgbW9ub1N5bnRoO1xuICAgICAqXG4gICAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgICAqICAgIGNudi5tb3VzZVByZXNzZWQodHJpZ2dlckF0dGFjayk7XG4gICAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgICAqICAgIHRleHQoJ3RhcCBoZXJlIGZvciBhdHRhY2ssIGxldCBnbyB0byByZWxlYXNlJywgNSwgMjAsIHdpZHRoIC0gMjApO1xuICAgICAqICAgIG1vbm9TeW50aCA9IG5ldyBwNS5Nb25vU3ludGgoKTtcbiAgICAgKiAgfVxuICAgICAqXG4gICAgICogIGZ1bmN0aW9uIHRyaWdnZXJBdHRhY2soKSB7XG4gICAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICAgKlxuICAgICAqICAgIG1vbm9TeW50aC50cmlnZ2VyQXR0YWNrKFwiRTNcIik7XG4gICAgICogIH1cbiAgICAgKlxuICAgICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgICAqICAgIG1vbm9TeW50aC50cmlnZ2VyUmVsZWFzZSgpO1xuICAgICAqICB9XG4gICAgICogIDwvY29kZT48L2Rpdj5cbiAgICAgKi9cblxuXG4gIHA1Lk1vbm9TeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAoc2Vjb25kc0Zyb21Ob3cpIHtcbiAgICB2YXIgc2Vjb25kc0Zyb21Ob3cgPSBzZWNvbmRzRnJvbU5vdyB8fCAwO1xuICAgIHRoaXMuZW52LnJhbXAodGhpcy5vdXRwdXQuZ2Fpbiwgc2Vjb25kc0Zyb21Ob3csIDApO1xuICB9O1xuICAvKipcbiAgICAgKiAgU2V0IHZhbHVlcyBsaWtlIGEgdHJhZGl0aW9uYWxcbiAgICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bnRoZXNpemVyIy9tZWRpYS9GaWxlOkFEU1JfcGFyYW1ldGVyLnN2Z1wiPlxuICAgICAqICBBRFNSIGVudmVsb3BlXG4gICAgICogIDwvYT4uXG4gICAgICpcbiAgICAgKiAgQG1ldGhvZCAgc2V0QURTUlxuICAgICAqICBAZm9yIHA1Lk1vbm9TeW50aFxuICAgICAqICBAcGFyYW0ge051bWJlcn0gYXR0YWNrVGltZSAgICBUaW1lIChpbiBzZWNvbmRzIGJlZm9yZSBlbnZlbG9wZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFjaGVzIEF0dGFjayBMZXZlbFxuICAgICAqICBAcGFyYW0ge051bWJlcn0gW2RlY2F5VGltZV0gICAgVGltZSAoaW4gc2Vjb25kcykgYmVmb3JlIGVudmVsb3BlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWNoZXMgRGVjYXkvU3VzdGFpbiBMZXZlbFxuICAgICAqICBAcGFyYW0ge051bWJlcn0gW3N1c1JhdGlvXSAgICBSYXRpbyBiZXR3ZWVuIGF0dGFja0xldmVsIGFuZCByZWxlYXNlTGV2ZWwsIG9uIGEgc2NhbGUgZnJvbSAwIHRvIDEsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlIDEuMCA9IGF0dGFja0xldmVsLCAwLjAgPSByZWxlYXNlTGV2ZWwuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBzdXNSYXRpbyBkZXRlcm1pbmVzIHRoZSBkZWNheUxldmVsIGFuZCB0aGUgbGV2ZWwgYXQgd2hpY2ggdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3RhaW4gcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUgd2lsbCBzdXN0YWluLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgaWYgYXR0YWNrTGV2ZWwgaXMgMC40LCByZWxlYXNlTGV2ZWwgaXMgMCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHN1c0FtdCBpcyAwLjUsIHRoZSBkZWNheUxldmVsIHdvdWxkIGJlIDAuMi4gSWYgYXR0YWNrTGV2ZWwgaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVhc2VkIHRvIDEuMCAodXNpbmcgPGNvZGU+c2V0UmFuZ2U8L2NvZGU+KSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBkZWNheUxldmVsIHdvdWxkIGluY3JlYXNlIHByb3BvcnRpb25hbGx5LCB0byBiZWNvbWUgMC41LlxuICAgICAqICBAcGFyYW0ge051bWJlcn0gW3JlbGVhc2VUaW1lXSAgIFRpbWUgaW4gc2Vjb25kcyBmcm9tIG5vdyAoZGVmYXVsdHMgdG8gMClcbiAgICAgKi9cblxuXG4gIHA1Lk1vbm9TeW50aC5wcm90b3R5cGUuc2V0QURTUiA9IGZ1bmN0aW9uIChhdHRhY2ssIGRlY2F5LCBzdXN0YWluLCByZWxlYXNlKSB7XG4gICAgdGhpcy5lbnYuc2V0QURTUihhdHRhY2ssIGRlY2F5LCBzdXN0YWluLCByZWxlYXNlKTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHRlcnMgYW5kIFNldHRlcnNcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGF0dGFja1xuICAgKiBAZm9yIHA1Lk1vbm9TeW50aFxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlY2F5XG4gICAqIEBmb3IgcDUuTW9ub1N5bnRoXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gc3VzdGFpblxuICAgKiBAZm9yIHA1Lk1vbm9TeW50aFxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJlbGVhc2VcbiAgICogQGZvciBwNS5Nb25vU3ludGhcbiAgICovXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwNS5Nb25vU3ludGgucHJvdG90eXBlLCB7XG4gICAgJ2F0dGFjayc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnYuYVRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXR0YWNrKSB7XG4gICAgICAgIHRoaXMuZW52LnNldEFEU1IoYXR0YWNrLCB0aGlzLmVudi5kVGltZSwgdGhpcy5lbnYuc1BlcmNlbnQsIHRoaXMuZW52LnJUaW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdkZWNheSc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnYuZFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZGVjYXkpIHtcbiAgICAgICAgdGhpcy5lbnYuc2V0QURTUih0aGlzLmVudi5hVGltZSwgZGVjYXksIHRoaXMuZW52LnNQZXJjZW50LCB0aGlzLmVudi5yVGltZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnc3VzdGFpbic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnYuc1BlcmNlbnQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc3VzdGFpbikge1xuICAgICAgICB0aGlzLmVudi5zZXRBRFNSKHRoaXMuZW52LmFUaW1lLCB0aGlzLmVudi5kVGltZSwgc3VzdGFpbiwgdGhpcy5lbnYuclRpbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3JlbGVhc2UnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW52LnJUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHJlbGVhc2UpIHtcbiAgICAgICAgdGhpcy5lbnYuc2V0QURTUih0aGlzLmVudi5hVGltZSwgdGhpcy5lbnYuZFRpbWUsIHRoaXMuZW52LnNQZXJjZW50LCByZWxlYXNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogTW9ub1N5bnRoIGFtcFxuICAgKiBAbWV0aG9kICBhbXBcbiAgICogQGZvciBwNS5Nb25vU3ludGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSB2b2wgICAgICBkZXNpcmVkIHZvbHVtZVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtyYW1wVGltZV0gVGltZSB0byByZWFjaCBuZXcgdm9sdW1lXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgbmV3IHZvbHVtZSB2YWx1ZVxuICAgKi9cblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlLmFtcCA9IGZ1bmN0aW9uICh2b2wsIHJhbXBUaW1lKSB7XG4gICAgdmFyIHQgPSByYW1wVGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB2b2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLm9zY2lsbGF0b3IuYW1wKHZvbCwgdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub3NjaWxsYXRvci5hbXAoKS52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqICBDb25uZWN0IHRvIGEgcDUuc291bmQgLyBXZWIgQXVkaW8gb2JqZWN0LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgY29ubmVjdFxuICAgKiAgQGZvciBwNS5Nb25vU3ludGhcbiAgICogIEBwYXJhbSAge09iamVjdH0gdW5pdCBBIHA1LnNvdW5kIG9yIFdlYiBBdWRpbyBvYmplY3RcbiAgICovXG5cblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHZhciB1ID0gdW5pdCB8fCBwNXNvdW5kLmlucHV0O1xuICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodS5pbnB1dCA/IHUuaW5wdXQgOiB1KTtcbiAgfTtcbiAgLyoqXG4gICAqICBEaXNjb25uZWN0IGFsbCBvdXRwdXRzXG4gICAqXG4gICAqICBAbWV0aG9kICBkaXNjb25uZWN0XG4gICAqICBAZm9yIHA1Lk1vbm9TeW50aFxuICAgKi9cblxuXG4gIHA1Lk1vbm9TeW50aC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgR2V0IHJpZCBvZiB0aGUgTW9ub1N5bnRoIGFuZCBmcmVlIHVwIGl0cyByZXNvdXJjZXMgLyBtZW1vcnkuXG4gICAqXG4gICAqICBAbWV0aG9kICBkaXNwb3NlXG4gICAqICBAZm9yIHA1Lk1vbm9TeW50aFxuICAgKi9cblxuXG4gIHA1Lk1vbm9TeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBBdWRpb1ZvaWNlLnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuZW52KSB7XG4gICAgICB0aGlzLmVudi5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3NjaWxsYXRvcikge1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIC8qKlxuICAgKiBCYXNlIGNsYXNzIGZvciBtb25vcGhvbmljIHN5bnRoZXNpemVycy4gQW55IGV4dGVuc2lvbnMgb2YgdGhpcyBjbGFzc1xuICAgKiBzaG91bGQgZm9sbG93IHRoZSBBUEkgYW5kIGltcGxlbWVudCB0aGUgbWV0aG9kcyBiZWxvdyBpbiBvcmRlciB0b1xuICAgKiByZW1haW4gY29tcGF0aWJsZSB3aXRoIHA1LlBvbHlTeW50aCgpO1xuICAgKlxuICAgKiBAY2xhc3MgcDUuQXVkaW9Wb2ljZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cblxuICBwNS5BdWRpb1ZvaWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWMgPSBwNXNvdW5kLmF1ZGlvY29udGV4dDtcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMuYWMuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5wdXNoKHRoaXMpO1xuICB9O1xuXG4gIHA1LkF1ZGlvVm9pY2UucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAobm90ZSwgdmVsb2NpdHksIHNlY29uZHNGcm9tTm93LCBzdXN0aW1lKSB7fTtcblxuICBwNS5BdWRpb1ZvaWNlLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrID0gZnVuY3Rpb24gKG5vdGUsIHZlbG9jaXR5LCBzZWNvbmRzRnJvbU5vdykge307XG5cbiAgcDUuQXVkaW9Wb2ljZS5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAoc2Vjb25kc0Zyb21Ob3cpIHt9O1xuXG4gIHA1LkF1ZGlvVm9pY2UucHJvdG90eXBlLmFtcCA9IGZ1bmN0aW9uICh2b2wsIHJhbXBUaW1lKSB7fTtcbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gcDUgb2JqZWN0cyBvciBXZWIgQXVkaW8gTm9kZXNcbiAgICogQG1ldGhvZCAgY29ubmVjdFxuICAgKiBAZm9yIHA1LkF1ZGlvVm9pY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHVuaXRcbiAgICovXG5cblxuICBwNS5BdWRpb1ZvaWNlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB2YXIgdSA9IHVuaXQgfHwgcDVzb3VuZC5pbnB1dDtcbiAgICB0aGlzLm91dHB1dC5jb25uZWN0KHUuaW5wdXQgPyB1LmlucHV0IDogdSk7XG4gIH07XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IGZyb20gc291bmRPdXRcbiAgICogQG1ldGhvZCAgZGlzY29ubmVjdFxuICAgKiBAZm9yIHA1LkF1ZGlvVm9pY2VcbiAgICovXG5cblxuICBwNS5BdWRpb1ZvaWNlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgfTtcblxuICBwNS5BdWRpb1ZvaWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMub3V0cHV0O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcDUuQXVkaW9Wb2ljZTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIFRpbWVsaW5lU2lnbmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbiAgdmFyIG5vdGVUb0ZyZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLm5vdGVUb0ZyZXE7XG4gIC8qKlxuICAgICogIEFuIEF1ZGlvVm9pY2UgaXMgdXNlZCBhcyBhIHNpbmdsZSB2b2ljZSBmb3Igc291bmQgc3ludGhlc2lzLlxuICAgICogIFRoZSBQb2x5U3ludGggY2xhc3MgaG9sZHMgYW4gYXJyYXkgb2YgQXVkaW9Wb2ljZSwgYW5kIGRlYWxzXG4gICAgKiAgd2l0aCB2b2ljZXMgYWxsb2NhdGlvbnMsIHdpdGggc2V0dGluZyBub3RlcyB0byBiZSBwbGF5ZWQsIGFuZFxuICAgICogIHBhcmFtZXRlcnMgdG8gYmUgc2V0LlxuICAgICpcbiAgICAqICBAY2xhc3MgcDUuUG9seVN5bnRoXG4gICAgKiAgQGNvbnN0cnVjdG9yXG4gICAgKlxuICAgICogIEBwYXJhbSB7TnVtYmVyfSBbc3ludGhWb2ljZV0gICBBIG1vbm9waG9uaWMgc3ludGggdm9pY2UgaW5oZXJpdGluZ1xuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgQXVkaW9Wb2ljZSBjbGFzcy4gRGVmYXVsdHMgdG8gcDUuTW9ub1N5bnRoXG4gICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFttYXhWb2ljZXNdIE51bWJlciBvZiB2b2ljZXMsIGRlZmF1bHRzIHRvIDg7XG4gICAgKiAgQGV4YW1wbGVcbiAgICAqICA8ZGl2Pjxjb2RlPlxuICAgICogIGxldCBwb2x5U3ludGg7XG4gICAgKlxuICAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTeW50aCk7XG4gICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAgKiAgICB0ZXh0KCdjbGljayB0byBwbGF5JywgMjAsIDIwKTtcbiAgICAqXG4gICAgKiAgICBwb2x5U3ludGggPSBuZXcgcDUuUG9seVN5bnRoKCk7XG4gICAgKiAgfVxuICAgICpcbiAgICAqICBmdW5jdGlvbiBwbGF5U3ludGgoKSB7XG4gICAgKiAgICB1c2VyU3RhcnRBdWRpbygpO1xuICAgICpcbiAgICAqICAgIC8vIG5vdGUgZHVyYXRpb24gKGluIHNlY29uZHMpXG4gICAgKiAgICBsZXQgZHVyID0gMS41O1xuICAgICpcbiAgICAqICAgIC8vIHRpbWUgZnJvbSBub3cgKGluIHNlY29uZHMpXG4gICAgKiAgICBsZXQgdGltZSA9IDA7XG4gICAgKlxuICAgICogICAgLy8gdmVsb2NpdHkgKHZvbHVtZSwgZnJvbSAwIHRvIDEpXG4gICAgKiAgICBsZXQgdmVsID0gMC4xO1xuICAgICpcbiAgICAqICAgIC8vIG5vdGVzIGNhbiBvdmVybGFwIHdpdGggZWFjaCBvdGhlclxuICAgICogICAgcG9seVN5bnRoLnBsYXkoJ0cyJywgdmVsLCAwLCBkdXIpO1xuICAgICogICAgcG9seVN5bnRoLnBsYXkoJ0MzJywgdmVsLCB0aW1lICs9IDEvMywgZHVyKTtcbiAgICAqICAgIHBvbHlTeW50aC5wbGF5KCdHMycsIHZlbCwgdGltZSArPSAxLzMsIGR1cik7XG4gICAgKiAgfVxuICAgICogIDwvY29kZT48L2Rpdj5cbiAgICAqKi9cblxuXG4gIHA1LlBvbHlTeW50aCA9IGZ1bmN0aW9uIChhdWRpb1ZvaWNlLCBtYXhWb2ljZXMpIHtcbiAgICB0aGlzLmF1ZGlvdm9pY2VzID0gW107XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRoYXQgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2ggbm90ZXMgaGF2ZSBiZWVuIHBsYXllZCBhbmRcbiAgICAgKiB3aGljaCBub3RlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBsYXllZC4gTmV3IG5vdGVzIGFyZSBhZGRlZCBhcyBrZXlzXG4gICAgICogb24gdGhlIGZseS4gV2hpbGUgYSBub3RlIGhhcyBiZWVuIGF0dGFja2VkLCBidXQgbm90IHJlbGVhc2VkLCB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICoga2V5IGlzIHRoZSBhdWRpb3ZvaWNlIHdoaWNoIGlzIGdlbmVyYXRpbmcgdGhhdCBub3RlLiBXaGVuIG5vdGVzIGFyZSByZWxlYXNlZCxcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhlIGtleSBiZWNvbWVzIHVuZGVmaW5lZC5cbiAgICAgKiBAcHJvcGVydHkgbm90ZXNcbiAgICAgKi9cblxuICAgIHRoaXMubm90ZXMgPSB7fTsgXG5cbiAgICB0aGlzLl9uZXdlc3QgPSAwO1xuICAgIHRoaXMuX29sZGVzdCA9IDA7XG4gICAgLyoqXG4gICAgICogQSBQb2x5U3ludGggbXVzdCBoYXZlIGF0IGxlYXN0IDEgdm9pY2UsIGRlZmF1bHRzIHRvIDhcbiAgICAgKiBAcHJvcGVydHkgcG9seXZhbHVlXG4gICAgICovXG5cbiAgICB0aGlzLm1heFZvaWNlcyA9IG1heFZvaWNlcyB8fCA4O1xuICAgIC8qKlxuICAgICAqIE1vbm9zeW50aCB0aGF0IGdlbmVyYXRlcyB0aGUgc291bmQgZm9yIGVhY2ggbm90ZSB0aGF0IGlzIHRyaWdnZXJlZC4gVGhlXG4gICAgICogcDUuUG9seVN5bnRoIGRlZmF1bHRzIHRvIHVzaW5nIHRoZSBwNS5Nb25vU3ludGggYXMgaXRzIHZvaWNlLlxuICAgICAqIEBwcm9wZXJ0eSBBdWRpb1ZvaWNlXG4gICAgICovXG5cbiAgICB0aGlzLkF1ZGlvVm9pY2UgPSBhdWRpb1ZvaWNlID09PSB1bmRlZmluZWQgPyBwNS5Nb25vU3ludGggOiBhdWRpb1ZvaWNlO1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgbXVzdCBvbmx5IGNoYW5nZSBhcyBhIG5vdGUgaXMgYXR0YWNrZWQgb3IgcmVsZWFzZWQuIER1ZSB0byBkZWxheVxuICAgICAqIGFuZCBzdXN0YWluIHRpbWVzLCBUb25lLlRpbWVsaW5lU2lnbmFsIGlzIHJlcXVpcmVkIHRvIHNjaGVkdWxlIHRoZSBjaGFuZ2UgaW4gdmFsdWUuXG4gICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7VG9uZS5UaW1lbGluZVNpZ25hbH0gX3ZvaWNlc0luVXNlXG4gICAgICovXG5cbiAgICB0aGlzLl92b2ljZXNJblVzZSA9IG5ldyBUaW1lbGluZVNpZ25hbCgwKTtcbiAgICB0aGlzLm91dHB1dCA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLmNvbm5lY3QoKTsgXG5cbiAgICB0aGlzLl9hbGxvY2F0ZVZvaWNlcygpO1xuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdWRpb3ZvaWNlc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAZm9yIHA1LlBvbHlTeW50aFxuICAgKiBAbWV0aG9kICBfYWxsb2NhdGVWb2ljZXNcbiAgICovXG5cblxuICBwNS5Qb2x5U3ludGgucHJvdG90eXBlLl9hbGxvY2F0ZVZvaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWF4Vm9pY2VzOyBpKyspIHtcbiAgICAgIHRoaXMuYXVkaW92b2ljZXMucHVzaChuZXcgdGhpcy5BdWRpb1ZvaWNlKCkpO1xuICAgICAgdGhpcy5hdWRpb3ZvaWNlc1tpXS5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmF1ZGlvdm9pY2VzW2ldLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBQbGF5IGEgbm90ZSBieSB0cmlnZ2VyaW5nIG5vdGVBdHRhY2sgYW5kIG5vdGVSZWxlYXNlIHdpdGggc3VzdGFpbiB0aW1lXG4gICAqXG4gICAqICBAbWV0aG9kICBwbGF5XG4gICAqICBAZm9yIHA1LlBvbHlTeW50aFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbbm90ZV0gbWlkaSBub3RlIHRvIHBsYXkgKHJhbmdpbmcgZnJvbSAwIHRvIDEyNyAtIDYwIGJlaW5nIGEgbWlkZGxlIEMpXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt2ZWxvY2l0eV0gdmVsb2NpdHkgb2YgdGhlIG5vdGUgdG8gcGxheSAocmFuZ2luZyBmcm9tIDAgdG8gMSlcbiAgICogIEBwYXJhbSAge051bWJlcn0gW3NlY29uZHNGcm9tTm93XSAgdGltZSBmcm9tIG5vdyAoaW4gc2Vjb25kcykgYXQgd2hpY2ggdG8gcGxheVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbc3VzdGFpblRpbWVdIHRpbWUgdG8gc3VzdGFpbiBiZWZvcmUgcmVsZWFzaW5nIHRoZSBlbnZlbG9wZVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgcG9seVN5bnRoO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTeW50aCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgnY2xpY2sgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqXG4gICAqICAgIHBvbHlTeW50aCA9IG5ldyBwNS5Qb2x5U3ludGgoKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlTeW50aCgpIHtcbiAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICpcbiAgICogICAgLy8gbm90ZSBkdXJhdGlvbiAoaW4gc2Vjb25kcylcbiAgICogICAgbGV0IGR1ciA9IDEuNTtcbiAgICpcbiAgICogICAgLy8gdGltZSBmcm9tIG5vdyAoaW4gc2Vjb25kcylcbiAgICogICAgbGV0IHRpbWUgPSAwO1xuICAgKlxuICAgKiAgICAvLyB2ZWxvY2l0eSAodm9sdW1lLCBmcm9tIDAgdG8gMSlcbiAgICogICAgbGV0IHZlbCA9IDAuMTtcbiAgICpcbiAgICogICAgLy8gbm90ZXMgY2FuIG92ZXJsYXAgd2l0aCBlYWNoIG90aGVyXG4gICAqICAgIHBvbHlTeW50aC5wbGF5KCdHMicsIHZlbCwgMCwgZHVyKTtcbiAgICogICAgcG9seVN5bnRoLnBsYXkoJ0MzJywgdmVsLCB0aW1lICs9IDEvMywgZHVyKTtcbiAgICogICAgcG9seVN5bnRoLnBsYXkoJ0czJywgdmVsLCB0aW1lICs9IDEvMywgZHVyKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5Qb2x5U3ludGgucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAobm90ZSwgdmVsb2NpdHksIHNlY29uZHNGcm9tTm93LCBzdXNUaW1lKSB7XG4gICAgdmFyIHN1c1RpbWUgPSBzdXNUaW1lIHx8IDE7XG4gICAgdGhpcy5ub3RlQXR0YWNrKG5vdGUsIHZlbG9jaXR5LCBzZWNvbmRzRnJvbU5vdyk7XG4gICAgdGhpcy5ub3RlUmVsZWFzZShub3RlLCBzZWNvbmRzRnJvbU5vdyArIHN1c1RpbWUpO1xuICB9O1xuICAvKipcbiAgICogIG5vdGVBRFNSIHNldHMgdGhlIGVudmVsb3BlIGZvciBhIHNwZWNpZmljIG5vdGUgdGhhdCBoYXMganVzdCBiZWVuIHRyaWdnZXJlZC5cbiAgICogIFVzaW5nIHRoaXMgbWV0aG9kIG1vZGlmaWVzIHRoZSBlbnZlbG9wZSBvZiB3aGljaGV2ZXIgYXVkaW92b2ljZSBpcyBiZWluZyB1c2VkXG4gICAqICB0byBwbGF5IHRoZSBkZXNpcmVkIG5vdGUuIFRoZSBlbnZlbG9wZSBzaG91bGQgYmUgcmVzZXQgYmVmb3JlIG5vdGVSZWxlYXNlIGlzIGNhbGxlZFxuICAgKiAgaW4gb3JkZXIgdG8gcHJldmVudCB0aGUgbW9kaWZpZWQgZW52ZWxvcGUgZnJvbSBiZWluZyB1c2VkIG9uIG90aGVyIG5vdGVzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbm90ZUFEU1JcbiAgICogIEBmb3IgcDUuUG9seVN5bnRoXG4gICAqICBAcGFyYW0ge051bWJlcn0gW25vdGVdICAgICAgICBNaWRpIG5vdGUgb24gd2hpY2ggQURTUiBzaG91bGQgYmUgc2V0LlxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFthdHRhY2tUaW1lXSAgVGltZSAoaW4gc2Vjb25kcyBiZWZvcmUgZW52ZWxvcGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWNoZXMgQXR0YWNrIExldmVsXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2RlY2F5VGltZV0gICBUaW1lIChpbiBzZWNvbmRzKSBiZWZvcmUgZW52ZWxvcGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWNoZXMgRGVjYXkvU3VzdGFpbiBMZXZlbFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtzdXNSYXRpb10gICAgUmF0aW8gYmV0d2VlbiBhdHRhY2tMZXZlbCBhbmQgcmVsZWFzZUxldmVsLCBvbiBhIHNjYWxlIGZyb20gMCB0byAxLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmUgMS4wID0gYXR0YWNrTGV2ZWwsIDAuMCA9IHJlbGVhc2VMZXZlbC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBzdXNSYXRpbyBkZXRlcm1pbmVzIHRoZSBkZWNheUxldmVsIGFuZCB0aGUgbGV2ZWwgYXQgd2hpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXN0YWluIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlIHdpbGwgc3VzdGFpbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvciBleGFtcGxlLCBpZiBhdHRhY2tMZXZlbCBpcyAwLjQsIHJlbGVhc2VMZXZlbCBpcyAwLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHN1c0FtdCBpcyAwLjUsIHRoZSBkZWNheUxldmVsIHdvdWxkIGJlIDAuMi4gSWYgYXR0YWNrTGV2ZWwgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlYXNlZCB0byAxLjAgKHVzaW5nIDxjb2RlPnNldFJhbmdlPC9jb2RlPiksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGRlY2F5TGV2ZWwgd291bGQgaW5jcmVhc2UgcHJvcG9ydGlvbmFsbHksIHRvIGJlY29tZSAwLjUuXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3JlbGVhc2VUaW1lXSAgIFRpbWUgaW4gc2Vjb25kcyBmcm9tIG5vdyAoZGVmYXVsdHMgdG8gMClcbiAgICoqL1xuXG5cbiAgcDUuUG9seVN5bnRoLnByb3RvdHlwZS5ub3RlQURTUiA9IGZ1bmN0aW9uIChub3RlLCBhLCBkLCBzLCByLCB0aW1lRnJvbU5vdykge1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgdGltZUZyb21Ob3cgPSB0aW1lRnJvbU5vdyB8fCAwO1xuICAgIHZhciB0ID0gbm93ICsgdGltZUZyb21Ob3c7XG4gICAgdGhpcy5hdWRpb3ZvaWNlc1t0aGlzLm5vdGVzW25vdGVdLmdldFZhbHVlQXRUaW1lKHQpXS5zZXRBRFNSKGEsIGQsIHMsIHIpO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRoZSBQb2x5U3ludGhzIGdsb2JhbCBlbnZlbG9wZS4gVGhpcyBtZXRob2QgbW9kaWZpZXMgdGhlIGVudmVsb3BlcyBvZiBlYWNoXG4gICAqIG1vbm9zeW50aCBzbyB0aGF0IGFsbCBub3RlcyBhcmUgcGxheWVkIHdpdGggdGhpcyBlbnZlbG9wZS5cbiAgICpcbiAgICogIEBtZXRob2QgIHNldEFEU1JcbiAgICogIEBmb3IgcDUuUG9seVN5bnRoXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2F0dGFja1RpbWVdICBUaW1lIChpbiBzZWNvbmRzIGJlZm9yZSBlbnZlbG9wZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhY2hlcyBBdHRhY2sgTGV2ZWxcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbZGVjYXlUaW1lXSAgIFRpbWUgKGluIHNlY29uZHMpIGJlZm9yZSBlbnZlbG9wZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhY2hlcyBEZWNheS9TdXN0YWluIExldmVsXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3N1c1JhdGlvXSAgICBSYXRpbyBiZXR3ZWVuIGF0dGFja0xldmVsIGFuZCByZWxlYXNlTGV2ZWwsIG9uIGEgc2NhbGUgZnJvbSAwIHRvIDEsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSAxLjAgPSBhdHRhY2tMZXZlbCwgMC4wID0gcmVsZWFzZUxldmVsLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHN1c1JhdGlvIGRldGVybWluZXMgdGhlIGRlY2F5TGV2ZWwgYW5kIHRoZSBsZXZlbCBhdCB3aGljaCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3RhaW4gcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUgd2lsbCBzdXN0YWluLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUsIGlmIGF0dGFja0xldmVsIGlzIDAuNCwgcmVsZWFzZUxldmVsIGlzIDAsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc3VzQW10IGlzIDAuNSwgdGhlIGRlY2F5TGV2ZWwgd291bGQgYmUgMC4yLiBJZiBhdHRhY2tMZXZlbCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVhc2VkIHRvIDEuMCAodXNpbmcgPGNvZGU+c2V0UmFuZ2U8L2NvZGU+KSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gZGVjYXlMZXZlbCB3b3VsZCBpbmNyZWFzZSBwcm9wb3J0aW9uYWxseSwgdG8gYmVjb21lIDAuNS5cbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbcmVsZWFzZVRpbWVdICAgVGltZSBpbiBzZWNvbmRzIGZyb20gbm93IChkZWZhdWx0cyB0byAwKVxuICAgKiovXG5cblxuICBwNS5Qb2x5U3ludGgucHJvdG90eXBlLnNldEFEU1IgPSBmdW5jdGlvbiAoYSwgZCwgcywgcikge1xuICAgIHRoaXMuYXVkaW92b2ljZXMuZm9yRWFjaChmdW5jdGlvbiAodm9pY2UpIHtcbiAgICAgIHZvaWNlLnNldEFEU1IoYSwgZCwgcywgcik7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiAgVHJpZ2dlciB0aGUgQXR0YWNrLCBhbmQgRGVjYXkgcG9ydGlvbiBvZiBhIE1vbm9TeW50aC5cbiAgICogIFNpbWlsYXIgdG8gaG9sZGluZyBkb3duIGEga2V5IG9uIGEgcGlhbm8sIGJ1dCBpdCB3aWxsXG4gICAqICBob2xkIHRoZSBzdXN0YWluIGxldmVsIHVudGlsIHlvdSBsZXQgZ28uXG4gICAqXG4gICAqICBAbWV0aG9kICBub3RlQXR0YWNrXG4gICAqICBAZm9yIHA1LlBvbHlTeW50aFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbbm90ZV0gICAgICAgICAgIG1pZGkgbm90ZSBvbiB3aGljaCBhdHRhY2sgc2hvdWxkIGJlIHRyaWdnZXJlZC5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW3ZlbG9jaXR5XSAgICAgICB2ZWxvY2l0eSBvZiB0aGUgbm90ZSB0byBwbGF5IChyYW5naW5nIGZyb20gMCB0byAxKS9cbiAgICogIEBwYXJhbSAge051bWJlcn0gW3NlY29uZHNGcm9tTm93XSB0aW1lIGZyb20gbm93IChpbiBzZWNvbmRzKVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgcG9seVN5bnRoID0gbmV3IHA1LlBvbHlTeW50aCgpO1xuICAgKiAgbGV0IHBpdGNoZXMgPSBbJ0cnLCAnRCcsICdHJywgJ0MnXTtcbiAgICogIGxldCBvY3RhdmVzID0gWzIsIDMsIDRdO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlDaG9yZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheUNob3JkKCkge1xuICAgKiAgICB1c2VyU3RhcnRBdWRpbygpO1xuICAgKlxuICAgKiAgICAvLyBwbGF5IGEgY2hvcmQ6IG11bHRpcGxlIG5vdGVzIGF0IHRoZSBzYW1lIHRpbWVcbiAgICogICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICogICAgICBsZXQgbm90ZSA9IHJhbmRvbShwaXRjaGVzKSArIHJhbmRvbShvY3RhdmVzKTtcbiAgICogICAgICBwb2x5U3ludGgubm90ZUF0dGFjayhub3RlLCAwLjEpO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICAvLyByZWxlYXNlIGFsbCB2b2ljZXNcbiAgICogICAgcG9seVN5bnRoLm5vdGVSZWxlYXNlKCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuUG9seVN5bnRoLnByb3RvdHlwZS5ub3RlQXR0YWNrID0gZnVuY3Rpb24gKF9ub3RlLCBfdmVsb2NpdHksIHNlY29uZHNGcm9tTm93KSB7XG4gICAgdmFyIHNlY29uZHNGcm9tTm93ID0gfn5zZWNvbmRzRnJvbU5vdzsgXG5cbiAgICB2YXIgYWNUaW1lID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWUgKyBzZWNvbmRzRnJvbU5vdzsgXG5cbiAgICB2YXIgbm90ZSA9IG5vdGVUb0ZyZXEoX25vdGUpO1xuICAgIHZhciB2ZWxvY2l0eSA9IF92ZWxvY2l0eSB8fCAwLjE7XG4gICAgdmFyIGN1cnJlbnRWb2ljZTsgXG5cbiAgICBpZiAodGhpcy5ub3Rlc1tub3RlXSAmJiB0aGlzLm5vdGVzW25vdGVdLmdldFZhbHVlQXRUaW1lKGFjVGltZSkgIT09IG51bGwpIHtcbiAgICAgIHRoaXMubm90ZVJlbGVhc2Uobm90ZSwgMCk7XG4gICAgfSBcblxuXG4gICAgaWYgKHRoaXMuX3ZvaWNlc0luVXNlLmdldFZhbHVlQXRUaW1lKGFjVGltZSkgPCB0aGlzLm1heFZvaWNlcykge1xuICAgICAgY3VycmVudFZvaWNlID0gTWF0aC5tYXgofn50aGlzLl92b2ljZXNJblVzZS5nZXRWYWx1ZUF0VGltZShhY1RpbWUpLCAwKTtcbiAgICB9IFxuICAgIGVsc2Uge1xuICAgICAgICBjdXJyZW50Vm9pY2UgPSB0aGlzLl9vbGRlc3Q7XG4gICAgICAgIHZhciBvbGRlc3ROb3RlID0gcDUucHJvdG90eXBlLmZyZXFUb01pZGkodGhpcy5hdWRpb3ZvaWNlc1t0aGlzLl9vbGRlc3RdLm9zY2lsbGF0b3IuZnJlcSgpLnZhbHVlKTtcbiAgICAgICAgdGhpcy5ub3RlUmVsZWFzZShvbGRlc3ROb3RlKTtcbiAgICAgICAgdGhpcy5fb2xkZXN0ID0gKHRoaXMuX29sZGVzdCArIDEpICUgKHRoaXMubWF4Vm9pY2VzIC0gMSk7XG4gICAgICB9IFxuXG5cbiAgICB0aGlzLm5vdGVzW25vdGVdID0gbmV3IFRpbWVsaW5lU2lnbmFsKCk7XG4gICAgdGhpcy5ub3Rlc1tub3RlXS5zZXRWYWx1ZUF0VGltZShjdXJyZW50Vm9pY2UsIGFjVGltZSk7IFxuXG4gICAgdmFyIHByZXZpb3VzVmFsID0gdGhpcy5fdm9pY2VzSW5Vc2UuX3NlYXJjaEJlZm9yZShhY1RpbWUpID09PSBudWxsID8gMCA6IHRoaXMuX3ZvaWNlc0luVXNlLl9zZWFyY2hCZWZvcmUoYWNUaW1lKS52YWx1ZTtcblxuICAgIHRoaXMuX3ZvaWNlc0luVXNlLnNldFZhbHVlQXRUaW1lKHByZXZpb3VzVmFsICsgMSwgYWNUaW1lKTsgXG5cblxuICAgIHRoaXMuX3VwZGF0ZUFmdGVyKGFjVGltZSwgMSk7XG5cbiAgICB0aGlzLl9uZXdlc3QgPSBjdXJyZW50Vm9pY2U7IFxuXG4gICAgaWYgKHR5cGVvZiB2ZWxvY2l0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBtYXhSYW5nZSA9IDEgLyB0aGlzLl92b2ljZXNJblVzZS5nZXRWYWx1ZUF0VGltZShhY1RpbWUpICogMjtcbiAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHkgPiBtYXhSYW5nZSA/IG1heFJhbmdlIDogdmVsb2NpdHk7XG4gICAgfVxuXG4gICAgdGhpcy5hdWRpb3ZvaWNlc1tjdXJyZW50Vm9pY2VdLnRyaWdnZXJBdHRhY2sobm90ZSwgdmVsb2NpdHksIHNlY29uZHNGcm9tTm93KTtcbiAgfTtcbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kIHRvIGVuc3VyZSBhY2N1cmF0ZSB2YWx1ZXMgb2YgdGhpcy5fdm9pY2VzSW5Vc2VcbiAgICogQW55IHRpbWUgYSBuZXcgdmFsdWUgaXMgc2NoZWR1bGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gaW5jcmVtZW50IGFsbCBzdWJzZXF1ZW50XG4gICAqIHNjaGVkdWxlZFZhbHVlcyBhZnRlciBhdHRhY2ssIGFuZCBkZWNyZW1lbnQgYWxsIHN1YnNlcXVlbnRcbiAgICogc2NoZWR1bGVkVmFsdWVzIGFmdGVyIHJlbGVhc2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZvciBwNS5Qb2x5U3ludGhcbiAgICogQHBhcmFtICB7W3R5cGVdfSB0aW1lICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gdmFsdWUgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG5cblxuICBwNS5Qb2x5U3ludGgucHJvdG90eXBlLl91cGRhdGVBZnRlciA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl92b2ljZXNJblVzZS5fc2VhcmNoQWZ0ZXIodGltZSkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdm9pY2VzSW5Vc2UuX3NlYXJjaEFmdGVyKHRpbWUpLnZhbHVlICs9IHZhbHVlO1xuXG4gICAgICB2YXIgbmV4dFRpbWUgPSB0aGlzLl92b2ljZXNJblVzZS5fc2VhcmNoQWZ0ZXIodGltZSkudGltZTtcblxuICAgICAgdGhpcy5fdXBkYXRlQWZ0ZXIobmV4dFRpbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgVHJpZ2dlciB0aGUgUmVsZWFzZSBvZiBhbiBBdWRpb1ZvaWNlIG5vdGUuIFRoaXMgaXMgc2ltaWxhciB0byByZWxlYXNpbmdcbiAgICogIHRoZSBrZXkgb24gYSBwaWFubyBhbmQgbGV0dGluZyB0aGUgc291bmQgZmFkZSBhY2NvcmRpbmcgdG8gdGhlXG4gICAqICByZWxlYXNlIGxldmVsIGFuZCByZWxlYXNlIHRpbWUuXG4gICAqXG4gICAqICBAbWV0aG9kICBub3RlUmVsZWFzZVxuICAgKiAgQGZvciBwNS5Qb2x5U3ludGhcbiAgICogIEBwYXJhbSAge051bWJlcn0gW25vdGVdICAgICAgICAgICBtaWRpIG5vdGUgb24gd2hpY2ggYXR0YWNrIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQsIGFsbCBub3RlcyB3aWxsIGJlIHJlbGVhc2VkLlxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbc2Vjb25kc0Zyb21Ob3ddIHRpbWUgdG8gdHJpZ2dlciB0aGUgcmVsZWFzZVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgcG9seVN5bnRoID0gbmV3IHA1LlBvbHlTeW50aCgpO1xuICAgKiAgbGV0IHBpdGNoZXMgPSBbJ0cnLCAnRCcsICdHJywgJ0MnXTtcbiAgICogIGxldCBvY3RhdmVzID0gWzIsIDMsIDRdO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlDaG9yZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheUNob3JkKCkge1xuICAgKiAgICB1c2VyU3RhcnRBdWRpbygpO1xuICAgKlxuICAgKiAgICAvLyBwbGF5IGEgY2hvcmQ6IG11bHRpcGxlIG5vdGVzIGF0IHRoZSBzYW1lIHRpbWVcbiAgICogICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICogICAgICBsZXQgbm90ZSA9IHJhbmRvbShwaXRjaGVzKSArIHJhbmRvbShvY3RhdmVzKTtcbiAgICogICAgICBwb2x5U3ludGgubm90ZUF0dGFjayhub3RlLCAwLjEpO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICAvLyByZWxlYXNlIGFsbCB2b2ljZXNcbiAgICogICAgcG9seVN5bnRoLm5vdGVSZWxlYXNlKCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqXG4gICAqL1xuXG5cbiAgcDUuUG9seVN5bnRoLnByb3RvdHlwZS5ub3RlUmVsZWFzZSA9IGZ1bmN0aW9uIChfbm90ZSwgc2Vjb25kc0Zyb21Ob3cpIHtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIHRGcm9tTm93ID0gc2Vjb25kc0Zyb21Ob3cgfHwgMDtcbiAgICB2YXIgdCA9IG5vdyArIHRGcm9tTm93OyBcblxuICAgIGlmICghX25vdGUpIHtcbiAgICAgIHRoaXMuYXVkaW92b2ljZXMuZm9yRWFjaChmdW5jdGlvbiAodm9pY2UpIHtcbiAgICAgICAgdm9pY2UudHJpZ2dlclJlbGVhc2UodEZyb21Ob3cpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3ZvaWNlc0luVXNlLnNldFZhbHVlQXRUaW1lKDAsIHQpO1xuXG4gICAgICBmb3IgKHZhciBuIGluIHRoaXMubm90ZXMpIHtcbiAgICAgICAgdGhpcy5ub3Rlc1tuXS5kaXNwb3NlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5vdGVzW25dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSBcblxuXG4gICAgdmFyIG5vdGUgPSBub3RlVG9GcmVxKF9ub3RlKTtcblxuICAgIGlmICghdGhpcy5ub3Rlc1tub3RlXSB8fCB0aGlzLm5vdGVzW25vdGVdLmdldFZhbHVlQXRUaW1lKHQpID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCByZWxlYXNlIGEgbm90ZSB0aGF0IGlzIG5vdCBhbHJlYWR5IHBsYXlpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXZpb3VzVmFsID0gTWF0aC5tYXgofn50aGlzLl92b2ljZXNJblVzZS5nZXRWYWx1ZUF0VGltZSh0KS52YWx1ZSwgMSk7XG5cbiAgICAgIHRoaXMuX3ZvaWNlc0luVXNlLnNldFZhbHVlQXRUaW1lKHByZXZpb3VzVmFsIC0gMSwgdCk7IFxuXG5cbiAgICAgIGlmIChwcmV2aW91c1ZhbCA+IDApIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQWZ0ZXIodCwgLTEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmF1ZGlvdm9pY2VzW3RoaXMubm90ZXNbbm90ZV0uZ2V0VmFsdWVBdFRpbWUodCldLnRyaWdnZXJSZWxlYXNlKHRGcm9tTm93KTtcbiAgICAgIHRoaXMubm90ZXNbbm90ZV0uZGlzcG9zZSgpO1xuICAgICAgZGVsZXRlIHRoaXMubm90ZXNbbm90ZV07XG4gICAgICB0aGlzLl9uZXdlc3QgPSB0aGlzLl9uZXdlc3QgPT09IDAgPyAwIDogKHRoaXMuX25ld2VzdCAtIDEpICUgKHRoaXMubWF4Vm9pY2VzIC0gMSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICAqICBDb25uZWN0IHRvIGEgcDUuc291bmQgLyBXZWIgQXVkaW8gb2JqZWN0LlxuICAgICpcbiAgICAqICBAbWV0aG9kICBjb25uZWN0XG4gICAgKiAgQGZvciBwNS5Qb2x5U3ludGhcbiAgICAqICBAcGFyYW0gIHtPYmplY3R9IHVuaXQgQSBwNS5zb3VuZCBvciBXZWIgQXVkaW8gb2JqZWN0XG4gICAgKi9cblxuXG4gIHA1LlBvbHlTeW50aC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdmFyIHUgPSB1bml0IHx8IHA1c291bmQuaW5wdXQ7XG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh1LmlucHV0ID8gdS5pbnB1dCA6IHUpO1xuICB9O1xuICAvKipcbiAgKiAgRGlzY29ubmVjdCBhbGwgb3V0cHV0c1xuICAqXG4gICogIEBtZXRob2QgIGRpc2Nvbm5lY3RcbiAgKiAgQGZvciBwNS5Qb2x5U3ludGhcbiAgKi9cblxuXG4gIHA1LlBvbHlTeW50aC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgICogIEdldCByaWQgb2YgdGhlIE1vbm9TeW50aCBhbmQgZnJlZSB1cCBpdHMgcmVzb3VyY2VzIC8gbWVtb3J5LlxuICAgICpcbiAgICAqICBAbWV0aG9kICBkaXNwb3NlXG4gICAgKiAgQGZvciBwNS5Qb2x5U3ludGhcbiAgICAqL1xuXG5cbiAgcDUuUG9seVN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXVkaW92b2ljZXMuZm9yRWFjaChmdW5jdGlvbiAodm9pY2UpIHtcbiAgICAgIHZvaWNlLmRpc3Bvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMub3V0cHV0O1xuICAgIH1cbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxuICB2YXIgcDVTT1VORCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxuICByZXR1cm4gcDVTT1VORDtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4hZnVuY3Rpb24oKXt2YXIgbCxzPVtdO2Z1bmN0aW9uIHAoZSl7dmFyIG89dGhpcyxuPXt9LGk9LTE7dGhpcy5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24oZSx0KXt2YXIgcj1zWysraV18fChzW2ldPW5ldyBGbG9hdDMyQXJyYXkoby5idWZmZXJTaXplKSk7ci5maWxsKGUudmFsdWUpLG5bdF09cn0pLHRoaXMucHJvY2Vzc29yLnJlYWxtLmV4ZWMoXCJzZWxmLnNhbXBsZVJhdGU9c2FtcGxlUmF0ZT1cIit0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZStcIjtzZWxmLmN1cnJlbnRUaW1lPWN1cnJlbnRUaW1lPVwiK3RoaXMuY29udGV4dC5jdXJyZW50VGltZSk7dmFyIHQ9YShlLmlucHV0QnVmZmVyKSxyPWEoZS5vdXRwdXRCdWZmZXIpO3RoaXMuaW5zdGFuY2UucHJvY2VzcyhbdF0sW3JdLG4pfWZ1bmN0aW9uIGEoZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubnVtYmVyT2ZDaGFubmVscztyKyspdFtyXT1lLmdldENoYW5uZWxEYXRhKHIpO3JldHVybiB0fWZ1bmN0aW9uIGYoZSl7cmV0dXJuIGUuJCRwcm9jZXNzb3JzfHwoZS4kJHByb2Nlc3NvcnM9e30pfWZ1bmN0aW9uIGUoZSl7dGhpcy4kJGNvbnRleHQ9ZX1cImZ1bmN0aW9uXCIhPXR5cGVvZiBBdWRpb1dvcmtsZXROb2RlJiYoc2VsZi5BdWRpb1dvcmtsZXROb2RlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbz1mKGUpW3RdLG49ZS5jcmVhdGVTY3JpcHRQcm9jZXNzb3Iodm9pZCAwLDIsciYmci5vdXRwdXRDaGFubmVsQ291bnQ/ci5vdXRwdXRDaGFubmVsQ291bnRbMF06Mik7aWYobi5wYXJhbWV0ZXJzPW5ldyBNYXAsby5wcm9wZXJ0aWVzKWZvcih2YXIgaT0wO2k8by5wcm9wZXJ0aWVzLmxlbmd0aDtpKyspe3ZhciBzPW8ucHJvcGVydGllc1tpXSxhPWUuY3JlYXRlR2FpbigpLmdhaW47YS52YWx1ZT1zLmRlZmF1bHRWYWx1ZSxuLnBhcmFtZXRlcnMuc2V0KHMubmFtZSxhKX12YXIgdT1uZXcgTWVzc2FnZUNoYW5uZWw7bD11LnBvcnQyO3ZhciBjPW5ldyBvLlByb2Nlc3NvcihyfHx7fSk7cmV0dXJuIGw9bnVsbCxuLnBvcnQ9dS5wb3J0MSxuLnByb2Nlc3Nvcj1vLG4uaW5zdGFuY2U9YyxuLm9uYXVkaW9wcm9jZXNzPXAsbn0sT2JqZWN0LmRlZmluZVByb3BlcnR5KChzZWxmLkF1ZGlvQ29udGV4dHx8c2VsZi53ZWJraXRBdWRpb0NvbnRleHQpLnByb3RvdHlwZSxcImF1ZGlvV29ya2xldFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kJGF1ZGlvV29ya2xldHx8KHRoaXMuJCRhdWRpb1dvcmtsZXQ9bmV3IHNlbGYuQXVkaW9Xb3JrbGV0KHRoaXMpKX19KSxzZWxmLkF1ZGlvV29ya2xldD0oZS5wcm90b3R5cGUuYWRkTW9kdWxlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gZmV0Y2goZSkudGhlbihmdW5jdGlvbihlKXtpZighZS5vayl0aHJvdyBFcnJvcihlLnN0YXR1cyk7cmV0dXJuIGUudGV4dCgpfSkudGhlbihmdW5jdGlvbihlKXt2YXIgcj17c2FtcGxlUmF0ZTowLGN1cnJlbnRUaW1lOjAsQXVkaW9Xb3JrbGV0UHJvY2Vzc29yOmZ1bmN0aW9uKCl7dGhpcy5wb3J0PWx9LHJlZ2lzdGVyUHJvY2Vzc29yOmZ1bmN0aW9uKGUsdCl7ZihuLiQkY29udGV4dClbZV09e3JlYWxtOm8sY29udGV4dDpyLFByb2Nlc3Nvcjp0LHByb3BlcnRpZXM6dC5wYXJhbWV0ZXJEZXNjcmlwdG9yc3x8W119fX0sbz1uZXcgZnVuY3Rpb24oZSx0KXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO3Iuc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6LTk5OXB4O3dpZHRoOjFweDtoZWlnaHQ6MXB4O1wiLHQuYXBwZW5kQ2hpbGQocik7dmFyIG89ci5jb250ZW50V2luZG93LG49by5kb2N1bWVudCxpPVwidmFyIHdpbmRvdywkaG9va1wiO2Zvcih2YXIgcyBpbiBvKXMgaW4gZXx8XCJldmFsXCI9PT1zfHwoaSs9XCIsXCIsaSs9cyk7Zm9yKHZhciBhIGluIGUpaSs9XCIsXCIsaSs9YSxpKz1cIj1zZWxmLlwiLGkrPWE7dmFyIHU9bi5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO3UuYXBwZW5kQ2hpbGQobi5jcmVhdGVUZXh0Tm9kZSgnZnVuY3Rpb24gJGhvb2soc2VsZixjb25zb2xlKSB7XCJ1c2Ugc3RyaWN0XCI7XFxuICAgICAgICAnK2krXCI7cmV0dXJuIGZ1bmN0aW9uKCkge3JldHVybiBldmFsKGFyZ3VtZW50c1swXSl9fVwiKSksbi5ib2R5LmFwcGVuZENoaWxkKHUpLHRoaXMuZXhlYz1vLiRob29rKGUsY29uc29sZSl9KHIuc2VsZj1yLGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7cmV0dXJuIG8uZXhlYygodCYmdC50cmFuc3BpbGV8fFN0cmluZykoZSkpLG51bGx9KX0sZSkpfSgpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcbi8qKlxuICogVGhpcyBtb2R1bGUgaGFzIHNoaW1zXG4gKi9cblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAoKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZml4U2V0VGFyZ2V0KHBhcmFtKSB7XG4gICAgICBpZiAoIXBhcmFtKSBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFwYXJhbS5zZXRUYXJnZXRBdFRpbWUpIHBhcmFtLnNldFRhcmdldEF0VGltZSA9IHBhcmFtLnNldFRhcmdldFZhbHVlQXRUaW1lO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdEF1ZGlvQ29udGV4dCcpICYmICF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvQ29udGV4dCcpKSB7XG4gICAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcbiAgICAgIGlmICh0eXBlb2YgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluICE9PSAnZnVuY3Rpb24nKSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW4gPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW5Ob2RlO1xuICAgICAgaWYgKHR5cGVvZiBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ICE9PSAnZnVuY3Rpb24nKSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheU5vZGU7XG4gICAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU2NyaXB0UHJvY2Vzc29yICE9PSAnZnVuY3Rpb24nKSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVNjcmlwdFByb2Nlc3NvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlSmF2YVNjcmlwdE5vZGU7XG4gICAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGVyaW9kaWNXYXZlICE9PSAnZnVuY3Rpb24nKSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBlcmlvZGljV2F2ZSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlV2F2ZVRhYmxlO1xuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluO1xuXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVHYWluKCk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmdhaW4pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG5cbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5O1xuXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gZnVuY3Rpb24gKG1heERlbGF5VGltZSkge1xuICAgICAgICB2YXIgbm9kZSA9IG1heERlbGF5VGltZSA/IHRoaXMuaW50ZXJuYWxfY3JlYXRlRGVsYXkobWF4RGVsYXlUaW1lKSA6IHRoaXMuaW50ZXJuYWxfY3JlYXRlRGVsYXkoKTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGVsYXlUaW1lKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9O1xuXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUJ1ZmZlclNvdXJjZSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlO1xuXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXG4gICAgICAgIGlmICghbm9kZS5zdGFydCkge1xuICAgICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAod2hlbiwgb2Zmc2V0LCBkdXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKG9mZnNldCB8fCBkdXJhdGlvbikgdGhpcy5ub3RlR3JhaW5Pbih3aGVuIHx8IDAsIG9mZnNldCwgZHVyYXRpb24pO2Vsc2UgdGhpcy5ub3RlT24od2hlbiB8fCAwKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQgPSBub2RlLnN0YXJ0O1xuXG4gICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICh3aGVuLCBvZmZzZXQsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGR1cmF0aW9uICE9PSAndW5kZWZpbmVkJykgbm9kZS5pbnRlcm5hbF9zdGFydCh3aGVuIHx8IDAsIG9mZnNldCwgZHVyYXRpb24pO2Vsc2Ugbm9kZS5pbnRlcm5hbF9zdGFydCh3aGVuIHx8IDAsIG9mZnNldCB8fCAwKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub2RlLnN0b3ApIHtcbiAgICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiAod2hlbikge1xuICAgICAgICAgICAgdGhpcy5ub3RlT2ZmKHdoZW4gfHwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AgPSBub2RlLnN0b3A7XG5cbiAgICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiAod2hlbikge1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wKHdoZW4gfHwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLnBsYXliYWNrUmF0ZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfTtcblxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcjtcblxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUudGhyZXNob2xkKTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUua25lZSk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLnJhdGlvKTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucmVkdWN0aW9uKTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuYXR0YWNrKTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucmVsZWFzZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfTtcblxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJpcXVhZEZpbHRlcjtcblxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZnJlcXVlbmN5KTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGV0dW5lKTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuUSk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmdhaW4pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2YgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVPc2NpbGxhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvcjtcblxuICAgICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZU9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZU9zY2lsbGF0b3IoKTtcblxuICAgICAgICAgIGlmICghbm9kZS5zdGFydCkge1xuICAgICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICh3aGVuKSB7XG4gICAgICAgICAgICAgIHRoaXMubm90ZU9uKHdoZW4gfHwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0ID0gbm9kZS5zdGFydDtcblxuICAgICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICh3aGVuKSB7XG4gICAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQod2hlbiB8fCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFub2RlLnN0b3ApIHtcbiAgICAgICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICh3aGVuKSB7XG4gICAgICAgICAgICAgIHRoaXMubm90ZU9mZih3aGVuIHx8IDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wID0gbm9kZS5zdG9wO1xuXG4gICAgICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiAod2hlbikge1xuICAgICAgICAgICAgICBub2RlLmludGVybmFsX3N0b3Aod2hlbiB8fCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFub2RlLnNldFBlcmlvZGljV2F2ZSkgbm9kZS5zZXRQZXJpb2RpY1dhdmUgPSBub2RlLnNldFdhdmVUYWJsZTtcbiAgICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICAgIGZpeFNldFRhcmdldChub2RlLmRldHVuZSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCcpICYmICF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ09mZmxpbmVBdWRpb0NvbnRleHQnKSkge1xuICAgICAgd2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICB9XG4gIH0pKHdpbmRvdyk7IFxuXG5cbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYTtcbiAgLyoqXG4gICAqIERldGVybWluZSB3aGljaCBmaWxldHlwZXMgYXJlIHN1cHBvcnRlZCAoaW5zcGlyZWQgYnkgYnV6ei5qcylcbiAgICogVGhlIGF1ZGlvIGVsZW1lbnQgKGVsKSB3aWxsIG9ubHkgYmUgdXNlZCB0byB0ZXN0IGJyb3dzZXIgc3VwcG9ydCBmb3IgdmFyaW91cyBhdWRpbyBmb3JtYXRzXG4gICAqL1xuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG5cbiAgcDUucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIWVsLmNhblBsYXlUeXBlO1xuICB9O1xuXG4gIHZhciBpc09HR1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzT0dHU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhIWVsLmNhblBsYXlUeXBlICYmIGVsLmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cInZvcmJpc1wiJyk7XG4gIH07XG5cbiAgdmFyIGlzTVAzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNNUDNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEhZWwuY2FuUGxheVR5cGUgJiYgZWwuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWc7Jyk7XG4gIH07XG5cbiAgdmFyIGlzV0FWU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNXQVZTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEhZWwuY2FuUGxheVR5cGUgJiYgZWwuY2FuUGxheVR5cGUoJ2F1ZGlvL3dhdjsgY29kZWNzPVwiMVwiJyk7XG4gIH07XG5cbiAgdmFyIGlzQUFDU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNBQUNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEhZWwuY2FuUGxheVR5cGUgJiYgKGVsLmNhblBsYXlUeXBlKCdhdWRpby94LW00YTsnKSB8fCBlbC5jYW5QbGF5VHlwZSgnYXVkaW8vYWFjOycpKTtcbiAgfTtcblxuICB2YXIgaXNBSUZTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc0FJRlN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gISFlbC5jYW5QbGF5VHlwZSAmJiBlbC5jYW5QbGF5VHlwZSgnYXVkaW8veC1haWZmOycpO1xuICB9O1xuXG4gIHA1LnByb3RvdHlwZS5pc0ZpbGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG4gICAgc3dpdGNoIChleHRlbnNpb24udG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgcmV0dXJuIGlzTVAzU3VwcG9ydGVkKCk7XG5cbiAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgIHJldHVybiBpc1dBVlN1cHBvcnRlZCgpO1xuXG4gICAgICBjYXNlICdvZ2cnOlxuICAgICAgICByZXR1cm4gaXNPR0dTdXBwb3J0ZWQoKTtcblxuICAgICAgY2FzZSAnYWFjJzpcbiAgICAgIGNhc2UgJ200YSc6XG4gICAgICBjYXNlICdtcDQnOlxuICAgICAgICByZXR1cm4gaXNBQUNTdXBwb3J0ZWQoKTtcblxuICAgICAgY2FzZSAnYWlmJzpcbiAgICAgIGNhc2UgJ2FpZmYnOlxuICAgICAgICByZXR1cm4gaXNBSUZTdXBwb3J0ZWQoKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e2c9Z3x8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaCh0KXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYoZz13aW5kb3cpfW1vZHVsZS5leHBvcnRzPWc7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyFmdW5jdGlvbihlLHQpeyB0cnVlPyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAodCksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTp1bmRlZmluZWR9KHRoaXMsZnVuY3Rpb24oKXt2YXIgcj1mdW5jdGlvbihlLHQpe3RoaXMuX2RyYWdnZWQ9ITEsdGhpcy5fZWxlbWVudD1lLHRoaXMuX2JpbmRlZE1vdmU9dGhpcy5fbW92ZWQuYmluZCh0aGlzKSx0aGlzLl9iaW5kZWRFbmQ9dGhpcy5fZW5kZWQuYmluZCh0aGlzLHQpLGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLl9iaW5kZWRFbmQpLGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMuX2JpbmRlZE1vdmUpLGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5fYmluZGVkRW5kKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5fYmluZGVkRW5kKX07ZnVuY3Rpb24gbyhlKXtyZXR1cm5cInJ1bm5pbmdcIj09PWUuc3RhdGV9cmV0dXJuIHIucHJvdG90eXBlLl9tb3ZlZD1mdW5jdGlvbihlKXt0aGlzLl9kcmFnZ2VkPSEwfSxyLnByb3RvdHlwZS5fZW5kZWQ9ZnVuY3Rpb24oZSl7dGhpcy5fZHJhZ2dlZHx8ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jcmVhdGVCdWZmZXIoMSwxLGUuc2FtcGxlUmF0ZSksbj1lLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO24uYnVmZmVyPXQsbi5jb25uZWN0KGUuZGVzdGluYXRpb24pLG4uc3RhcnQoMCksZS5yZXN1bWUmJmUucmVzdW1lKCl9KGUpLHRoaXMuX2RyYWdnZWQ9ITF9LHIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fYmluZGVkRW5kKSx0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLl9iaW5kZWRNb3ZlKSx0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMuX2JpbmRlZEVuZCksdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMuX2JpbmRlZEVuZCksdGhpcy5fYmluZGVkTW92ZT1udWxsLHRoaXMuX2JpbmRlZEVuZD1udWxsLHRoaXMuX2VsZW1lbnQ9bnVsbH0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0LG4pe28odCk/bigpOmZ1bmN0aW9uIGUoKXtvKHQpP24oKToocmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUpLHQucmVzdW1lJiZ0LnJlc3VtZSgpKX0oKX0odCxlKX0pLGQ9W107cmV0dXJuIGZ1bmN0aW9uIGUodCxuLGkpe2lmKEFycmF5LmlzQXJyYXkodCl8fE5vZGVMaXN0JiZ0IGluc3RhbmNlb2YgTm9kZUxpc3QpZm9yKHZhciBkPTA7ZDx0Lmxlbmd0aDtkKyspZSh0W2RdLG4saSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgdCllKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCksbixpKTtlbHNlIGlmKHQuanF1ZXJ5JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRvQXJyYXkpZSh0LnRvQXJyYXkoKSxuLGkpO2Vsc2UgaWYoRWxlbWVudCYmdCBpbnN0YW5jZW9mIEVsZW1lbnQpe3ZhciBvPW5ldyByKHQsaSk7bi5wdXNoKG8pfX0oZT1lfHxkb2N1bWVudC5ib2R5LGQsdCksaS50aGVuKGZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspZFtlXS5kaXNwb3NlKCk7ZD1udWxsLG4mJm4oKX0pLGl9fSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIG1vZHVsZVNvdXJjZXMgPSBbX193ZWJwYWNrX3JlcXVpcmVfXygzNylbXCJkZWZhdWx0XCJdLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KVtcImRlZmF1bHRcIl0sIF9fd2VicGFja19yZXF1aXJlX18oMzkpW1wiZGVmYXVsdFwiXV07XG52YXIgYWMgPSBwNXNvdW5kLmF1ZGlvY29udGV4dDtcbnZhciBpbml0aWFsaXplZEF1ZGlvV29ya2xldHMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbG9hZEF1ZGlvV29ya2xldE1vZHVsZXMoKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChtb2R1bGVTb3VyY2VzLm1hcChmdW5jdGlvbiAobW9kdWxlU3JjKSB7XG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbW9kdWxlU3JjXSwge1xuICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgfSk7XG4gICAgdmFyIG9iamVjdFVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgcmV0dXJuIGFjLmF1ZGlvV29ya2xldC5hZGRNb2R1bGUob2JqZWN0VVJMKTtcbiAgfSkpO1xufVxuXG5wNS5wcm90b3R5cGUucmVnaXN0ZXJNZXRob2QoJ2luaXQnLCBmdW5jdGlvbiAoKSB7XG4gIGlmIChpbml0aWFsaXplZEF1ZGlvV29ya2xldHMpIHJldHVybjsgXG5cbiAgaWYgKCF0aGlzLnByZWxvYWQgJiYgIXdpbmRvdy5wcmVsb2FkKSB7XG4gICAgdGhpcy5wcmVsb2FkID0gZnVuY3Rpb24gKCkge307XG4gIH0gXG5cblxuICB0aGlzLl9pbmNyZW1lbnRQcmVsb2FkKCk7XG5cbiAgdmFyIG9uV29ya2xldE1vZHVsZXNMb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGluaXRpYWxpemVkQXVkaW9Xb3JrbGV0cyA9IHRydWU7XG5cbiAgICB0aGlzLl9kZWNyZW1lbnRQcmVsb2FkKCk7XG4gIH0uYmluZCh0aGlzKTtcblxuICBsb2FkQXVkaW9Xb3JrbGV0TW9kdWxlcygpLnRoZW4ob25Xb3JrbGV0TW9kdWxlc0xvYWQpO1xufSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcXFwiZnVuY3Rpb25cXFwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxcblxcbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxcblxcbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFxcXCJbbmF0aXZlIGNvZGVdXFxcIikgIT09IC0xOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbi8vIGltcG9ydCBkZXBlbmRlbmNpZXMgdmlhIHByZXZhbC5yZXF1aXJlIHNvIHRoYXQgdGhleSdyZSBhdmFpbGFibGUgYXMgdmFsdWVzIGF0IGNvbXBpbGUgdGltZVxcbnZhciBwcm9jZXNzb3JOYW1lcyA9IHtcXG4gIFxcXCJyZWNvcmRlclByb2Nlc3NvclxcXCI6IFxcXCJyZWNvcmRlci1wcm9jZXNzb3JcXFwiLFxcbiAgXFxcInNvdW5kRmlsZVByb2Nlc3NvclxcXCI6IFxcXCJzb3VuZC1maWxlLXByb2Nlc3NvclxcXCIsXFxuICBcXFwiYW1wbGl0dWRlUHJvY2Vzc29yXFxcIjogXFxcImFtcGxpdHVkZS1wcm9jZXNzb3JcXFwiXFxufTtcXG52YXIgUmluZ0J1ZmZlciA9IHtcXG4gIFxcXCJkZWZhdWx0XFxcIjpcXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgLyoqXFxuICAgICAqIEBjb25zdHJ1Y3RvclxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGxlbmd0aCBCdWZmZXIgbGVuZ3RoIGluIGZyYW1lcy5cXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBjaGFubmVsQ291bnQgQnVmZmVyIGNoYW5uZWwgY291bnQuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBSaW5nQnVmZmVyKGxlbmd0aCwgY2hhbm5lbENvdW50KSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJpbmdCdWZmZXIpO1xcblxcbiAgICAgIHRoaXMuX3JlYWRJbmRleCA9IDA7XFxuICAgICAgdGhpcy5fd3JpdGVJbmRleCA9IDA7XFxuICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlID0gMDtcXG4gICAgICB0aGlzLl9jaGFubmVsQ291bnQgPSBjaGFubmVsQ291bnQ7XFxuICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xcbiAgICAgIHRoaXMuX2NoYW5uZWxEYXRhID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGFubmVsQ291bnQ7ICsraSkge1xcbiAgICAgICAgdGhpcy5fY2hhbm5lbERhdGFbaV0gPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXR0ZXIgZm9yIEF2YWlsYWJsZSBmcmFtZXMgaW4gYnVmZmVyLlxcbiAgICAgKlxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEF2YWlsYWJsZSBmcmFtZXMgaW4gYnVmZmVyLlxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKFJpbmdCdWZmZXIsIFt7XFxuICAgICAga2V5OiBcXFwicHVzaFxcXCIsXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogUHVzaCBhIHNlcXVlbmNlIG9mIEZsb2F0MzJBcnJheXMgdG8gYnVmZmVyLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtICB7YXJyYXl9IGFycmF5U2VxdWVuY2UgQSBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqL1xcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGFycmF5U2VxdWVuY2UpIHtcXG4gICAgICAgIC8vIFRoZSBjaGFubmVsIGNvdW50IG9mIGFycmF5U2VxdWVuY2UgYW5kIHRoZSBsZW5ndGggb2YgZWFjaCBjaGFubmVsIG11c3RcXG4gICAgICAgIC8vIG1hdGNoIHdpdGggdGhpcyBidWZmZXIgb2JlamN0LlxcbiAgICAgICAgLy8gVHJhbnNmZXIgZGF0YSBmcm9tIHRoZSB8YXJyYXlTZXF1ZW5jZXwgc3RvcmFnZSB0byB0aGUgaW50ZXJuYWwgYnVmZmVyLlxcbiAgICAgICAgdmFyIHNvdXJjZUxlbmd0aCA9IGFycmF5U2VxdWVuY2VbMF0ubGVuZ3RoO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VMZW5ndGg7ICsraSkge1xcbiAgICAgICAgICB2YXIgd3JpdGVJbmRleCA9ICh0aGlzLl93cml0ZUluZGV4ICsgaSkgJSB0aGlzLl9sZW5ndGg7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2NoYW5uZWwpIHtcXG4gICAgICAgICAgICB0aGlzLl9jaGFubmVsRGF0YVtjaGFubmVsXVt3cml0ZUluZGV4XSA9IGFycmF5U2VxdWVuY2VbY2hhbm5lbF1baV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3dyaXRlSW5kZXggKz0gc291cmNlTGVuZ3RoO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX3dyaXRlSW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX3dyaXRlSW5kZXggPSAwO1xcbiAgICAgICAgfSAvLyBGb3IgZXhjZXNzaXZlIGZyYW1lcywgdGhlIGJ1ZmZlciB3aWxsIGJlIG92ZXJ3cml0dGVuLlxcblxcblxcbiAgICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlICs9IHNvdXJjZUxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPiB0aGlzLl9sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlID0gdGhpcy5fbGVuZ3RoO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBQdWxsIGRhdGEgb3V0IG9mIGJ1ZmZlciBhbmQgZmlsbCBhIGdpdmVuIHNlcXVlbmNlIG9mIEZsb2F0MzJBcnJheXMuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0gIHthcnJheX0gYXJyYXlTZXF1ZW5jZSBBbiBhcnJheSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwicHVsbFxcXCIsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1bGwoYXJyYXlTZXF1ZW5jZSkge1xcbiAgICAgICAgLy8gVGhlIGNoYW5uZWwgY291bnQgb2YgYXJyYXlTZXF1ZW5jZSBhbmQgdGhlIGxlbmd0aCBvZiBlYWNoIGNoYW5uZWwgbXVzdFxcbiAgICAgICAgLy8gbWF0Y2ggd2l0aCB0aGlzIGJ1ZmZlciBvYmVqY3QuXFxuICAgICAgICAvLyBJZiB0aGUgRklGTyBpcyBjb21wbGV0ZWx5IGVtcHR5LCBkbyBub3RoaW5nLlxcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9PT0gMCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgZGVzdGluYXRpb25MZW5ndGggPSBhcnJheVNlcXVlbmNlWzBdLmxlbmd0aDsgLy8gVHJhbnNmZXIgZGF0YSBmcm9tIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gdGhlIHxhcnJheVNlcXVlbmNlfCBzdG9yYWdlLlxcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXN0aW5hdGlvbkxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgIHZhciByZWFkSW5kZXggPSAodGhpcy5fcmVhZEluZGV4ICsgaSkgJSB0aGlzLl9sZW5ndGg7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2NoYW5uZWwpIHtcXG4gICAgICAgICAgICBhcnJheVNlcXVlbmNlW2NoYW5uZWxdW2ldID0gdGhpcy5fY2hhbm5lbERhdGFbY2hhbm5lbF1bcmVhZEluZGV4XTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fcmVhZEluZGV4ICs9IGRlc3RpbmF0aW9uTGVuZ3RoO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX3JlYWRJbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5fcmVhZEluZGV4ID0gMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSAtPSBkZXN0aW5hdGlvbkxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPCAwKSB7XFxuICAgICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IDA7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiZnJhbWVzQXZhaWxhYmxlXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZXNBdmFpbGFibGU7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBSaW5nQnVmZmVyO1xcbiAgfSgpXFxufVtcXFwiZGVmYXVsdFxcXCJdO1xcblxcbnZhciBSZWNvcmRlclByb2Nlc3NvciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfQXVkaW9Xb3JrbGV0UHJvY2Vzc28pIHtcXG4gIF9pbmhlcml0cyhSZWNvcmRlclByb2Nlc3NvciwgX0F1ZGlvV29ya2xldFByb2Nlc3NvKTtcXG5cXG4gIGZ1bmN0aW9uIFJlY29yZGVyUHJvY2Vzc29yKG9wdGlvbnMpIHtcXG4gICAgdmFyIF90aGlzO1xcblxcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjb3JkZXJQcm9jZXNzb3IpO1xcblxcbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSZWNvcmRlclByb2Nlc3NvcikuY2FsbCh0aGlzKSk7XFxuICAgIHZhciBwcm9jZXNzb3JPcHRpb25zID0gb3B0aW9ucy5wcm9jZXNzb3JPcHRpb25zIHx8IHt9O1xcbiAgICBfdGhpcy5udW1PdXRwdXRDaGFubmVscyA9IG9wdGlvbnMub3V0cHV0Q2hhbm5lbENvdW50IHx8IDI7XFxuICAgIF90aGlzLm51bUlucHV0Q2hhbm5lbHMgPSBwcm9jZXNzb3JPcHRpb25zLm51bUlucHV0Q2hhbm5lbHMgfHwgMjtcXG4gICAgX3RoaXMuYnVmZmVyU2l6ZSA9IHByb2Nlc3Nvck9wdGlvbnMuYnVmZmVyU2l6ZSB8fCAxMDI0O1xcbiAgICBfdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcXG5cXG4gICAgX3RoaXMuY2xlYXIoKTtcXG5cXG4gICAgX3RoaXMucG9ydC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XFxuXFxuICAgICAgaWYgKGRhdGEubmFtZSA9PT0gJ3N0YXJ0Jykge1xcbiAgICAgICAgX3RoaXMucmVjb3JkKGRhdGEuZHVyYXRpb24pO1xcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5uYW1lID09PSAnc3RvcCcpIHtcXG4gICAgICAgIF90aGlzLnN0b3AoKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHJldHVybiBfdGhpcztcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhSZWNvcmRlclByb2Nlc3NvciwgW3tcXG4gICAga2V5OiBcXFwicHJvY2Vzc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKGlucHV0cykge1xcbiAgICAgIGlmICghdGhpcy5yZWNvcmRpbmcpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zYW1wbGVMaW1pdCAmJiB0aGlzLnJlY29yZGVkU2FtcGxlcyA+PSB0aGlzLnNhbXBsZUxpbWl0KSB7XFxuICAgICAgICB0aGlzLnN0b3AoKTtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaW5wdXQgPSBpbnB1dHNbMF07XFxuICAgICAgdGhpcy5pbnB1dFJpbmdCdWZmZXIucHVzaChpbnB1dCk7XFxuXFxuICAgICAgaWYgKHRoaXMuaW5wdXRSaW5nQnVmZmVyLmZyYW1lc0F2YWlsYWJsZSA+PSB0aGlzLmJ1ZmZlclNpemUpIHtcXG4gICAgICAgIHRoaXMuaW5wdXRSaW5nQnVmZmVyLnB1bGwodGhpcy5pbnB1dFJpbmdCdWZmZXJBcnJheVNlcXVlbmNlKTtcXG5cXG4gICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5udW1PdXRwdXRDaGFubmVsczsgKytjaGFubmVsKSB7XFxuICAgICAgICAgIHZhciBpbnB1dENoYW5uZWxDb3B5ID0gdGhpcy5pbnB1dFJpbmdCdWZmZXJBcnJheVNlcXVlbmNlW2NoYW5uZWxdLnNsaWNlKCk7XFxuXFxuICAgICAgICAgIGlmIChjaGFubmVsID09PSAwKSB7XFxuICAgICAgICAgICAgdGhpcy5sZWZ0QnVmZmVycy5wdXNoKGlucHV0Q2hhbm5lbENvcHkpO1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLm51bUlucHV0Q2hhbm5lbHMgPT09IDEpIHtcXG4gICAgICAgICAgICAgIHRoaXMucmlnaHRCdWZmZXJzLnB1c2goaW5wdXRDaGFubmVsQ29weSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWwgPT09IDEgJiYgdGhpcy5udW1JbnB1dENoYW5uZWxzID4gMSkge1xcbiAgICAgICAgICAgIHRoaXMucmlnaHRCdWZmZXJzLnB1c2goaW5wdXRDaGFubmVsQ29weSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMucmVjb3JkZWRTYW1wbGVzICs9IHRoaXMuYnVmZmVyU2l6ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVjb3JkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29yZChkdXJhdGlvbikge1xcbiAgICAgIGlmIChkdXJhdGlvbikge1xcbiAgICAgICAgdGhpcy5zYW1wbGVMaW1pdCA9IE1hdGgucm91bmQoZHVyYXRpb24gKiBzYW1wbGVSYXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5yZWNvcmRpbmcgPSB0cnVlO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInN0b3BcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcXG4gICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xcbiAgICAgIHZhciBidWZmZXJzID0gdGhpcy5nZXRCdWZmZXJzKCk7XFxuICAgICAgdmFyIGxlZnRCdWZmZXIgPSBidWZmZXJzWzBdLmJ1ZmZlcjtcXG4gICAgICB2YXIgcmlnaHRCdWZmZXIgPSBidWZmZXJzWzFdLmJ1ZmZlcjtcXG4gICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe1xcbiAgICAgICAgbmFtZTogJ2J1ZmZlcnMnLFxcbiAgICAgICAgbGVmdEJ1ZmZlcjogbGVmdEJ1ZmZlcixcXG4gICAgICAgIHJpZ2h0QnVmZmVyOiByaWdodEJ1ZmZlclxcbiAgICAgIH0sIFtsZWZ0QnVmZmVyLCByaWdodEJ1ZmZlcl0pO1xcbiAgICAgIHRoaXMuY2xlYXIoKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRCdWZmZXJzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJ1ZmZlcnMoKSB7XFxuICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcXG4gICAgICBidWZmZXJzLnB1c2godGhpcy5tZXJnZUJ1ZmZlcnModGhpcy5sZWZ0QnVmZmVycykpO1xcbiAgICAgIGJ1ZmZlcnMucHVzaCh0aGlzLm1lcmdlQnVmZmVycyh0aGlzLnJpZ2h0QnVmZmVycykpO1xcbiAgICAgIHJldHVybiBidWZmZXJzO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIm1lcmdlQnVmZmVyc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZUJ1ZmZlcnMoY2hhbm5lbEJ1ZmZlcikge1xcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucmVjb3JkZWRTYW1wbGVzKTtcXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcXG4gICAgICB2YXIgbG5nID0gY2hhbm5lbEJ1ZmZlci5sZW5ndGg7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsbmc7IGkrKykge1xcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGNoYW5uZWxCdWZmZXJbaV07XFxuICAgICAgICByZXN1bHQuc2V0KGJ1ZmZlciwgb2Zmc2V0KTtcXG4gICAgICAgIG9mZnNldCArPSBidWZmZXIubGVuZ3RoO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImNsZWFyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMubGVmdEJ1ZmZlcnMgPSBbXTtcXG4gICAgICB0aGlzLnJpZ2h0QnVmZmVycyA9IFtdO1xcbiAgICAgIHRoaXMuaW5wdXRSaW5nQnVmZmVyID0gbmV3IFJpbmdCdWZmZXIodGhpcy5idWZmZXJTaXplLCB0aGlzLm51bUlucHV0Q2hhbm5lbHMpO1xcbiAgICAgIHRoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZSA9IG5ldyBBcnJheSh0aGlzLm51bUlucHV0Q2hhbm5lbHMpLmZpbGwobnVsbCkubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KF90aGlzMi5idWZmZXJTaXplKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLnJlY29yZGVkU2FtcGxlcyA9IDA7XFxuICAgICAgdGhpcy5zYW1wbGVMaW1pdCA9IG51bGw7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBSZWNvcmRlclByb2Nlc3NvcjtcXG59KF93cmFwTmF0aXZlU3VwZXIoQXVkaW9Xb3JrbGV0UHJvY2Vzc29yKSk7XFxuXFxucmVnaXN0ZXJQcm9jZXNzb3IocHJvY2Vzc29yTmFtZXMucmVjb3JkZXJQcm9jZXNzb3IsIFJlY29yZGVyUHJvY2Vzc29yKTtcIik7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcXFwiZnVuY3Rpb25cXFwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxcblxcbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxcblxcbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFxcXCJbbmF0aXZlIGNvZGVdXFxcIikgIT09IC0xOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbi8vIGltcG9ydCBkZXBlbmRlbmNpZXMgdmlhIHByZXZhbC5yZXF1aXJlIHNvIHRoYXQgdGhleSdyZSBhdmFpbGFibGUgYXMgdmFsdWVzIGF0IGNvbXBpbGUgdGltZVxcbnZhciBwcm9jZXNzb3JOYW1lcyA9IHtcXG4gIFxcXCJyZWNvcmRlclByb2Nlc3NvclxcXCI6IFxcXCJyZWNvcmRlci1wcm9jZXNzb3JcXFwiLFxcbiAgXFxcInNvdW5kRmlsZVByb2Nlc3NvclxcXCI6IFxcXCJzb3VuZC1maWxlLXByb2Nlc3NvclxcXCIsXFxuICBcXFwiYW1wbGl0dWRlUHJvY2Vzc29yXFxcIjogXFxcImFtcGxpdHVkZS1wcm9jZXNzb3JcXFwiXFxufTtcXG52YXIgUmluZ0J1ZmZlciA9IHtcXG4gIFxcXCJkZWZhdWx0XFxcIjpcXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgLyoqXFxuICAgICAqIEBjb25zdHJ1Y3RvclxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGxlbmd0aCBCdWZmZXIgbGVuZ3RoIGluIGZyYW1lcy5cXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBjaGFubmVsQ291bnQgQnVmZmVyIGNoYW5uZWwgY291bnQuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBSaW5nQnVmZmVyKGxlbmd0aCwgY2hhbm5lbENvdW50KSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJpbmdCdWZmZXIpO1xcblxcbiAgICAgIHRoaXMuX3JlYWRJbmRleCA9IDA7XFxuICAgICAgdGhpcy5fd3JpdGVJbmRleCA9IDA7XFxuICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlID0gMDtcXG4gICAgICB0aGlzLl9jaGFubmVsQ291bnQgPSBjaGFubmVsQ291bnQ7XFxuICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xcbiAgICAgIHRoaXMuX2NoYW5uZWxEYXRhID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGFubmVsQ291bnQ7ICsraSkge1xcbiAgICAgICAgdGhpcy5fY2hhbm5lbERhdGFbaV0gPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXR0ZXIgZm9yIEF2YWlsYWJsZSBmcmFtZXMgaW4gYnVmZmVyLlxcbiAgICAgKlxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEF2YWlsYWJsZSBmcmFtZXMgaW4gYnVmZmVyLlxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKFJpbmdCdWZmZXIsIFt7XFxuICAgICAga2V5OiBcXFwicHVzaFxcXCIsXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogUHVzaCBhIHNlcXVlbmNlIG9mIEZsb2F0MzJBcnJheXMgdG8gYnVmZmVyLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtICB7YXJyYXl9IGFycmF5U2VxdWVuY2UgQSBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqL1xcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGFycmF5U2VxdWVuY2UpIHtcXG4gICAgICAgIC8vIFRoZSBjaGFubmVsIGNvdW50IG9mIGFycmF5U2VxdWVuY2UgYW5kIHRoZSBsZW5ndGggb2YgZWFjaCBjaGFubmVsIG11c3RcXG4gICAgICAgIC8vIG1hdGNoIHdpdGggdGhpcyBidWZmZXIgb2JlamN0LlxcbiAgICAgICAgLy8gVHJhbnNmZXIgZGF0YSBmcm9tIHRoZSB8YXJyYXlTZXF1ZW5jZXwgc3RvcmFnZSB0byB0aGUgaW50ZXJuYWwgYnVmZmVyLlxcbiAgICAgICAgdmFyIHNvdXJjZUxlbmd0aCA9IGFycmF5U2VxdWVuY2VbMF0ubGVuZ3RoO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VMZW5ndGg7ICsraSkge1xcbiAgICAgICAgICB2YXIgd3JpdGVJbmRleCA9ICh0aGlzLl93cml0ZUluZGV4ICsgaSkgJSB0aGlzLl9sZW5ndGg7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2NoYW5uZWwpIHtcXG4gICAgICAgICAgICB0aGlzLl9jaGFubmVsRGF0YVtjaGFubmVsXVt3cml0ZUluZGV4XSA9IGFycmF5U2VxdWVuY2VbY2hhbm5lbF1baV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3dyaXRlSW5kZXggKz0gc291cmNlTGVuZ3RoO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX3dyaXRlSW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX3dyaXRlSW5kZXggPSAwO1xcbiAgICAgICAgfSAvLyBGb3IgZXhjZXNzaXZlIGZyYW1lcywgdGhlIGJ1ZmZlciB3aWxsIGJlIG92ZXJ3cml0dGVuLlxcblxcblxcbiAgICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlICs9IHNvdXJjZUxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPiB0aGlzLl9sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlID0gdGhpcy5fbGVuZ3RoO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBQdWxsIGRhdGEgb3V0IG9mIGJ1ZmZlciBhbmQgZmlsbCBhIGdpdmVuIHNlcXVlbmNlIG9mIEZsb2F0MzJBcnJheXMuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0gIHthcnJheX0gYXJyYXlTZXF1ZW5jZSBBbiBhcnJheSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwicHVsbFxcXCIsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1bGwoYXJyYXlTZXF1ZW5jZSkge1xcbiAgICAgICAgLy8gVGhlIGNoYW5uZWwgY291bnQgb2YgYXJyYXlTZXF1ZW5jZSBhbmQgdGhlIGxlbmd0aCBvZiBlYWNoIGNoYW5uZWwgbXVzdFxcbiAgICAgICAgLy8gbWF0Y2ggd2l0aCB0aGlzIGJ1ZmZlciBvYmVqY3QuXFxuICAgICAgICAvLyBJZiB0aGUgRklGTyBpcyBjb21wbGV0ZWx5IGVtcHR5LCBkbyBub3RoaW5nLlxcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9PT0gMCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgZGVzdGluYXRpb25MZW5ndGggPSBhcnJheVNlcXVlbmNlWzBdLmxlbmd0aDsgLy8gVHJhbnNmZXIgZGF0YSBmcm9tIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gdGhlIHxhcnJheVNlcXVlbmNlfCBzdG9yYWdlLlxcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXN0aW5hdGlvbkxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgIHZhciByZWFkSW5kZXggPSAodGhpcy5fcmVhZEluZGV4ICsgaSkgJSB0aGlzLl9sZW5ndGg7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2NoYW5uZWwpIHtcXG4gICAgICAgICAgICBhcnJheVNlcXVlbmNlW2NoYW5uZWxdW2ldID0gdGhpcy5fY2hhbm5lbERhdGFbY2hhbm5lbF1bcmVhZEluZGV4XTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fcmVhZEluZGV4ICs9IGRlc3RpbmF0aW9uTGVuZ3RoO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX3JlYWRJbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5fcmVhZEluZGV4ID0gMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSAtPSBkZXN0aW5hdGlvbkxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPCAwKSB7XFxuICAgICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IDA7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiZnJhbWVzQXZhaWxhYmxlXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZXNBdmFpbGFibGU7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBSaW5nQnVmZmVyO1xcbiAgfSgpXFxufVtcXFwiZGVmYXVsdFxcXCJdO1xcblxcbnZhciBTb3VuZEZpbGVQcm9jZXNzb3IgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX0F1ZGlvV29ya2xldFByb2Nlc3NvKSB7XFxuICBfaW5oZXJpdHMoU291bmRGaWxlUHJvY2Vzc29yLCBfQXVkaW9Xb3JrbGV0UHJvY2Vzc28pO1xcblxcbiAgZnVuY3Rpb24gU291bmRGaWxlUHJvY2Vzc29yKG9wdGlvbnMpIHtcXG4gICAgdmFyIF90aGlzO1xcblxcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU291bmRGaWxlUHJvY2Vzc29yKTtcXG5cXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoU291bmRGaWxlUHJvY2Vzc29yKS5jYWxsKHRoaXMpKTtcXG4gICAgdmFyIHByb2Nlc3Nvck9wdGlvbnMgPSBvcHRpb25zLnByb2Nlc3Nvck9wdGlvbnMgfHwge307XFxuICAgIF90aGlzLmJ1ZmZlclNpemUgPSBwcm9jZXNzb3JPcHRpb25zLmJ1ZmZlclNpemUgfHwgMjU2O1xcbiAgICBfdGhpcy5pbnB1dFJpbmdCdWZmZXIgPSBuZXcgUmluZ0J1ZmZlcihfdGhpcy5idWZmZXJTaXplLCAxKTtcXG4gICAgX3RoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZSA9IFtuZXcgRmxvYXQzMkFycmF5KF90aGlzLmJ1ZmZlclNpemUpXTtcXG4gICAgcmV0dXJuIF90aGlzO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFNvdW5kRmlsZVByb2Nlc3NvciwgW3tcXG4gICAga2V5OiBcXFwicHJvY2Vzc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKGlucHV0cykge1xcbiAgICAgIHZhciBpbnB1dCA9IGlucHV0c1swXTsgLy8gd2Ugb25seSBjYXJlIGFib3V0IHRoZSBmaXJzdCBpbnB1dCBjaGFubmVsLCBiZWNhdXNlIHRoYXQgY29udGFpbnMgdGhlIHBvc2l0aW9uIGRhdGFcXG5cXG4gICAgICB0aGlzLmlucHV0UmluZ0J1ZmZlci5wdXNoKFtpbnB1dFswXV0pO1xcblxcbiAgICAgIGlmICh0aGlzLmlucHV0UmluZ0J1ZmZlci5mcmFtZXNBdmFpbGFibGUgPj0gdGhpcy5idWZmZXJTaXplKSB7XFxuICAgICAgICB0aGlzLmlucHV0UmluZ0J1ZmZlci5wdWxsKHRoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZSk7XFxuICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gdGhpcy5pbnB1dFJpbmdCdWZmZXJBcnJheVNlcXVlbmNlWzBdO1xcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gaW5wdXRDaGFubmVsW2lucHV0Q2hhbm5lbC5sZW5ndGggLSAxXSB8fCAwO1xcbiAgICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHtcXG4gICAgICAgICAgbmFtZTogJ3Bvc2l0aW9uJyxcXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTb3VuZEZpbGVQcm9jZXNzb3I7XFxufShfd3JhcE5hdGl2ZVN1cGVyKEF1ZGlvV29ya2xldFByb2Nlc3NvcikpO1xcblxcbnJlZ2lzdGVyUHJvY2Vzc29yKHByb2Nlc3Nvck5hbWVzLnNvdW5kRmlsZVByb2Nlc3NvciwgU291bmRGaWxlUHJvY2Vzc29yKTtcIik7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcXFwiZnVuY3Rpb25cXFwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxcblxcbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxcblxcbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFxcXCJbbmF0aXZlIGNvZGVdXFxcIikgIT09IC0xOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbi8vIGltcG9ydCBkZXBlbmRlbmNpZXMgdmlhIHByZXZhbC5yZXF1aXJlIHNvIHRoYXQgdGhleSdyZSBhdmFpbGFibGUgYXMgdmFsdWVzIGF0IGNvbXBpbGUgdGltZVxcbnZhciBwcm9jZXNzb3JOYW1lcyA9IHtcXG4gIFxcXCJyZWNvcmRlclByb2Nlc3NvclxcXCI6IFxcXCJyZWNvcmRlci1wcm9jZXNzb3JcXFwiLFxcbiAgXFxcInNvdW5kRmlsZVByb2Nlc3NvclxcXCI6IFxcXCJzb3VuZC1maWxlLXByb2Nlc3NvclxcXCIsXFxuICBcXFwiYW1wbGl0dWRlUHJvY2Vzc29yXFxcIjogXFxcImFtcGxpdHVkZS1wcm9jZXNzb3JcXFwiXFxufTtcXG52YXIgUmluZ0J1ZmZlciA9IHtcXG4gIFxcXCJkZWZhdWx0XFxcIjpcXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgLyoqXFxuICAgICAqIEBjb25zdHJ1Y3RvclxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGxlbmd0aCBCdWZmZXIgbGVuZ3RoIGluIGZyYW1lcy5cXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBjaGFubmVsQ291bnQgQnVmZmVyIGNoYW5uZWwgY291bnQuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBSaW5nQnVmZmVyKGxlbmd0aCwgY2hhbm5lbENvdW50KSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJpbmdCdWZmZXIpO1xcblxcbiAgICAgIHRoaXMuX3JlYWRJbmRleCA9IDA7XFxuICAgICAgdGhpcy5fd3JpdGVJbmRleCA9IDA7XFxuICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlID0gMDtcXG4gICAgICB0aGlzLl9jaGFubmVsQ291bnQgPSBjaGFubmVsQ291bnQ7XFxuICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xcbiAgICAgIHRoaXMuX2NoYW5uZWxEYXRhID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGFubmVsQ291bnQ7ICsraSkge1xcbiAgICAgICAgdGhpcy5fY2hhbm5lbERhdGFbaV0gPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXR0ZXIgZm9yIEF2YWlsYWJsZSBmcmFtZXMgaW4gYnVmZmVyLlxcbiAgICAgKlxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEF2YWlsYWJsZSBmcmFtZXMgaW4gYnVmZmVyLlxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKFJpbmdCdWZmZXIsIFt7XFxuICAgICAga2V5OiBcXFwicHVzaFxcXCIsXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogUHVzaCBhIHNlcXVlbmNlIG9mIEZsb2F0MzJBcnJheXMgdG8gYnVmZmVyLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtICB7YXJyYXl9IGFycmF5U2VxdWVuY2UgQSBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqL1xcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGFycmF5U2VxdWVuY2UpIHtcXG4gICAgICAgIC8vIFRoZSBjaGFubmVsIGNvdW50IG9mIGFycmF5U2VxdWVuY2UgYW5kIHRoZSBsZW5ndGggb2YgZWFjaCBjaGFubmVsIG11c3RcXG4gICAgICAgIC8vIG1hdGNoIHdpdGggdGhpcyBidWZmZXIgb2JlamN0LlxcbiAgICAgICAgLy8gVHJhbnNmZXIgZGF0YSBmcm9tIHRoZSB8YXJyYXlTZXF1ZW5jZXwgc3RvcmFnZSB0byB0aGUgaW50ZXJuYWwgYnVmZmVyLlxcbiAgICAgICAgdmFyIHNvdXJjZUxlbmd0aCA9IGFycmF5U2VxdWVuY2VbMF0ubGVuZ3RoO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VMZW5ndGg7ICsraSkge1xcbiAgICAgICAgICB2YXIgd3JpdGVJbmRleCA9ICh0aGlzLl93cml0ZUluZGV4ICsgaSkgJSB0aGlzLl9sZW5ndGg7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2NoYW5uZWwpIHtcXG4gICAgICAgICAgICB0aGlzLl9jaGFubmVsRGF0YVtjaGFubmVsXVt3cml0ZUluZGV4XSA9IGFycmF5U2VxdWVuY2VbY2hhbm5lbF1baV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3dyaXRlSW5kZXggKz0gc291cmNlTGVuZ3RoO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX3dyaXRlSW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX3dyaXRlSW5kZXggPSAwO1xcbiAgICAgICAgfSAvLyBGb3IgZXhjZXNzaXZlIGZyYW1lcywgdGhlIGJ1ZmZlciB3aWxsIGJlIG92ZXJ3cml0dGVuLlxcblxcblxcbiAgICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlICs9IHNvdXJjZUxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPiB0aGlzLl9sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5fZnJhbWVzQXZhaWxhYmxlID0gdGhpcy5fbGVuZ3RoO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBQdWxsIGRhdGEgb3V0IG9mIGJ1ZmZlciBhbmQgZmlsbCBhIGdpdmVuIHNlcXVlbmNlIG9mIEZsb2F0MzJBcnJheXMuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0gIHthcnJheX0gYXJyYXlTZXF1ZW5jZSBBbiBhcnJheSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwicHVsbFxcXCIsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1bGwoYXJyYXlTZXF1ZW5jZSkge1xcbiAgICAgICAgLy8gVGhlIGNoYW5uZWwgY291bnQgb2YgYXJyYXlTZXF1ZW5jZSBhbmQgdGhlIGxlbmd0aCBvZiBlYWNoIGNoYW5uZWwgbXVzdFxcbiAgICAgICAgLy8gbWF0Y2ggd2l0aCB0aGlzIGJ1ZmZlciBvYmVqY3QuXFxuICAgICAgICAvLyBJZiB0aGUgRklGTyBpcyBjb21wbGV0ZWx5IGVtcHR5LCBkbyBub3RoaW5nLlxcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9PT0gMCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgZGVzdGluYXRpb25MZW5ndGggPSBhcnJheVNlcXVlbmNlWzBdLmxlbmd0aDsgLy8gVHJhbnNmZXIgZGF0YSBmcm9tIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gdGhlIHxhcnJheVNlcXVlbmNlfCBzdG9yYWdlLlxcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXN0aW5hdGlvbkxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgIHZhciByZWFkSW5kZXggPSAodGhpcy5fcmVhZEluZGV4ICsgaSkgJSB0aGlzLl9sZW5ndGg7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2NoYW5uZWwpIHtcXG4gICAgICAgICAgICBhcnJheVNlcXVlbmNlW2NoYW5uZWxdW2ldID0gdGhpcy5fY2hhbm5lbERhdGFbY2hhbm5lbF1bcmVhZEluZGV4XTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fcmVhZEluZGV4ICs9IGRlc3RpbmF0aW9uTGVuZ3RoO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX3JlYWRJbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5fcmVhZEluZGV4ID0gMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSAtPSBkZXN0aW5hdGlvbkxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPCAwKSB7XFxuICAgICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IDA7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiZnJhbWVzQXZhaWxhYmxlXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZXNBdmFpbGFibGU7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBSaW5nQnVmZmVyO1xcbiAgfSgpXFxufVtcXFwiZGVmYXVsdFxcXCJdO1xcblxcbnZhciBBbXBsaXR1ZGVQcm9jZXNzb3IgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX0F1ZGlvV29ya2xldFByb2Nlc3NvKSB7XFxuICBfaW5oZXJpdHMoQW1wbGl0dWRlUHJvY2Vzc29yLCBfQXVkaW9Xb3JrbGV0UHJvY2Vzc28pO1xcblxcbiAgZnVuY3Rpb24gQW1wbGl0dWRlUHJvY2Vzc29yKG9wdGlvbnMpIHtcXG4gICAgdmFyIF90aGlzO1xcblxcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW1wbGl0dWRlUHJvY2Vzc29yKTtcXG5cXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQW1wbGl0dWRlUHJvY2Vzc29yKS5jYWxsKHRoaXMpKTtcXG4gICAgdmFyIHByb2Nlc3Nvck9wdGlvbnMgPSBvcHRpb25zLnByb2Nlc3Nvck9wdGlvbnMgfHwge307XFxuICAgIF90aGlzLm51bU91dHB1dENoYW5uZWxzID0gb3B0aW9ucy5vdXRwdXRDaGFubmVsQ291bnQgfHwgMTtcXG4gICAgX3RoaXMubnVtSW5wdXRDaGFubmVscyA9IHByb2Nlc3Nvck9wdGlvbnMubnVtSW5wdXRDaGFubmVscyB8fCAyO1xcbiAgICBfdGhpcy5ub3JtYWxpemUgPSBwcm9jZXNzb3JPcHRpb25zLm5vcm1hbGl6ZSB8fCBmYWxzZTtcXG4gICAgX3RoaXMuc21vb3RoaW5nID0gcHJvY2Vzc29yT3B0aW9ucy5zbW9vdGhpbmcgfHwgMDtcXG4gICAgX3RoaXMuYnVmZmVyU2l6ZSA9IHByb2Nlc3Nvck9wdGlvbnMuYnVmZmVyU2l6ZSB8fCAyMDQ4O1xcbiAgICBfdGhpcy5pbnB1dFJpbmdCdWZmZXIgPSBuZXcgUmluZ0J1ZmZlcihfdGhpcy5idWZmZXJTaXplLCBfdGhpcy5udW1JbnB1dENoYW5uZWxzKTtcXG4gICAgX3RoaXMub3V0cHV0UmluZ0J1ZmZlciA9IG5ldyBSaW5nQnVmZmVyKF90aGlzLmJ1ZmZlclNpemUsIF90aGlzLm51bU91dHB1dENoYW5uZWxzKTtcXG4gICAgX3RoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZSA9IG5ldyBBcnJheShfdGhpcy5udW1JbnB1dENoYW5uZWxzKS5maWxsKG51bGwpLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMuYnVmZmVyU2l6ZSk7XFxuICAgIH0pO1xcbiAgICBfdGhpcy5zdGVyZW9Wb2wgPSBbMCwgMF07XFxuICAgIF90aGlzLnN0ZXJlb1ZvbE5vcm0gPSBbMCwgMF07XFxuICAgIF90aGlzLnZvbE1heCA9IDAuMDAxO1xcblxcbiAgICBfdGhpcy5wb3J0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcXG5cXG4gICAgICBpZiAoZGF0YS5uYW1lID09PSAndG9nZ2xlTm9ybWFsaXplJykge1xcbiAgICAgICAgX3RoaXMubm9ybWFsaXplID0gZGF0YS5ub3JtYWxpemU7XFxuICAgICAgfSBlbHNlIGlmIChkYXRhLm5hbWUgPT09ICdzbW9vdGhpbmcnKSB7XFxuICAgICAgICBfdGhpcy5zbW9vdGhpbmcgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBkYXRhLnNtb290aGluZykpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIF90aGlzO1xcbiAgfSAvLyBUTyBETyBtYWtlIHRoaXMgc3RlcmVvIC8gZGVwZW5kZW50IG9uICMgb2YgYXVkaW8gY2hhbm5lbHNcXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhBbXBsaXR1ZGVQcm9jZXNzb3IsIFt7XFxuICAgIGtleTogXFxcInByb2Nlc3NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcyhpbnB1dHMsIG91dHB1dHMpIHtcXG4gICAgICB2YXIgaW5wdXQgPSBpbnB1dHNbMF07XFxuICAgICAgdmFyIG91dHB1dCA9IG91dHB1dHNbMF07XFxuICAgICAgdmFyIHNtb290aGluZyA9IHRoaXMuc21vb3RoaW5nO1xcbiAgICAgIHRoaXMuaW5wdXRSaW5nQnVmZmVyLnB1c2goaW5wdXQpO1xcblxcbiAgICAgIGlmICh0aGlzLmlucHV0UmluZ0J1ZmZlci5mcmFtZXNBdmFpbGFibGUgPj0gdGhpcy5idWZmZXJTaXplKSB7XFxuICAgICAgICB0aGlzLmlucHV0UmluZ0J1ZmZlci5wdWxsKHRoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZSk7XFxuXFxuICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMubnVtSW5wdXRDaGFubmVsczsgKytjaGFubmVsKSB7XFxuICAgICAgICAgIHZhciBpbnB1dEJ1ZmZlciA9IHRoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZVtjaGFubmVsXTtcXG4gICAgICAgICAgdmFyIGJ1Zkxlbmd0aCA9IGlucHV0QnVmZmVyLmxlbmd0aDtcXG4gICAgICAgICAgdmFyIHN1bSA9IDA7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmTGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICB2YXIgeCA9IGlucHV0QnVmZmVyW2ldO1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZSkge1xcbiAgICAgICAgICAgICAgc3VtICs9IE1hdGgubWF4KE1hdGgubWluKHggLyB0aGlzLnZvbE1heCwgMSksIC0xKSAqIE1hdGgubWF4KE1hdGgubWluKHggLyB0aGlzLnZvbE1heCwgMSksIC0xKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgc3VtICs9IHggKiB4O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyAuLi4gdGhlbiB0YWtlIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3VtLlxcblxcblxcbiAgICAgICAgICB2YXIgcm1zID0gTWF0aC5zcXJ0KHN1bSAvIGJ1Zkxlbmd0aCk7XFxuICAgICAgICAgIHRoaXMuc3RlcmVvVm9sW2NoYW5uZWxdID0gTWF0aC5tYXgocm1zLCB0aGlzLnN0ZXJlb1ZvbFtjaGFubmVsXSAqIHNtb290aGluZyk7XFxuICAgICAgICAgIHRoaXMudm9sTWF4ID0gTWF0aC5tYXgodGhpcy5zdGVyZW9Wb2xbY2hhbm5lbF0sIHRoaXMudm9sTWF4KTtcXG4gICAgICAgIH0gLy8gY2FsY3VsYXRlIHN0ZXJvIG5vcm1hbGl6ZWQgdm9sdW1lIGFuZCBhZGQgdm9sdW1lIGZyb20gYWxsIGNoYW5uZWxzIHRvZ2V0aGVyXFxuXFxuXFxuICAgICAgICB2YXIgdm9sU3VtID0gMDtcXG5cXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnN0ZXJlb1ZvbC5sZW5ndGg7IGluZGV4KyspIHtcXG4gICAgICAgICAgdGhpcy5zdGVyZW9Wb2xOb3JtW2luZGV4XSA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuc3RlcmVvVm9sW2luZGV4XSAvIHRoaXMudm9sTWF4LCAxKSwgMCk7XFxuICAgICAgICAgIHZvbFN1bSArPSB0aGlzLnN0ZXJlb1ZvbFtpbmRleF07XFxuICAgICAgICB9IC8vIHZvbHVtZSBpcyBhdmVyYWdlIG9mIGNoYW5uZWxzXFxuXFxuXFxuICAgICAgICB2YXIgdm9sdW1lID0gdm9sU3VtIC8gdGhpcy5zdGVyZW9Wb2wubGVuZ3RoOyAvLyBub3JtYWxpemVkIHZhbHVlXFxuXFxuICAgICAgICB2YXIgdm9sTm9ybSA9IE1hdGgubWF4KE1hdGgubWluKHZvbHVtZSAvIHRoaXMudm9sTWF4LCAxKSwgMCk7XFxuICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe1xcbiAgICAgICAgICBuYW1lOiAnYW1wbGl0dWRlJyxcXG4gICAgICAgICAgdm9sdW1lOiB2b2x1bWUsXFxuICAgICAgICAgIHZvbE5vcm06IHZvbE5vcm0sXFxuICAgICAgICAgIHN0ZXJlb1ZvbDogdGhpcy5zdGVyZW9Wb2wsXFxuICAgICAgICAgIHN0ZXJlb1ZvbE5vcm06IHRoaXMuc3RlcmVvVm9sTm9ybVxcbiAgICAgICAgfSk7IC8vIHBhc3MgaW5wdXQgdGhyb3VnaCB0byBvdXRwdXRcXG5cXG4gICAgICAgIHRoaXMub3V0cHV0UmluZ0J1ZmZlci5wdXNoKHRoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZSk7XFxuICAgICAgfSAvLyBwdWxsIDEyOCBmcmFtZXMgb3V0IG9mIHRoZSByaW5nIGJ1ZmZlclxcbiAgICAgIC8vIGlmIHRoZSByaW5nIGJ1ZmZlciBkb2VzIG5vdCBoYXZlIGVub3VnaCBmcmFtZXMsIHRoZSBvdXRwdXQgd2lsbCBiZSBzaWxlbnRcXG5cXG5cXG4gICAgICB0aGlzLm91dHB1dFJpbmdCdWZmZXIucHVsbChvdXRwdXQpO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gQW1wbGl0dWRlUHJvY2Vzc29yO1xcbn0oX3dyYXBOYXRpdmVTdXBlcihBdWRpb1dvcmtsZXRQcm9jZXNzb3IpKTtcXG5cXG5yZWdpc3RlclByb2Nlc3Nvcihwcm9jZXNzb3JOYW1lcy5hbXBsaXR1ZGVQcm9jZXNzb3IsIEFtcGxpdHVkZVByb2Nlc3Nvcik7XCIpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIGFjID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7IFxuXG4gIGlmICh0eXBlb2YgYWMuY3JlYXRlU3RlcmVvUGFubmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHA1LlBhbm5lciA9IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0KSB7XG4gICAgICB0aGlzLnN0ZXJlb1Bhbm5lciA9IHRoaXMuaW5wdXQgPSBhYy5jcmVhdGVTdGVyZW9QYW5uZXIoKTtcbiAgICAgIGlucHV0LmNvbm5lY3QodGhpcy5zdGVyZW9QYW5uZXIpO1xuICAgICAgdGhpcy5zdGVyZW9QYW5uZXIuY29ubmVjdChvdXRwdXQpO1xuICAgIH07XG5cbiAgICBwNS5QYW5uZXIucHJvdG90eXBlLnBhbiA9IGZ1bmN0aW9uICh2YWwsIHRGcm9tTm93KSB7XG4gICAgICB2YXIgdGltZSA9IHRGcm9tTm93IHx8IDA7XG4gICAgICB2YXIgdCA9IGFjLmN1cnJlbnRUaW1lICsgdGltZTtcbiAgICAgIHRoaXMuc3RlcmVvUGFubmVyLnBhbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWwsIHQpO1xuICAgIH07IFxuXG5cbiAgICBwNS5QYW5uZXIucHJvdG90eXBlLmlucHV0Q2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHA1LlBhbm5lci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHRoaXMuc3RlcmVvUGFubmVyLmNvbm5lY3Qob2JqKTtcbiAgICB9O1xuXG4gICAgcDUuUGFubmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuc3RlcmVvUGFubmVyKSB7XG4gICAgICAgIHRoaXMuc3RlcmVvUGFubmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHA1LlBhbm5lciA9IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0LCBudW1JbnB1dENoYW5uZWxzKSB7XG4gICAgICB0aGlzLmlucHV0ID0gYWMuY3JlYXRlR2FpbigpO1xuICAgICAgaW5wdXQuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgICAgIHRoaXMubGVmdCA9IGFjLmNyZWF0ZUdhaW4oKTtcbiAgICAgIHRoaXMucmlnaHQgPSBhYy5jcmVhdGVHYWluKCk7XG4gICAgICB0aGlzLmxlZnQuY2hhbm5lbEludGVycHJldGF0aW9uID0gJ2Rpc2NyZXRlJztcbiAgICAgIHRoaXMucmlnaHQuY2hhbm5lbEludGVycHJldGF0aW9uID0gJ2Rpc2NyZXRlJzsgXG5cbiAgICAgIGlmIChudW1JbnB1dENoYW5uZWxzID4gMSkge1xuICAgICAgICB0aGlzLnNwbGl0dGVyID0gYWMuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5zcGxpdHRlcik7XG4gICAgICAgIHRoaXMuc3BsaXR0ZXIuY29ubmVjdCh0aGlzLmxlZnQsIDEpO1xuICAgICAgICB0aGlzLnNwbGl0dGVyLmNvbm5lY3QodGhpcy5yaWdodCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5sZWZ0KTtcbiAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMucmlnaHQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm91dHB1dCA9IGFjLmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XG4gICAgICB0aGlzLmxlZnQuY29ubmVjdCh0aGlzLm91dHB1dCwgMCwgMSk7XG4gICAgICB0aGlzLnJpZ2h0LmNvbm5lY3QodGhpcy5vdXRwdXQsIDAsIDApO1xuICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdChvdXRwdXQpO1xuICAgIH07IFxuXG5cbiAgICBwNS5QYW5uZXIucHJvdG90eXBlLnBhbiA9IGZ1bmN0aW9uICh2YWwsIHRGcm9tTm93KSB7XG4gICAgICB2YXIgdGltZSA9IHRGcm9tTm93IHx8IDA7XG4gICAgICB2YXIgdCA9IGFjLmN1cnJlbnRUaW1lICsgdGltZTtcbiAgICAgIHZhciB2ID0gKHZhbCArIDEpIC8gMjtcbiAgICAgIHZhciByaWdodFZhbCA9IE1hdGguY29zKHYgKiBNYXRoLlBJIC8gMik7XG4gICAgICB2YXIgbGVmdFZhbCA9IE1hdGguc2luKHYgKiBNYXRoLlBJIC8gMik7XG4gICAgICB0aGlzLmxlZnQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShsZWZ0VmFsLCB0KTtcbiAgICAgIHRoaXMucmlnaHQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShyaWdodFZhbCwgdCk7XG4gICAgfTtcblxuICAgIHA1LlBhbm5lci5wcm90b3R5cGUuaW5wdXRDaGFubmVscyA9IGZ1bmN0aW9uIChudW1DaGFubmVscykge1xuICAgICAgaWYgKG51bUNoYW5uZWxzID09PSAxKSB7XG4gICAgICAgIHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5sZWZ0KTtcbiAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMucmlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChudW1DaGFubmVscyA9PT0gMikge1xuICAgICAgICBpZiAoX3R5cGVvZih0aGlzLnNwbGl0dGVyID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICB0aGlzLnNwbGl0dGVyID0gYWMuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLnNwbGl0dGVyKTtcbiAgICAgICAgdGhpcy5zcGxpdHRlci5jb25uZWN0KHRoaXMubGVmdCwgMSk7XG4gICAgICAgIHRoaXMuc3BsaXR0ZXIuY29ubmVjdCh0aGlzLnJpZ2h0LCAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcDUuUGFubmVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdChvYmopO1xuICAgIH07XG5cbiAgICBwNS5QYW5uZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgQ3VzdG9tRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIGFjID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7XG5cbiAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KSxcbiAgICAgIG1pZGlUb0ZyZXEgPSBfcmVxdWlyZS5taWRpVG9GcmVxLFxuICAgICAgY29udmVydFRvV2F2ID0gX3JlcXVpcmUuY29udmVydFRvV2F2LFxuICAgICAgc2FmZUJ1ZmZlclNpemUgPSBfcmVxdWlyZS5zYWZlQnVmZmVyU2l6ZTtcblxuICB2YXIgcHJvY2Vzc29yTmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbiAgLyoqXG4gICAqICA8cD5Tb3VuZEZpbGUgb2JqZWN0IHdpdGggYSBwYXRoIHRvIGEgZmlsZS48L3A+XG4gICAqXG4gICAqICA8cD5UaGUgcDUuU291bmRGaWxlIG1heSBub3QgYmUgYXZhaWxhYmxlIGltbWVkaWF0ZWx5IGJlY2F1c2VcbiAgICogIGl0IGxvYWRzIHRoZSBmaWxlIGluZm9ybWF0aW9uIGFzeW5jaHJvbm91c2x5LjwvcD5cbiAgICpcbiAgICogIDxwPlRvIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBzb3VuZCBhcyBzb29uIGFzIGl0IGxvYWRzXG4gICAqICBwYXNzIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuPC9wPlxuICAgKlxuICAgKiAgPHA+T25seSBvbmUgZmlsZSBwYXRoIGlzIHJlcXVpcmVkLiBIb3dldmVyLCBhdWRpbyBmaWxlIGZvcm1hdHNcbiAgICogIChpLmUuIG1wMywgb2dnLCB3YXYgYW5kIG00YS9hYWMpIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGFsbFxuICAgKiAgd2ViIGJyb3dzZXJzLiBJZiB5b3Ugd2FudCB0byBlbnN1cmUgY29tcGF0YWJpbGl0eSwgaW5zdGVhZCBvZiBhIHNpbmdsZVxuICAgKiAgZmlsZSBwYXRoLCB5b3UgbWF5IGluY2x1ZGUgYW4gQXJyYXkgb2YgZmlsZXBhdGhzLCBhbmQgdGhlIGJyb3dzZXIgd2lsbFxuICAgKiAgY2hvb3NlIGEgZm9ybWF0IHRoYXQgd29ya3MuPC9wPlxuICAgKlxuICAgKiAgQGNsYXNzIHA1LlNvdW5kRmlsZVxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGF0aCAgIHBhdGggdG8gYSBzb3VuZCBmaWxlIChTdHJpbmcpLiBPcHRpb25hbGx5LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5b3UgbWF5IGluY2x1ZGUgbXVsdGlwbGUgZmlsZSBmb3JtYXRzIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5LiBBbHRlcm5hdGVseSwgYWNjZXB0cyBhbiBvYmplY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSB0aGUgSFRNTDUgRmlsZSBBUEksIG9yIGEgcDUuRmlsZS5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzQ2FsbGJhY2tdICAgTmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSBmaWxlIGxvYWRzXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JDYWxsYmFja10gICBOYW1lIG9mIGEgZnVuY3Rpb24gdG8gY2FsbCBpZiBmaWxlIGZhaWxzIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkLiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBhbiBlcnJvciBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBYTUxIdHRwUmVxdWVzdCBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm91dCB3aGF0IHdlbnQgd3JvbmcuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbd2hpbGVMb2FkaW5nQ2FsbGJhY2tdICAgTmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGNhbGwgd2hpbGUgZmlsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGxvYWRpbmcuIFRoYXQgZnVuY3Rpb24gd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgcHJvZ3Jlc3Mgb2YgdGhlIHJlcXVlc3QgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkIHRoZSBzb3VuZCBmaWxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJldHdlZW4gMCBhbmQgMSkgYXMgaXRzIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyLiBUaGlzIHByb2dyZXNzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3QgYWNjb3VudCBmb3IgdGhlIGFkZGl0aW9uYWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lIG5lZWRlZCB0byBkZWNvZGUgdGhlIGF1ZGlvIGRhdGEuXG4gICAqXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBteVNvdW5kO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgc291bmRGb3JtYXRzKCdtcDMnLCAnb2dnJyk7XG4gICAqICAgIG15U291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9kb29yYmVsbCcpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCBoZXJlIHRvIHBsYXknLCAxMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgLy8gcGxheWluZyBhIHNvdW5kIGZpbGUgb24gYSB1c2VyIGdlc3R1cmVcbiAgICogICAgLy8gaXMgZXF1aXZhbGVudCB0byBgdXNlclN0YXJ0QXVkaW8oKWBcbiAgICogICAgbXlTb3VuZC5wbGF5KCk7XG4gICAqICB9XG4gICAqIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUgPSBmdW5jdGlvbiAocGF0aHMsIG9ubG9hZCwgb25lcnJvciwgd2hpbGVMb2FkaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRocyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aHMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwYXRoc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwNS5wcm90b3R5cGUuX2NoZWNrRmlsZUZvcm1hdHMocGF0aHMpO1xuXG4gICAgICAgIHRoaXMudXJsID0gcGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihwYXRocykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghKHdpbmRvdy5GaWxlICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlTGlzdCAmJiB3aW5kb3cuQmxvYikpIHtcbiAgICAgICAgICB0aHJvdyAnVW5hYmxlIHRvIGxvYWQgZmlsZSBiZWNhdXNlIHRoZSBGaWxlIEFQSSBpcyBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgfVxuICAgICAgfSBcblxuXG4gICAgICBpZiAocGF0aHMuZmlsZSkge1xuICAgICAgICBwYXRocyA9IHBhdGhzLmZpbGU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlsZSA9IHBhdGhzO1xuICAgIH0gXG5cblxuICAgIHRoaXMuX29uZW5kZWQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHRoaXMuX2xvb3BpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF1c2VUaW1lID0gMDsgXG5cbiAgICB0aGlzLl9jdWVzID0gW107XG4gICAgdGhpcy5fY3VlSURDb3VudGVyID0gMDsgXG5cbiAgICB0aGlzLl9sYXN0UG9zID0gMDtcbiAgICB0aGlzLl9jb3VudGVyTm9kZSA9IG51bGw7XG4gICAgdGhpcy5fd29ya2xldE5vZGUgPSBudWxsOyBcblxuICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZXMgPSBbXTsgXG5cbiAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUgPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgdGhpcy5pbnB1dCA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLm91dHB1dCA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLnJldmVyc2VkID0gZmFsc2U7IFxuXG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgdGhpcy5wYXVzZVRpbWUgPSAwOyBcblxuICAgIHRoaXMubW9kZSA9ICdzdXN0YWluJzsgXG5cbiAgICB0aGlzLnN0YXJ0TWlsbGlzID0gbnVsbDsgXG5cbiAgICB0aGlzLnBhblBvc2l0aW9uID0gMC4wO1xuICAgIHRoaXMucGFubmVyID0gbmV3IHA1LlBhbm5lcih0aGlzLm91dHB1dCwgcDVzb3VuZC5pbnB1dCwgMik7IFxuXG4gICAgaWYgKHRoaXMudXJsIHx8IHRoaXMuZmlsZSkge1xuICAgICAgdGhpcy5sb2FkKG9ubG9hZCwgb25lcnJvcik7XG4gICAgfSBcblxuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIHdoaWxlTG9hZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd2hpbGVMb2FkaW5nID0gd2hpbGVMb2FkaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aGlsZUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLl9jbGVhck9uRW5kID0gX2NsZWFyT25FbmQuYmluZCh0aGlzKTtcbiAgfTsgXG5cblxuICBwNS5wcm90b3R5cGUucmVnaXN0ZXJQcmVsb2FkTWV0aG9kKCdsb2FkU291bmQnLCBwNS5wcm90b3R5cGUpO1xuICAvKipcbiAgICogIGxvYWRTb3VuZCgpIHJldHVybnMgYSBuZXcgcDUuU291bmRGaWxlIGZyb20gYSBzcGVjaWZpZWRcbiAgICogIHBhdGguIElmIGNhbGxlZCBkdXJpbmcgcHJlbG9hZCgpLCB0aGUgcDUuU291bmRGaWxlIHdpbGwgYmUgcmVhZHlcbiAgICogIHRvIHBsYXkgaW4gdGltZSBmb3Igc2V0dXAoKSBhbmQgZHJhdygpLiBJZiBjYWxsZWQgb3V0c2lkZSBvZlxuICAgKiAgcHJlbG9hZCwgdGhlIHA1LlNvdW5kRmlsZSB3aWxsIG5vdCBiZSByZWFkeSBpbW1lZGlhdGVseSwgc29cbiAgICogIGxvYWRTb3VuZCBhY2NlcHRzIGEgY2FsbGJhY2sgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuIFVzaW5nIGFcbiAgICogIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vcHJvY2Vzc2luZy9wNS5qcy93aWtpL0xvY2FsLXNlcnZlclwiPlxuICAgKiAgbG9jYWwgc2VydmVyPC9hPiBpcyByZWNvbW1lbmRlZCB3aGVuIGxvYWRpbmcgZXh0ZXJuYWwgZmlsZXMuXG4gICAqXG4gICAqICBAbWV0aG9kIGxvYWRTb3VuZFxuICAgKiAgQGZvciBwNVxuICAgKiAgQHBhcmFtICB7U3RyaW5nfEFycmF5fSAgIHBhdGggICAgIFBhdGggdG8gdGhlIHNvdW5kIGZpbGUsIG9yIGFuIGFycmF5IHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRocyB0byBzb3VuZGZpbGVzIGluIG11bHRpcGxlIGZvcm1hdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmUuIFsnc291bmQub2dnJywgJ3NvdW5kLm1wMyddLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsdGVybmF0ZWx5LCBhY2NlcHRzIGFuIG9iamVjdDogZWl0aGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSB0aGUgSFRNTDUgRmlsZSBBUEksIG9yIGEgcDUuRmlsZS5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzQ2FsbGJhY2tdICAgTmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSBmaWxlIGxvYWRzXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JDYWxsYmFja10gICBOYW1lIG9mIGEgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGVyZSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gZXJyb3IgbG9hZGluZyB0aGUgZmlsZS5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IFt3aGlsZUxvYWRpbmddIE5hbWUgb2YgYSBmdW5jdGlvbiB0byBjYWxsIHdoaWxlIGZpbGUgaXMgbG9hZGluZy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgcGVyY2VudGFnZSBsb2FkZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbyBmYXIsIGZyb20gMC4wIHRvIDEuMC5cbiAgICogIEByZXR1cm4ge1NvdW5kRmlsZX0gICAgICAgICAgICBSZXR1cm5zIGEgcDUuU291bmRGaWxlXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBteVNvdW5kO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgc291bmRGb3JtYXRzKCdtcDMnLCAnb2dnJyk7XG4gICAqICAgIG15U291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9kb29yYmVsbCcpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCBoZXJlIHRvIHBsYXknLCAxMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgLy8gcGxheWluZyBhIHNvdW5kIGZpbGUgb24gYSB1c2VyIGdlc3R1cmVcbiAgICogICAgLy8gaXMgZXF1aXZhbGVudCB0byBgdXNlclN0YXJ0QXVkaW8oKWBcbiAgICogICAgbXlTb3VuZC5wbGF5KCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG4gIHA1LnByb3RvdHlwZS5sb2FkU291bmQgPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2ssIG9uZXJyb3IsIHdoaWxlTG9hZGluZykge1xuICAgIGlmICh3aW5kb3cubG9jYXRpb24ub3JpZ2luLmluZGV4T2YoJ2ZpbGU6Ly8nKSA+IC0xICYmIHdpbmRvdy5jb3Jkb3ZhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LmFsZXJ0KCdUaGlzIHNrZXRjaCBtYXkgcmVxdWlyZSBhIHNlcnZlciB0byBsb2FkIGV4dGVybmFsIGZpbGVzLiBQbGVhc2Ugc2VlIGh0dHA6Ly9iaXQubHkvMXFjSW53UycpO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcyA9IG5ldyBwNS5Tb3VuZEZpbGUocGF0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGYuX2RlY3JlbWVudFByZWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2VsZi5fZGVjcmVtZW50UHJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0sIG9uZXJyb3IsIHdoaWxlTG9hZGluZyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgdGhlIHA1LlNvdW5kRmlsZSBjYWxscyB0byBsb2FkXG4gICAqIGl0c2VsZi4gQWNjZXB0cyBhIGNhbGxiYWNrICh0aGUgbmFtZSBvZiBhbm90aGVyIGZ1bmN0aW9uKVxuICAgKiBhcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzQ2FsbGJhY2tdICAgTmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSBmaWxlIGxvYWRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvckNhbGxiYWNrXSAgIE5hbWUgb2YgYSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoZXJlIGlzIGFuIGVycm9yXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlcnJvclRyYWNlID0gbmV3IEVycm9yKCkuc3RhY2s7XG5cbiAgICBpZiAodGhpcy51cmwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnVybCAhPT0gJycpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBzZWxmLl91cGRhdGVQcm9ncmVzcyhldnQpO1xuICAgICAgfSwgZmFsc2UpO1xuICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIGlmICghc2VsZi5wYW5uZXIpIHJldHVybjtcbiAgICAgICAgICBhYy5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgXG4gICAgICAgICAgZnVuY3Rpb24gKGJ1ZmYpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5wYW5uZXIpIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuYnVmZmVyID0gYnVmZjtcbiAgICAgICAgICAgIHNlbGYucGFubmVyLmlucHV0Q2hhbm5lbHMoYnVmZi5udW1iZXJPZkNoYW5uZWxzKTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5wYW5uZXIpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgQ3VzdG9tRXJyb3IoJ2RlY29kZUF1ZGlvRGF0YScsIGVycm9yVHJhY2UsIHNlbGYudXJsKTtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnQXVkaW9Db250ZXh0IGVycm9yIGF0IGRlY29kZUF1ZGlvRGF0YSBmb3IgJyArIHNlbGYudXJsO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICBlcnIubXNnID0gbXNnO1xuICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyArICdcXG4gVGhlIGVycm9yIHN0YWNrIHRyYWNlIGluY2x1ZGVzOiBcXG4nICsgZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYucGFubmVyKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEN1c3RvbUVycm9yKCdsb2FkU291bmQnLCBlcnJvclRyYWNlLCBzZWxmLnVybCk7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ1VuYWJsZSB0byBsb2FkICcgKyBzZWxmLnVybCArICcuIFRoZSByZXF1ZXN0IHN0YXR1cyB3YXM6ICcgKyByZXF1ZXN0LnN0YXR1cyArICcgKCcgKyByZXF1ZXN0LnN0YXR1c1RleHQgKyAnKSc7XG5cbiAgICAgICAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyArICdcXG4gVGhlIGVycm9yIHN0YWNrIHRyYWNlIGluY2x1ZGVzOiBcXG4nICsgZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9OyBcblxuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgQ3VzdG9tRXJyb3IoJ2xvYWRTb3VuZCcsIGVycm9yVHJhY2UsIHNlbGYudXJsKTtcbiAgICAgICAgdmFyIG1zZyA9ICdUaGVyZSB3YXMgbm8gcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIGF0ICcgKyBzZWxmLnVybCArICcuIENoZWNrIHRoZSB1cmwgYW5kIGludGVybmV0IGNvbm5lY3Rpdml0eS4nO1xuXG4gICAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnICsgJ1xcbiBUaGUgZXJyb3Igc3RhY2sgdHJhY2UgaW5jbHVkZXM6IFxcbicgKyBlcnIuc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzZWxmLnBhbm5lcikgcmV0dXJuO1xuICAgICAgICBhYy5kZWNvZGVBdWRpb0RhdGEocmVhZGVyLnJlc3VsdCwgZnVuY3Rpb24gKGJ1ZmYpIHtcbiAgICAgICAgICBpZiAoIXNlbGYucGFubmVyKSByZXR1cm47XG4gICAgICAgICAgc2VsZi5idWZmZXIgPSBidWZmO1xuICAgICAgICAgIHNlbGYucGFubmVyLmlucHV0Q2hhbm5lbHMoYnVmZi5udW1iZXJPZkNoYW5uZWxzKTtcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnBhbm5lcikgcmV0dXJuO1xuXG4gICAgICAgIGlmIChvbmVycm9yKSB7XG4gICAgICAgICAgb25lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHRoaXMuZmlsZSk7XG4gICAgfVxuICB9OyBcblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuX3VwZGF0ZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmIChldnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgdmFyIHBlcmNlbnRDb21wbGV0ZSA9IGV2dC5sb2FkZWQgLyBldnQudG90YWwgKiAwLjk5O1xuXG4gICAgICB0aGlzLl93aGlsZUxvYWRpbmcocGVyY2VudENvbXBsZXRlLCBldnQpOyBcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aGlsZUxvYWRpbmcoJ3NpemUgdW5rbm93bicpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHNvdW5kIGZpbGUgZmluaXNoZWQgbG9hZGluZyBzdWNjZXNzZnVsbHkuXG4gICAqXG4gICAqICBAbWV0aG9kICBpc0xvYWRlZFxuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUGxheSB0aGUgcDUuU291bmRGaWxlXG4gICAqXG4gICAqIEBtZXRob2QgcGxheVxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0VGltZV0gICAgICAgICAgICAob3B0aW9uYWwpIHNjaGVkdWxlIHBsYXliYWNrIHRvIHN0YXJ0IChpbiBzZWNvbmRzIGZyb20gbm93KS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRlXSAgICAgICAgICAgICAob3B0aW9uYWwpIHBsYXliYWNrIHJhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFthbXBdICAgICAgICAgICAgICAob3B0aW9uYWwpIGFtcGxpdHVkZSAodm9sdW1lKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBwbGF5YmFja1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2N1ZVN0YXJ0XSAgICAgICAgKG9wdGlvbmFsKSBjdWUgc3RhcnQgdGltZSBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb25dICAgICAgICAgIChvcHRpb25hbCkgZHVyYXRpb24gb2YgcGxheWJhY2sgaW4gc2Vjb25kc1xuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChzdGFydFRpbWUsIHJhdGUsIGFtcCwgX2N1ZVN0YXJ0LCBkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5vdXRwdXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignU291bmRGaWxlLnBsYXkoKSBjYWxsZWQgYWZ0ZXIgZGlzcG9zZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgY3VlU3RhcnQsIGN1ZUVuZDtcbiAgICB2YXIgdGltZSA9IHN0YXJ0VGltZSB8fCAwO1xuXG4gICAgaWYgKHRpbWUgPCAwKSB7XG4gICAgICB0aW1lID0gMDtcbiAgICB9XG5cbiAgICB0aW1lID0gdGltZSArIG5vdztcblxuICAgIGlmICh0eXBlb2YgcmF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmF0ZShyYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFtcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuc2V0Vm9sdW1lKGFtcCk7XG4gICAgfSBcblxuXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICB0aGlzLl9wYXVzZVRpbWUgPSAwOyBcblxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ3Jlc3RhcnQnICYmIHRoaXMuYnVmZmVyICYmIHRoaXMuYnVmZmVyU291cmNlTm9kZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUuc3RvcCh0aW1lKTtcblxuICAgICAgICB0aGlzLl9jb3VudGVyTm9kZS5zdG9wKHRpbWUpO1xuICAgICAgfSBcblxuXG4gICAgICBpZiAodGhpcy5tb2RlID09PSAndW50aWxkb25lJyAmJiB0aGlzLmlzUGxheWluZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gXG5cblxuICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlID0gdGhpcy5faW5pdFNvdXJjZU5vZGUoKTsgXG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9jb3VudGVyTm9kZTtcbiAgICAgIHRoaXMuX2NvdW50ZXJOb2RlID0gdGhpcy5faW5pdENvdW50ZXJOb2RlKCk7XG5cbiAgICAgIGlmIChfY3VlU3RhcnQpIHtcbiAgICAgICAgaWYgKF9jdWVTdGFydCA+PSAwICYmIF9jdWVTdGFydCA8IHRoaXMuYnVmZmVyLmR1cmF0aW9uKSB7XG4gICAgICAgICAgY3VlU3RhcnQgPSBfY3VlU3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ3N0YXJ0IHRpbWUgb3V0IG9mIHJhbmdlJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VlU3RhcnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiA8PSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIGN1ZVN0YXJ0ID8gZHVyYXRpb24gOiB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcbiAgICAgIH0gXG5cblxuICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUuc3RhcnQodGltZSwgdGhpcy5wYXVzZVRpbWUsIGR1cmF0aW9uKTtcblxuICAgICAgICB0aGlzLl9jb3VudGVyTm9kZS5zdGFydCh0aW1lLCB0aGlzLnBhdXNlVGltZSwgZHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLnN0YXJ0KHRpbWUsIGN1ZVN0YXJ0LCBkdXJhdGlvbik7XG5cbiAgICAgICAgdGhpcy5fY291bnRlck5vZGUuc3RhcnQodGltZSwgY3VlU3RhcnQsIGR1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGxheWluZyA9IHRydWU7XG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTsgXG5cbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZXMucHVzaCh0aGlzLmJ1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLl9hcnJheUluZGV4ID0gdGhpcy5idWZmZXJTb3VyY2VOb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5fY2xlYXJPbkVuZCk7XG4gICAgfSBcbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgJ25vdCByZWFkeSB0byBwbGF5IGZpbGUsIGJ1ZmZlciBoYXMgeWV0IHRvIGxvYWQuIFRyeSBwcmVsb2FkKCknO1xuICAgICAgfSBcblxuXG4gICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLmxvb3AgPSB0aGlzLl9sb29waW5nO1xuICAgIHRoaXMuX2NvdW50ZXJOb2RlLmxvb3AgPSB0aGlzLl9sb29waW5nO1xuXG4gICAgaWYgKHRoaXMuX2xvb3BpbmcgPT09IHRydWUpIHtcbiAgICAgIGN1ZUVuZCA9IGR1cmF0aW9uID8gZHVyYXRpb24gOiBjdWVTdGFydCAtIDAuMDAwMDAwMDAwMDAwMDAxO1xuICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLmxvb3BTdGFydCA9IGN1ZVN0YXJ0O1xuICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLmxvb3BFbmQgPSBjdWVFbmQ7XG4gICAgICB0aGlzLl9jb3VudGVyTm9kZS5sb29wU3RhcnQgPSBjdWVTdGFydDtcbiAgICAgIHRoaXMuX2NvdW50ZXJOb2RlLmxvb3BFbmQgPSBjdWVFbmQ7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIHA1LlNvdW5kRmlsZSBoYXMgdHdvIHBsYXkgbW9kZXM6IDxjb2RlPnJlc3RhcnQ8L2NvZGU+IGFuZFxuICAgKiAgPGNvZGU+c3VzdGFpbjwvY29kZT4uIFBsYXkgTW9kZSBkZXRlcm1pbmVzIHdoYXQgaGFwcGVucyB0byBhXG4gICAqICBwNS5Tb3VuZEZpbGUgaWYgaXQgaXMgdHJpZ2dlcmVkIHdoaWxlIGluIHRoZSBtaWRkbGUgb2YgcGxheWJhY2suXG4gICAqICBJbiBzdXN0YWluIG1vZGUsIHBsYXliYWNrIHdpbGwgY29udGludWUgc2ltdWx0YW5lb3VzIHRvIHRoZVxuICAgKiAgbmV3IHBsYXliYWNrLiBJbiByZXN0YXJ0IG1vZGUsIHBsYXkoKSB3aWxsIHN0b3AgcGxheWJhY2tcbiAgICogIGFuZCBzdGFydCBvdmVyLiBXaXRoIHVudGlsRG9uZSwgYSBzb3VuZCB3aWxsIHBsYXkgb25seSBpZiBpdCdzXG4gICAqICBub3QgYWxyZWFkeSBwbGF5aW5nLiBTdXN0YWluIGlzIHRoZSBkZWZhdWx0IG1vZGUuXG4gICAqXG4gICAqICBAbWV0aG9kICBwbGF5TW9kZVxuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEBwYXJhbSAge1N0cmluZ30gc3RyICdyZXN0YXJ0JyBvciAnc3VzdGFpbicgb3IgJ3VudGlsRG9uZSdcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IG15U291bmQ7XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCl7XG4gICAqICAgIG15U291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9EYW1zY3JheV9EYW5jaW5nVGlnZXIubXAzJyk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoY2FudmFzUHJlc3NlZCk7XG4gICAqICAgIG5vRmlsbCgpO1xuICAgKiAgICByZWN0KDAsIGhlaWdodC8yLCB3aWR0aCAtIDEsIGhlaWdodC8yIC0gMSk7XG4gICAqICAgIHJlY3QoMCwgMCwgd2lkdGggLSAxLCBoZWlnaHQvMik7XG4gICAqICAgIHRleHRBbGlnbihDRU5URVIsIENFTlRFUik7XG4gICAqICAgIGZpbGwoMjApO1xuICAgKiAgICB0ZXh0KCdyZXN0YXJ0Jywgd2lkdGgvMiwgMSAqIGhlaWdodC80KTtcbiAgICogICAgdGV4dCgnc3VzdGFpbicsIHdpZHRoLzIsIDMgKiBoZWlnaHQvNCk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBjYW52YXNQcmVzc2VkKCkge1xuICAgKiAgICBpZiAobW91c2VYIDwgaGVpZ2h0LzIpIHtcbiAgICogICAgICBteVNvdW5kLnBsYXlNb2RlKCdyZXN0YXJ0Jyk7XG4gICAqICAgIH0gZWxzZSB7XG4gICAqICAgICAgbXlTb3VuZC5wbGF5TW9kZSgnc3VzdGFpbicpO1xuICAgKiAgICB9XG4gICAqICAgIG15U291bmQucGxheSgpO1xuICAgKiAgfVxuICAgKlxuICAgKiA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5wbGF5TW9kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgcyA9IHN0ci50b0xvd2VyQ2FzZSgpOyBcblxuICAgIGlmIChzID09PSAncmVzdGFydCcgJiYgdGhpcy5idWZmZXIgJiYgdGhpcy5idWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVyU291cmNlTm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2Rlc1tpXS5zdG9wKG5vdyk7XG4gICAgICB9XG4gICAgfSBcblxuXG4gICAgaWYgKHMgPT09ICdyZXN0YXJ0JyB8fCBzID09PSAnc3VzdGFpbicgfHwgcyA9PT0gJ3VudGlsZG9uZScpIHtcbiAgICAgIHRoaXMubW9kZSA9IHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdJbnZhbGlkIHBsYXkgbW9kZS4gTXVzdCBiZSBlaXRoZXIgXCJyZXN0YXJ0XCIgb3IgXCJzdXN0YWluXCInO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBQYXVzZXMgYSBmaWxlIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcuIElmIHRoZSBmaWxlIGlzIG5vdFxuICAgKiAgcGxheWluZywgdGhlbiBub3RoaW5nIHdpbGwgaGFwcGVuLlxuICAgKlxuICAgKiAgQWZ0ZXIgcGF1c2luZywgLnBsYXkoKSB3aWxsIHJlc3VtZSBmcm9tIHRoZSBwYXVzZWRcbiAgICogIHBvc2l0aW9uLlxuICAgKiAgSWYgcDUuU291bmRGaWxlIGhhZCBiZWVuIHNldCB0byBsb29wIGJlZm9yZSBpdCB3YXMgcGF1c2VkLFxuICAgKiAgaXQgd2lsbCBjb250aW51ZSB0byBsb29wIGFmdGVyIGl0IGlzIHVucGF1c2VkIHdpdGggLnBsYXkoKS5cbiAgICpcbiAgICogIEBtZXRob2QgcGF1c2VcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3N0YXJ0VGltZV0gKG9wdGlvbmFsKSBzY2hlZHVsZSBldmVudCB0byBvY2N1clxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBzb3VuZEZpbGU7XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBzb3VuZEZvcm1hdHMoJ29nZycsICdtcDMnKTtcbiAgICogICAgc291bmRGaWxlID0gbG9hZFNvdW5kKCdhc3NldHMvRGFtc2NyYXlfLV9EYW5jaW5nX1RpZ2VyXzAyLm1wMycpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5LCByZWxlYXNlIHRvIHBhdXNlJywgMTAsIDIwLCB3aWR0aCAtIDIwKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIGNhbnZhc1ByZXNzZWQoKSB7XG4gICAqICAgIHNvdW5kRmlsZS5sb29wKCk7XG4gICAqICAgIGJhY2tncm91bmQoMCwgMjAwLCA1MCk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICBzb3VuZEZpbGUucGF1c2UoKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPlxuICAgKiAgPC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChzdGFydFRpbWUpIHtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIHRpbWUgPSBzdGFydFRpbWUgfHwgMDtcbiAgICB2YXIgcFRpbWUgPSB0aW1lICsgbm93O1xuXG4gICAgaWYgKHRoaXMuaXNQbGF5aW5nKCkgJiYgdGhpcy5idWZmZXIgJiYgdGhpcy5idWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5wYXVzZVRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKCk7XG4gICAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUuc3RvcChwVGltZSk7XG5cbiAgICAgIHRoaXMuX2NvdW50ZXJOb2RlLnN0b3AocFRpbWUpO1xuXG4gICAgICB0aGlzLl9wYXVzZVRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKCk7IFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXVzZVRpbWUgPSAwO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIExvb3AgdGhlIHA1LlNvdW5kRmlsZS4gQWNjZXB0cyBvcHRpb25hbCBwYXJhbWV0ZXJzIHRvIHNldCB0aGVcbiAgICogcGxheWJhY2sgcmF0ZSwgcGxheWJhY2sgdm9sdW1lLCBsb29wU3RhcnQsIGxvb3BFbmQuXG4gICAqXG4gICAqIEBtZXRob2QgbG9vcFxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0VGltZV0gKG9wdGlvbmFsKSBzY2hlZHVsZSBldmVudCB0byBvY2N1clxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyBmcm9tIG5vd1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3JhdGVdICAgICAgICAob3B0aW9uYWwpIHBsYXliYWNrIHJhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFthbXBdICAgICAgICAgKG9wdGlvbmFsKSBwbGF5YmFjayB2b2x1bWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjdWVMb29wU3RhcnRdIChvcHRpb25hbCkgc3RhcnRUaW1lIGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbl0gIChvcHRpb25hbCkgbG9vcCBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IHNvdW5kRmlsZTtcbiAgICogIGxldCBsb29wU3RhcnQgPSAwLjU7XG4gICAqICBsZXQgbG9vcER1cmF0aW9uID0gMC4yO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgc291bmRGb3JtYXRzKCdvZ2cnLCAnbXAzJyk7XG4gICAqICAgIHNvdW5kRmlsZSA9IGxvYWRTb3VuZCgnYXNzZXRzL0RhbXNjcmF5Xy1fRGFuY2luZ19UaWdlcl8wMi5tcDMnKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheSwgcmVsZWFzZSB0byBwYXVzZScsIDEwLCAyMCwgd2lkdGggLSAyMCk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBjYW52YXNQcmVzc2VkKCkge1xuICAgKiAgICBzb3VuZEZpbGUubG9vcCgpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDAsIDIwMCwgNTApO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgc291bmRGaWxlLnBhdXNlKCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogIH1cbiAgICogIDwvY29kZT5cbiAgICogIDwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uIChzdGFydFRpbWUsIHJhdGUsIGFtcCwgbG9vcFN0YXJ0LCBkdXJhdGlvbikge1xuICAgIHRoaXMuX2xvb3BpbmcgPSB0cnVlO1xuICAgIHRoaXMucGxheShzdGFydFRpbWUsIHJhdGUsIGFtcCwgbG9vcFN0YXJ0LCBkdXJhdGlvbik7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgYSBwNS5Tb3VuZEZpbGUncyBsb29waW5nIGZsYWcgdG8gdHJ1ZSBvciBmYWxzZS4gSWYgdGhlIHNvdW5kXG4gICAqIGlzIGN1cnJlbnRseSBwbGF5aW5nLCB0aGlzIGNoYW5nZSB3aWxsIHRha2UgZWZmZWN0IHdoZW4gaXRcbiAgICogcmVhY2hlcyB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHBsYXliYWNrLlxuICAgKlxuICAgKiBAbWV0aG9kIHNldExvb3BcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBCb29sZWFuICAgc2V0IGxvb3BpbmcgdG8gdHJ1ZSBvciBmYWxzZVxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2xvb3BpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYm9vbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2xvb3BpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ0Vycm9yOiBzZXRMb29wIGFjY2VwdHMgZWl0aGVyIHRydWUgb3IgZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJ1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5sb29wID0gdGhpcy5fbG9vcGluZztcbiAgICAgIHRoaXMuX2NvdW50ZXJOb2RlLmxvb3AgPSB0aGlzLl9sb29waW5nO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgJ3RydWUnIGlmIGEgcDUuU291bmRGaWxlIGlzIGN1cnJlbnRseSBsb29waW5nIGFuZCBwbGF5aW5nLCAnZmFsc2UnIGlmIG5vdC5cbiAgICpcbiAgICogQG1ldGhvZCBpc0xvb3BpbmdcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmlzTG9vcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyU291cmNlTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9sb29waW5nID09PSB0cnVlICYmIHRoaXMuaXNQbGF5aW5nKCkgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm5zIHRydWUgaWYgYSBwNS5Tb3VuZEZpbGUgaXMgcGxheWluZywgZmFsc2UgaWYgbm90IChpLmUuXG4gICAqICBwYXVzZWQgb3Igc3RvcHBlZCkuXG4gICAqXG4gICAqICBAbWV0aG9kIGlzUGxheWluZ1xuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyB0cnVlIGlmIGEgcDUuU291bmRGaWxlIGlzIHBhdXNlZCwgZmFsc2UgaWYgbm90IChpLmUuXG4gICAqICBwbGF5aW5nIG9yIHN0b3BwZWQpLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgaXNQYXVzZWRcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfTtcbiAgLyoqXG4gICAqIFN0b3Agc291bmRmaWxlIHBsYXliYWNrLlxuICAgKlxuICAgKiBAbWV0aG9kIHN0b3BcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFRpbWVdIChvcHRpb25hbCkgc2NoZWR1bGUgZXZlbnQgdG8gb2NjdXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZUZyb21Ob3cpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVGcm9tTm93IHx8IDA7XG5cbiAgICBpZiAodGhpcy5tb2RlID09PSAnc3VzdGFpbicgfHwgdGhpcy5tb2RlID09PSAndW50aWxkb25lJykge1xuICAgICAgdGhpcy5zdG9wQWxsKHRpbWUpO1xuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5wYXVzZVRpbWUgPSAwO1xuICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1ZmZlciAmJiB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHZhciB0ID0gdGltZSB8fCAwO1xuICAgICAgdGhpcy5wYXVzZVRpbWUgPSAwO1xuICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLnN0b3Aobm93ICsgdCk7XG5cbiAgICAgIHRoaXMuX2NvdW50ZXJOb2RlLnN0b3Aobm93ICsgdCk7XG5cbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTdG9wIHBsYXliYWNrIG9uIGFsbCBvZiB0aGlzIHNvdW5kZmlsZSdzIHNvdXJjZXMuXG4gICAqICBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuc3RvcEFsbCA9IGZ1bmN0aW9uIChfdGltZSkge1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgdGltZSA9IF90aW1lIHx8IDA7XG5cbiAgICBpZiAodGhpcy5idWZmZXIgJiYgdGhpcy5idWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuYnVmZmVyU291cmNlTm9kZXMpIHtcbiAgICAgICAgdmFyIGJ1ZmZlclNvdXJjZU5vZGUgPSB0aGlzLmJ1ZmZlclNvdXJjZU5vZGVzW2ldO1xuXG4gICAgICAgIGlmICghIWJ1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnVmZmVyU291cmNlTm9kZS5zdG9wKG5vdyArIHRpbWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY291bnRlck5vZGUuc3RvcChub3cgKyB0aW1lKTtcblxuICAgICAgdGhpcy5fb25lbmRlZCh0aGlzKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgTXVsdGlwbHkgdGhlIG91dHB1dCB2b2x1bWUgKGFtcGxpdHVkZSkgb2YgYSBzb3VuZCBmaWxlXG4gICAqICBiZXR3ZWVuIDAuMCAoc2lsZW5jZSkgYW5kIDEuMCAoZnVsbCB2b2x1bWUpLlxuICAgKiAgMS4wIGlzIHRoZSBtYXhpbXVtIGFtcGxpdHVkZSBvZiBhIGRpZ2l0YWwgc291bmQsIHNvIG11bHRpcGx5aW5nXG4gICAqICBieSBncmVhdGVyIHRoYW4gMS4wIG1heSBjYXVzZSBkaWdpdGFsIGRpc3RvcnRpb24uIFRvXG4gICAqICBmYWRlLCBwcm92aWRlIGEgPGNvZGU+cmFtcFRpbWU8L2NvZGU+IHBhcmFtZXRlci4gRm9yIG1vcmVcbiAgICogIGNvbXBsZXggZmFkZXMsIHNlZSB0aGUgRW52ZWxvcGUgY2xhc3MuXG4gICAqXG4gICAqICBBbHRlcm5hdGVseSwgeW91IGNhbiBwYXNzIGluIGEgc2lnbmFsIHNvdXJjZSBzdWNoIGFzIGFuXG4gICAqICBvc2NpbGxhdG9yIHRvIG1vZHVsYXRlIHRoZSBhbXBsaXR1ZGUgd2l0aCBhbiBhdWRpbyBzaWduYWwuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRWb2x1bWVcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZvbHVtZSAgVm9sdW1lIChhbXBsaXR1ZGUpIGJldHdlZW4gMC4wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCAxLjAgb3IgbW9kdWxhdGluZyBzaWduYWwvb3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtyYW1wVGltZV0gIEZhZGUgZm9yIHQgc2Vjb25kc1xuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gIFNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuIGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2b2wsIF9yYW1wVGltZSwgX3RGcm9tTm93KSB7XG4gICAgaWYgKHR5cGVvZiB2b2wgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgcmFtcFRpbWUgPSBfcmFtcFRpbWUgfHwgMDtcbiAgICAgIHZhciB0RnJvbU5vdyA9IF90RnJvbU5vdyB8fCAwO1xuICAgICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdmFyIGN1cnJlbnRWb2wgPSB0aGlzLm91dHB1dC5nYWluLnZhbHVlO1xuICAgICAgdGhpcy5vdXRwdXQuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMobm93ICsgdEZyb21Ob3cpO1xuICAgICAgdGhpcy5vdXRwdXQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShjdXJyZW50Vm9sLCBub3cgKyB0RnJvbU5vdyk7XG4gICAgICB0aGlzLm91dHB1dC5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZvbCwgbm93ICsgdEZyb21Ob3cgKyByYW1wVGltZSk7XG4gICAgfSBlbHNlIGlmICh2b2wpIHtcbiAgICAgIHZvbC5jb25uZWN0KHRoaXMub3V0cHV0LmdhaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXQuZ2FpbjtcbiAgICB9XG4gIH07IFxuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5hbXAgPSBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnNldFZvbHVtZTsgXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5mYWRlID0gcDUuU291bmRGaWxlLnByb3RvdHlwZS5zZXRWb2x1bWU7XG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0LmdhaW4udmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0ZXJlbyBwYW5uaW5nIG9mIGEgcDUuc291bmQgb2JqZWN0IHRvXG4gICAqIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gLTEuMCAobGVmdCkgYW5kIDEuMCAocmlnaHQpLlxuICAgKiBEZWZhdWx0IGlzIDAuMCAoY2VudGVyKS5cbiAgICpcbiAgICogQG1ldGhvZCBwYW5cbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYW5WYWx1ZV0gICAgIFNldCB0aGUgc3RlcmVvIHBhbm5lclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVGcm9tTm93XSAgc2NoZWR1bGUgdGhpcyBldmVudCB0byBoYXBwZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqIEBleGFtcGxlXG4gICAqIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgYmFsbFggPSAwO1xuICAgKiAgbGV0IHNvdW5kRmlsZTtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIHNvdW5kRm9ybWF0cygnb2dnJywgJ21wMycpO1xuICAgKiAgICBzb3VuZEZpbGUgPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Ym94Lm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoY2FudmFzUHJlc3NlZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgYmFsbFggPSBjb25zdHJhaW4obW91c2VYLCAwLCB3aWR0aCk7XG4gICAqICAgIGVsbGlwc2UoYmFsbFgsIGhlaWdodC8yLCAyMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpe1xuICAgKiAgICAvLyBtYXAgdGhlIGJhbGwncyB4IGxvY2F0aW9uIHRvIGEgcGFubmluZyBkZWdyZWVcbiAgICogICAgLy8gYmV0d2VlbiAtMS4wIChsZWZ0KSBhbmQgMS4wIChyaWdodClcbiAgICogICAgbGV0IHBhbm5pbmcgPSBtYXAoYmFsbFgsIDAuLCB3aWR0aCwtMS4wLCAxLjApO1xuICAgKiAgICBzb3VuZEZpbGUucGFuKHBhbm5pbmcpO1xuICAgKiAgICBzb3VuZEZpbGUucGxheSgpO1xuICAgKiAgfVxuICAgKiAgPC9kaXY+PC9jb2RlPlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUucGFuID0gZnVuY3Rpb24gKHB2YWwsIHRGcm9tTm93KSB7XG4gICAgdGhpcy5wYW5Qb3NpdGlvbiA9IHB2YWw7XG4gICAgdGhpcy5wYW5uZXIucGFuKHB2YWwsIHRGcm9tTm93KTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RlcmVvIHBhbiBwb3NpdGlvbiAoLTEuMCB0byAxLjApXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0UGFuXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgc3RlcmVvIHBhbiBzZXR0aW5nIG9mIHRoZSBPc2NpbGxhdG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBhIG51bWJlciBiZXR3ZWVuIC0xLjAgKGxlZnQpIGFuZCAxLjAgKHJpZ2h0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIDAuMCBpcyBjZW50ZXIgYW5kIGRlZmF1bHQuXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5nZXRQYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFuUG9zaXRpb247XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBwbGF5YmFjayByYXRlIG9mIGEgc291bmQgZmlsZS4gV2lsbCBjaGFuZ2UgdGhlIHNwZWVkIGFuZCB0aGUgcGl0Y2guXG4gICAqICBWYWx1ZXMgbGVzcyB0aGFuIHplcm8gd2lsbCByZXZlcnNlIHRoZSBhdWRpbyBidWZmZXIuXG4gICAqXG4gICAqICBAbWV0aG9kIHJhdGVcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3BsYXliYWNrUmF0ZV0gICAgIFNldCB0aGUgcGxheWJhY2sgcmF0ZS4gMS4wIGlzIG5vcm1hbCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLjUgaXMgaGFsZi1zcGVlZCwgMi4wIGlzIHR3aWNlIGFzIGZhc3QuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlcyBsZXNzIHRoYW4gemVybyBwbGF5IGJhY2t3YXJkcy5cbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IG15U291bmQ7XG4gICAqXG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBteVNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvRGFtc2NyYXlfRGFuY2luZ1RpZ2VyLm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgbXlTb3VuZC5sb29wKCk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICBteVNvdW5kLnBhdXNlKCk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqXG4gICAqICAgIC8vIFNldCB0aGUgcmF0ZSB0byBhIHJhbmdlIGJldHdlZW4gMC4xIGFuZCA0XG4gICAqICAgIC8vIENoYW5naW5nIHRoZSByYXRlIGFsc28gYWx0ZXJzIHRoZSBwaXRjaFxuICAgKiAgICBsZXQgcGxheWJhY2tSYXRlID0gbWFwKG1vdXNlWSwgMC4xLCBoZWlnaHQsIDIsIDApO1xuICAgKiAgICBwbGF5YmFja1JhdGUgPSBjb25zdHJhaW4ocGxheWJhY2tSYXRlLCAwLjAxLCA0KTtcbiAgICogICAgbXlTb3VuZC5yYXRlKHBsYXliYWNrUmF0ZSk7XG4gICAqXG4gICAqICAgIGxpbmUoMCwgbW91c2VZLCB3aWR0aCwgbW91c2VZKTtcbiAgICogICAgdGV4dCgncmF0ZTogJyArIHJvdW5kKHBsYXliYWNrUmF0ZSAqIDEwMCkgKyAnJScsIDEwLCAyMCk7XG4gICAqICB9XG4gICAqXG4gICAqIDwvY29kZT5cbiAgICogPC9kaXY+XG4gICAqXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5yYXRlID0gZnVuY3Rpb24gKHBsYXliYWNrUmF0ZSkge1xuICAgIHZhciByZXZlcnNlID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIHBsYXliYWNrUmF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZTtcblxuICAgIGlmIChwbGF5YmFja1JhdGUgPT09IDApIHtcbiAgICAgIHBsYXliYWNrUmF0ZSA9IDAuMDAwMDAwMDAwMDAwMTtcbiAgICB9IGVsc2UgaWYgKHBsYXliYWNrUmF0ZSA8IDAgJiYgIXRoaXMucmV2ZXJzZWQpIHtcbiAgICAgIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKHBsYXliYWNrUmF0ZSk7XG4gICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBsYXliYWNrUmF0ZSA+IDAgJiYgdGhpcy5yZXZlcnNlZCkge1xuICAgICAgcmV2ZXJzZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnVmZmVyU291cmNlTm9kZSkge1xuICAgICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLnBsYXliYWNrUmF0ZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMobm93KTtcbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5wbGF5YmFja1JhdGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoTWF0aC5hYnMocGxheWJhY2tSYXRlKSwgbm93KTtcblxuICAgICAgdGhpcy5fY291bnRlck5vZGUucGxheWJhY2tSYXRlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhub3cpO1xuXG4gICAgICB0aGlzLl9jb3VudGVyTm9kZS5wbGF5YmFja1JhdGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoTWF0aC5hYnMocGxheWJhY2tSYXRlKSwgbm93KTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgdGhpcy5yZXZlcnNlQnVmZmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xuICB9OyBcblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuc2V0UGl0Y2ggPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdmFyIG5ld1BsYXliYWNrUmF0ZSA9IG1pZGlUb0ZyZXEobnVtKSAvIG1pZGlUb0ZyZXEoNjApO1xuICAgIHRoaXMucmF0ZShuZXdQbGF5YmFja1JhdGUpO1xuICB9O1xuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuZ2V0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGR1cmF0aW9uIG9mIGEgc291bmQgZmlsZSBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAbWV0aG9kIGR1cmF0aW9uXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGR1cmF0aW9uIG9mIHRoZSBzb3VuZEZpbGUgaW4gc2Vjb25kcy5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHA1LlNvdW5kRmlsZSBwbGF5aGVhZCwgaW4gc2Vjb25kcy5cbiAgICogVGltZSBpcyByZWxhdGl2ZSB0byB0aGUgbm9ybWFsIGJ1ZmZlciBkaXJlY3Rpb24sIHNvIGlmIGByZXZlcnNlQnVmZmVyYFxuICAgKiBoYXMgYmVlbiBjYWxsZWQsIGN1cnJlbnRUaW1lIHdpbGwgY291bnQgYmFja3dhcmRzLlxuICAgKlxuICAgKiBAbWV0aG9kIGN1cnJlbnRUaW1lXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEByZXR1cm4ge051bWJlcn0gICBjdXJyZW50VGltZSBvZiB0aGUgc291bmRGaWxlIGluIHNlY29uZHMuXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5jdXJyZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCA/IE1hdGguYWJzKHRoaXMuX2xhc3RQb3MgLSB0aGlzLmJ1ZmZlci5sZW5ndGgpIC8gYWMuc2FtcGxlUmF0ZSA6IHRoaXMuX2xhc3RQb3MgLyBhYy5zYW1wbGVSYXRlO1xuICB9O1xuICAvKipcbiAgICogTW92ZSB0aGUgcGxheWhlYWQgb2YgYSBzb3VuZGZpbGUgdGhhdCBpcyBjdXJyZW50bHkgcGxheWluZyB0byBhXG4gICAqIG5ldyBwb3NpdGlvbiBhbmQgYSBuZXcgZHVyYXRpb24sIGluIHNlY29uZHMuXG4gICAqIElmIG5vbmUgYXJlIGdpdmVuLCB3aWxsIHJlc2V0IHRoZSBmaWxlIHRvIHBsYXkgZW50aXJlIGR1cmF0aW9uXG4gICAqIGZyb20gc3RhcnQgdG8gZmluaXNoLiBUbyBzZXQgdGhlIHBvc2l0aW9uIG9mIGEgc291bmRmaWxlIHRoYXQgaXNcbiAgICogbm90IGN1cnJlbnRseSBwbGF5aW5nLCB1c2UgdGhlIGBwbGF5YCBvciBgbG9vcGAgbWV0aG9kcy5cbiAgICpcbiAgICogQG1ldGhvZCBqdW1wXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjdWVUaW1lICAgIGN1ZVRpbWUgb2YgdGhlIHNvdW5kRmlsZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gICAgZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmp1bXAgPSBmdW5jdGlvbiAoY3VlVGltZSwgZHVyYXRpb24pIHtcbiAgICBpZiAoY3VlVGltZSA8IDAgfHwgY3VlVGltZSA+IHRoaXMuYnVmZmVyLmR1cmF0aW9uKSB7XG4gICAgICB0aHJvdyAnanVtcCB0aW1lIG91dCBvZiByYW5nZSc7XG4gICAgfVxuXG4gICAgaWYgKGR1cmF0aW9uID4gdGhpcy5idWZmZXIuZHVyYXRpb24gLSBjdWVUaW1lKSB7XG4gICAgICB0aHJvdyAnZW5kIHRpbWUgb3V0IG9mIHJhbmdlJztcbiAgICB9XG5cbiAgICB2YXIgY1RpbWUgPSBjdWVUaW1lIHx8IDA7XG4gICAgdmFyIGR1ciA9IGR1cmF0aW9uIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLmlzUGxheWluZygpKSB7XG4gICAgICB0aGlzLnN0b3AoMCk7XG4gICAgICB0aGlzLnBsYXkoMCwgdGhpcy5wbGF5YmFja1JhdGUsIHRoaXMub3V0cHV0LmdhaW4udmFsdWUsIGNUaW1lLCBkdXIpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBjaGFubmVscyBpbiBhIHNvdW5kIGZpbGUuXG4gICAgKiBGb3IgZXhhbXBsZSwgTW9ubyA9IDEsIFN0ZXJlbyA9IDIuXG4gICAgKlxuICAgICogQG1ldGhvZCBjaGFubmVsc1xuICAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICAqIEByZXR1cm4ge051bWJlcn0gW2NoYW5uZWxzXVxuICAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmNoYW5uZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuICB9O1xuICAvKipcbiAgICAqIFJldHVybiB0aGUgc2FtcGxlIHJhdGUgb2YgdGhlIHNvdW5kIGZpbGUuXG4gICAgKlxuICAgICogQG1ldGhvZCBzYW1wbGVSYXRlXG4gICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgICogQHJldHVybiB7TnVtYmVyfSBbc2FtcGxlUmF0ZV1cbiAgICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5zYW1wbGVSYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zYW1wbGVSYXRlO1xuICB9O1xuICAvKipcbiAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgaW4gYSBzb3VuZCBmaWxlLlxuICAgICogRXF1YWwgdG8gc2FtcGxlUmF0ZSAqIGR1cmF0aW9uLlxuICAgICpcbiAgICAqIEBtZXRob2QgZnJhbWVzXG4gICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgICogQHJldHVybiB7TnVtYmVyfSBbc2FtcGxlQ291bnRdXG4gICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuZnJhbWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFtcGxpdHVkZSBwZWFrcyBpbiBhIHA1LlNvdW5kRmlsZSB0aGF0IGNhbiBiZVxuICAgKiB1c2VkIHRvIGRyYXcgYSBzdGF0aWMgd2F2ZWZvcm0uIFNjYW5zIHRocm91Z2ggdGhlIHA1LlNvdW5kRmlsZSdzXG4gICAqIGF1ZGlvIGJ1ZmZlciB0byBmaW5kIHRoZSBncmVhdGVzdCBhbXBsaXR1ZGVzLiBBY2NlcHRzIG9uZVxuICAgKiBwYXJhbWV0ZXIsICdsZW5ndGgnLCB3aGljaCBkZXRlcm1pbmVzIHNpemUgb2YgdGhlIGFycmF5LlxuICAgKiBMYXJnZXIgYXJyYXlzIHJlc3VsdCBpbiBtb3JlIHByZWNpc2Ugd2F2ZWZvcm0gdmlzdWFsaXphdGlvbnMuXG4gICAqXG4gICAqIEluc3BpcmVkIGJ5IFdhdmVzdXJmZXIuanMuXG4gICAqXG4gICAqIEBtZXRob2QgIGdldFBlYWtzXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEBwYXJhbXMge051bWJlcn0gW2xlbmd0aF0gbGVuZ3RoIGlzIHRoZSBzaXplIG9mIHRoZSByZXR1cm5lZCBhcnJheS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIExhcmdlciBsZW5ndGggcmVzdWx0cyBpbiBtb3JlIHByZWNpc2lvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIDUqd2lkdGggb2YgdGhlIGJyb3dzZXIgd2luZG93LlxuICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSBBcnJheSBvZiBwZWFrcy5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmdldFBlYWtzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gd2luZG93LndpZHRoICogNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdmFyIHNhbXBsZVNpemUgPSBidWZmZXIubGVuZ3RoIC8gbGVuZ3RoO1xuICAgICAgICB2YXIgc2FtcGxlU3RlcCA9IH5+KHNhbXBsZVNpemUgLyAxMCkgfHwgMTtcbiAgICAgICAgdmFyIGNoYW5uZWxzID0gYnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICAgIHZhciBwZWFrcyA9IG5ldyBGbG9hdDMyQXJyYXkoTWF0aC5yb3VuZChsZW5ndGgpKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICB2YXIgY2hhbiA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YShjKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IH5+KGkgKiBzYW1wbGVTaXplKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB+fihzdGFydCArIHNhbXBsZVNpemUpO1xuICAgICAgICAgICAgdmFyIG1heCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8IGVuZDsgaiArPSBzYW1wbGVTdGVwKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNoYW5bal07XG5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7IFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKC12YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjID09PSAwIHx8IE1hdGguYWJzKG1heCkgPiBwZWFrc1tpXSkge1xuICAgICAgICAgICAgICBwZWFrc1tpXSA9IG1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGVha3M7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdDYW5ub3QgbG9hZCBwZWFrcyB5ZXQsIGJ1ZmZlciBpcyBub3QgbG9hZGVkJztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmV2ZXJzZXMgdGhlIHA1LlNvdW5kRmlsZSdzIGJ1ZmZlciBzb3VyY2UuXG4gICAqICBQbGF5YmFjayBtdXN0IGJlIGhhbmRsZWQgc2VwYXJhdGVseSAoc2VlIGV4YW1wbGUpLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcmV2ZXJzZUJ1ZmZlclxuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGRydW07XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBkcnVtID0gbG9hZFNvdW5kKCdhc3NldHMvZHJ1bS5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBjYW52YXNQcmVzc2VkKCkge1xuICAgKiAgICBkcnVtLnN0b3AoKTtcbiAgICogICAgZHJ1bS5yZXZlcnNlQnVmZmVyKCk7XG4gICAqICAgIGRydW0ucGxheSgpO1xuICAgKiAgfVxuICAgKiA8L2NvZGU+XG4gICAqIDwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUucmV2ZXJzZUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHZhciBjdXJyZW50UG9zID0gdGhpcy5fbGFzdFBvcyAvIGFjLnNhbXBsZVJhdGU7XG4gICAgICB2YXIgY3VyVm9sID0gdGhpcy5nZXRWb2x1bWUoKTtcbiAgICAgIHRoaXMuc2V0Vm9sdW1lKDAsIDAuMDAxKTtcbiAgICAgIHZhciBudW1DaGFubmVscyA9IHRoaXMuYnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhbm5lbHM7IGkrKykge1xuICAgICAgICB0aGlzLmJ1ZmZlci5nZXRDaGFubmVsRGF0YShpKS5yZXZlcnNlKCk7XG4gICAgICB9IFxuXG5cbiAgICAgIHRoaXMucmV2ZXJzZWQgPSAhdGhpcy5yZXZlcnNlZDtcblxuICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKCkgJiYgY3VycmVudFBvcykge1xuICAgICAgICB0aGlzLmp1bXAodGhpcy5kdXJhdGlvbigpIC0gY3VycmVudFBvcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0Vm9sdW1lKGN1clZvbCwgMC4wMDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnU291bmRGaWxlIGlzIG5vdCBkb25lIGxvYWRpbmcnO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTY2hlZHVsZSBhbiBldmVudCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc291bmRmaWxlXG4gICAqICByZWFjaGVzIHRoZSBlbmQgb2YgYSBidWZmZXIuIElmIHRoZSBzb3VuZGZpbGUgaXNcbiAgICogIHBsYXlpbmcgdGhyb3VnaCBvbmNlLCB0aGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gaXRcbiAgICogIGVuZHMuIElmIGl0IGlzIGxvb3BpbmcsIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICogIHN0b3AgaXMgY2FsbGVkLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgb25lbmRlZFxuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291bmRmaWxlIGhhcyBlbmRlZC5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLm9uZW5kZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbmVuZGVkID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gIH07XG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTsgXG5cbiAgICB2YXIgaW5kZXggPSBwNXNvdW5kLnNvdW5kQXJyYXkuaW5kZXhPZih0aGlzKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLnN0b3Aobm93KTtcblxuICAgIGlmICh0aGlzLmJ1ZmZlciAmJiB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXJTb3VyY2VOb2Rlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyU291cmNlTm9kZXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGVzW2ldLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGVzW2ldLnN0b3Aobm93KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ25vIGJ1ZmZlciBzb3VyY2Ugbm9kZSB0byBkaXNwb3NlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2Rlc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9jb3VudGVyTm9kZS5zdG9wKG5vdyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvdW50ZXJOb2RlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYW5uZXIpIHtcbiAgICAgIHRoaXMucGFubmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMucGFubmVyID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgb3V0cHV0IG9mIGEgcDVzb3VuZCBvYmplY3QgdG8gaW5wdXQgb2YgYW5vdGhlclxuICAgKiBwNS5zb3VuZCBvYmplY3QuIEZvciBleGFtcGxlLCB5b3UgbWF5IGNvbm5lY3QgYSBwNS5Tb3VuZEZpbGUgdG8gYW5cbiAgICogRkZUIG9yIGFuIEVmZmVjdC4gSWYgbm8gcGFyYW1ldGVyIGlzIGdpdmVuLCBpdCB3aWxsIGNvbm5lY3QgdG9cbiAgICogdGhlIG1hc3RlciBvdXRwdXQuIE1vc3QgcDVzb3VuZCBvYmplY3RzIGNvbm5lY3QgdG8gdGhlIG1hc3RlclxuICAgKiBvdXRwdXQgd2hlbiB0aGV5IGFyZSBjcmVhdGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIGNvbm5lY3RcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIEF1ZGlvIG9iamVjdCB0aGF0IGFjY2VwdHMgYW4gaW5wdXRcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIGlmICghdW5pdCkge1xuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdChwNXNvdW5kLmlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHVuaXQuaGFzT3duUHJvcGVydHkoJ2lucHV0JykpIHtcbiAgICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh1bml0LmlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodW5pdCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIG91dHB1dCBvZiB0aGlzIHA1c291bmQgb2JqZWN0LlxuICAgKlxuICAgKiBAbWV0aG9kIGRpc2Nvbm5lY3RcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFubmVyKSB7XG4gICAgICB0aGlzLnBhbm5lci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUud2FybigncDUuU291bmRGaWxlLmdldExldmVsIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbGlicmFyeS4gVXNlIHA1LkFtcGxpdHVkZSBpbnN0ZWFkJyk7XG4gIH07XG4gIC8qKlxuICAgKiAgUmVzZXQgdGhlIHNvdXJjZSBmb3IgdGhpcyBTb3VuZEZpbGUgdG8gYVxuICAgKiAgbmV3IHBhdGggKFVSTCkuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRQYXRoXG4gICAqICBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiAgQHBhcmFtIHtTdHJpbmd9ICAgcGF0aCAgICAgcGF0aCB0byBhdWRpbyBmaWxlXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uIChwLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXRoID0gcDUucHJvdG90eXBlLl9jaGVja0ZpbGVGb3JtYXRzKHApO1xuXG4gICAgdGhpcy51cmwgPSBwYXRoO1xuICAgIHRoaXMubG9hZChjYWxsYmFjayk7XG4gIH07XG4gIC8qKlxuICAgKiAgUmVwbGFjZSB0aGUgY3VycmVudCBBdWRpbyBCdWZmZXIgd2l0aCBhIG5ldyBCdWZmZXIuXG4gICAqXG4gICAqICBAbWV0aG9kIHNldEJ1ZmZlclxuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEBwYXJhbSB7QXJyYXl9IGJ1ZiBBcnJheSBvZiBGbG9hdDMyIEFycmF5KHMpLiAyIEZsb2F0MzIgQXJyYXlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgd2lsbCBjcmVhdGUgYSBzdGVyZW8gc291cmNlLiAxIHdpbGwgY3JlYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgYSBtb25vIHNvdXJjZS5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnNldEJ1ZmZlciA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSBidWYubGVuZ3RoO1xuICAgIHZhciBzaXplID0gYnVmWzBdLmxlbmd0aDtcbiAgICB2YXIgbmV3QnVmZmVyID0gYWMuY3JlYXRlQnVmZmVyKG51bUNoYW5uZWxzLCBzaXplLCBhYy5zYW1wbGVSYXRlKTtcblxuICAgIGlmICghKGJ1ZlswXSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgIGJ1ZlswXSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmWzBdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBjaGFubmVsTnVtID0gMDsgY2hhbm5lbE51bSA8IG51bUNoYW5uZWxzOyBjaGFubmVsTnVtKyspIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3QnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWxOdW0pO1xuICAgICAgY2hhbm5lbC5zZXQoYnVmW2NoYW5uZWxOdW1dKTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjsgXG5cbiAgICB0aGlzLnBhbm5lci5pbnB1dENoYW5uZWxzKG51bUNoYW5uZWxzKTtcbiAgfTsgXG5cblxuICB2YXIgX2NyZWF0ZUNvdW50ZXJCdWZmZXIgPSBmdW5jdGlvbiBfY3JlYXRlQ291bnRlckJ1ZmZlcihidWZmZXIpIHtcbiAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICB2YXIgYXVkaW9CdWYgPSBhYy5jcmVhdGVCdWZmZXIoMSwgYnVmZmVyLmxlbmd0aCwgYWMuc2FtcGxlUmF0ZSk7XG4gICAgdmFyIGFycmF5QnVmZmVyID0gYXVkaW9CdWYuZ2V0Q2hhbm5lbERhdGEoMCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICBhcnJheUJ1ZmZlcltpbmRleF0gPSBpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXVkaW9CdWY7XG4gIH07IFxuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5faW5pdENvdW50ZXJOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5vdyA9IGFjLmN1cnJlbnRUaW1lO1xuICAgIHZhciBjTm9kZSA9IGFjLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgIHZhciB3b3JrbGV0QnVmZmVyU2l6ZSA9IHNhZmVCdWZmZXJTaXplKDI1Nik7IFxuXG4gICAgaWYgKHNlbGYuX3dvcmtsZXROb2RlKSB7XG4gICAgICBzZWxmLl93b3JrbGV0Tm9kZS5kaXNjb25uZWN0KCk7XG5cbiAgICAgIGRlbGV0ZSBzZWxmLl93b3JrbGV0Tm9kZTtcbiAgICB9XG5cbiAgICBzZWxmLl93b3JrbGV0Tm9kZSA9IG5ldyBBdWRpb1dvcmtsZXROb2RlKGFjLCBwcm9jZXNzb3JOYW1lcy5zb3VuZEZpbGVQcm9jZXNzb3IsIHtcbiAgICAgIHByb2Nlc3Nvck9wdGlvbnM6IHtcbiAgICAgICAgYnVmZmVyU2l6ZTogd29ya2xldEJ1ZmZlclNpemVcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNlbGYuX3dvcmtsZXROb2RlLnBvcnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGF0YS5uYW1lID09PSAncG9zaXRpb24nKSB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLnBvc2l0aW9uID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX2xhc3RQb3MgPSBldmVudC5kYXRhLnBvc2l0aW9uOyBcblxuICAgICAgICBfdGhpcy5fb25UaW1lVXBkYXRlKHNlbGYuX2xhc3RQb3MpO1xuICAgICAgfVxuICAgIH07IFxuXG5cbiAgICBjTm9kZS5idWZmZXIgPSBfY3JlYXRlQ291bnRlckJ1ZmZlcihzZWxmLmJ1ZmZlcik7XG4gICAgY05vZGUucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKHNlbGYucGxheWJhY2tSYXRlLCBub3cpO1xuICAgIGNOb2RlLmNvbm5lY3Qoc2VsZi5fd29ya2xldE5vZGUpO1xuXG4gICAgc2VsZi5fd29ya2xldE5vZGUuY29ubmVjdChwNS5zb3VuZE91dC5fc2lsZW50Tm9kZSk7XG5cbiAgICByZXR1cm4gY05vZGU7XG4gIH07IFxuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5faW5pdFNvdXJjZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1ZmZlclNvdXJjZU5vZGUgPSBhYy5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICBidWZmZXJTb3VyY2VOb2RlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIGJ1ZmZlclNvdXJjZU5vZGUucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XG4gICAgYnVmZmVyU291cmNlTm9kZS5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICByZXR1cm4gYnVmZmVyU291cmNlTm9kZTtcbiAgfTtcbiAgLyoqXG4gICAqICBwcm9jZXNzUGVha3MgcmV0dXJucyBhbiBhcnJheSBvZiB0aW1lc3RhbXBzIHdoZXJlIGl0IHRoaW5rcyB0aGVyZSBpcyBhIGJlYXQuXG4gICAqXG4gICAqICBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyB0aGUgc291bmRmaWxlIGluIGFuIG9mZmxpbmUgYXVkaW8gY29udGV4dCxcbiAgICogIGFuZCBzZW5kcyB0aGUgcmVzdWx0cyB0byB5b3VyIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgVGhlIHByb2Nlc3MgaW52b2x2ZXMgcnVubmluZyB0aGUgc291bmRmaWxlIHRocm91Z2ggYSBsb3dwYXNzIGZpbHRlciwgYW5kIGZpbmRpbmcgYWxsIG9mIHRoZVxuICAgKiAgcGVha3MgYWJvdmUgdGhlIGluaXRpYWwgdGhyZXNob2xkLiBJZiB0aGUgdG90YWwgbnVtYmVyIG9mIHBlYWtzIGFyZSBiZWxvdyB0aGUgbWluaW11bSBudW1iZXIgb2YgcGVha3MsXG4gICAqICBpdCBkZWNyZWFzZXMgdGhlIHRocmVzaG9sZCBhbmQgcmUtcnVucyB0aGUgYW5hbHlzaXMgdW50aWwgZWl0aGVyIG1pblBlYWtzIG9yIG1pblRocmVzaG9sZCBhcmUgcmVhY2hlZC5cbiAgICpcbiAgICogIEBtZXRob2QgIHByb2Nlc3NQZWFrc1xuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICBhIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSB0aGlzIGRhdGEgaXMgcmV0dXJuZWRcbiAgICogIEBwYXJhbSAge051bWJlcn0gICBbaW5pdFRocmVzaG9sZF0gaW5pdGlhbCB0aHJlc2hvbGQgZGVmYXVsdHMgdG8gMC45XG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9ICAgW21pblRocmVzaG9sZF0gICBtaW5pbXVtIHRocmVzaG9sZCBkZWZhdWx0cyB0byAwLjIyXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9ICAgW21pblBlYWtzXSAgICAgICBtaW5pbXVtIG51bWJlciBvZiBwZWFrcyBkZWZhdWx0cyB0byAyMDBcbiAgICogIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICAgIEFycmF5IG9mIHRpbWVzdGFtcGVkIHBlYWtzXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5wcm9jZXNzUGVha3MgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIF9pbml0VGhyZXNob2xkLCBfbWluVGhyZXNob2xkLCBfbWluUGVha3MpIHtcbiAgICB2YXIgYnVmTGVuID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIHZhciBzYW1wbGVSYXRlID0gdGhpcy5idWZmZXIuc2FtcGxlUmF0ZTtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgdmFyIGFsbFBlYWtzID0gW107XG4gICAgdmFyIGluaXRpYWxUaHJlc2hvbGQgPSBfaW5pdFRocmVzaG9sZCB8fCAwLjksXG4gICAgICAgIHRocmVzaG9sZCA9IGluaXRpYWxUaHJlc2hvbGQsXG4gICAgICAgIG1pblRocmVzaG9sZCA9IF9taW5UaHJlc2hvbGQgfHwgMC4yMixcbiAgICAgICAgbWluUGVha3MgPSBfbWluUGVha3MgfHwgMjAwOyBcblxuICAgIHZhciBvZmZsaW5lQ29udGV4dCA9IG5ldyB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCBidWZMZW4sIHNhbXBsZVJhdGUpOyBcblxuICAgIHZhciBzb3VyY2UgPSBvZmZsaW5lQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICBzb3VyY2UuYnVmZmVyID0gYnVmZmVyOyBcblxuICAgIHZhciBmaWx0ZXIgPSBvZmZsaW5lQ29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICBmaWx0ZXIudHlwZSA9ICdsb3dwYXNzJztcbiAgICBzb3VyY2UuY29ubmVjdChmaWx0ZXIpO1xuICAgIGZpbHRlci5jb25uZWN0KG9mZmxpbmVDb250ZXh0LmRlc3RpbmF0aW9uKTsgXG5cbiAgICBzb3VyY2Uuc3RhcnQoMCk7XG4gICAgb2ZmbGluZUNvbnRleHQuc3RhcnRSZW5kZXJpbmcoKTsgXG5cbiAgICBvZmZsaW5lQ29udGV4dC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghc2VsZi5wYW5uZXIpIHJldHVybjtcbiAgICAgIHZhciBmaWx0ZXJlZEJ1ZmZlciA9IGUucmVuZGVyZWRCdWZmZXI7XG4gICAgICB2YXIgYnVmZmVyRGF0YSA9IGZpbHRlcmVkQnVmZmVyLmdldENoYW5uZWxEYXRhKDApOyBcblxuICAgICAgZG8ge1xuICAgICAgICBhbGxQZWFrcyA9IGdldFBlYWtzQXRUaHJlc2hvbGQoYnVmZmVyRGF0YSwgdGhyZXNob2xkKTtcbiAgICAgICAgdGhyZXNob2xkIC09IDAuMDA1O1xuICAgICAgfSB3aGlsZSAoT2JqZWN0LmtleXMoYWxsUGVha3MpLmxlbmd0aCA8IG1pblBlYWtzICYmIHRocmVzaG9sZCA+PSBtaW5UaHJlc2hvbGQpOyBcblxuXG4gICAgICB2YXIgaW50ZXJ2YWxDb3VudHMgPSBjb3VudEludGVydmFsc0JldHdlZW5OZWFyYnlQZWFrcyhhbGxQZWFrcyk7IFxuXG4gICAgICB2YXIgZ3JvdXBzID0gZ3JvdXBOZWlnaGJvcnNCeVRlbXBvKGludGVydmFsQ291bnRzLCBmaWx0ZXJlZEJ1ZmZlci5zYW1wbGVSYXRlKTsgXG5cbiAgICAgIHZhciB0b3BUZW1wb3MgPSBncm91cHMuc29ydChmdW5jdGlvbiAoaW50QSwgaW50Qikge1xuICAgICAgICByZXR1cm4gaW50Qi5jb3VudCAtIGludEEuY291bnQ7XG4gICAgICB9KS5zcGxpY2UoMCwgNSk7IFxuXG4gICAgICB0aGlzLnRlbXBvID0gdG9wVGVtcG9zWzBdLnRlbXBvOyBcblxuICAgICAgdmFyIGJwbVZhcmlhbmNlID0gNTtcbiAgICAgIHZhciB0ZW1wb1BlYWtzID0gZ2V0UGVha3NBdFRvcFRlbXBvKGFsbFBlYWtzLCB0b3BUZW1wb3NbMF0udGVtcG8sIGZpbHRlcmVkQnVmZmVyLnNhbXBsZVJhdGUsIGJwbVZhcmlhbmNlKTtcbiAgICAgIGNhbGxiYWNrKHRlbXBvUGVha3MpO1xuICAgIH07XG4gIH07IFxuXG5cbiAgdmFyIFBlYWsgPSBmdW5jdGlvbiBQZWFrKGFtcCwgaSkge1xuICAgIHRoaXMuc2FtcGxlSW5kZXggPSBpO1xuICAgIHRoaXMuYW1wbGl0dWRlID0gYW1wO1xuICAgIHRoaXMudGVtcG9zID0gW107XG4gICAgdGhpcy5pbnRlcnZhbHMgPSBbXTtcbiAgfTsgXG5cblxuICBmdW5jdGlvbiBnZXRQZWFrc0F0VGhyZXNob2xkKGRhdGEsIHRocmVzaG9sZCkge1xuICAgIHZhciBwZWFrc09iaiA9IHt9O1xuICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkYXRhW2ldID4gdGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBhbXAgPSBkYXRhW2ldO1xuICAgICAgICB2YXIgcGVhayA9IG5ldyBQZWFrKGFtcCwgaSk7XG4gICAgICAgIHBlYWtzT2JqW2ldID0gcGVhazsgXG5cbiAgICAgICAgaSArPSA2MDAwO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlYWtzT2JqO1xuICB9IFxuXG5cbiAgZnVuY3Rpb24gY291bnRJbnRlcnZhbHNCZXR3ZWVuTmVhcmJ5UGVha3MocGVha3NPYmopIHtcbiAgICB2YXIgaW50ZXJ2YWxDb3VudHMgPSBbXTtcbiAgICB2YXIgcGVha3NBcnJheSA9IE9iamVjdC5rZXlzKHBlYWtzT2JqKS5zb3J0KCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGVha3NBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnRQZWFrID0gcGVha3NPYmpbcGVha3NBcnJheVtpbmRleF1dO1xuICAgICAgICB2YXIgZW5kUGVhayA9IHBlYWtzT2JqW3BlYWtzQXJyYXlbaW5kZXggKyBpXV07XG5cbiAgICAgICAgaWYgKHN0YXJ0UGVhayAmJiBlbmRQZWFrKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9zID0gc3RhcnRQZWFrLnNhbXBsZUluZGV4O1xuICAgICAgICAgIHZhciBlbmRQb3MgPSBlbmRQZWFrLnNhbXBsZUluZGV4O1xuICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGVuZFBvcyAtIHN0YXJ0UG9zOyBcblxuICAgICAgICAgIGlmIChpbnRlcnZhbCA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0UGVhay5pbnRlcnZhbHMucHVzaChpbnRlcnZhbCk7XG4gICAgICAgICAgfSBcblxuXG4gICAgICAgICAgdmFyIGZvdW5kSW50ZXJ2YWwgPSBpbnRlcnZhbENvdW50cy5zb21lKGZ1bmN0aW9uIChpbnRlcnZhbENvdW50KSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWxDb3VudC5pbnRlcnZhbCA9PT0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgaW50ZXJ2YWxDb3VudC5jb3VudCsrO1xuICAgICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWxDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgXG5cbiAgICAgICAgICBpZiAoIWZvdW5kSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGludGVydmFsQ291bnRzLnB1c2goe1xuICAgICAgICAgICAgICBpbnRlcnZhbDogaW50ZXJ2YWwsXG4gICAgICAgICAgICAgIGNvdW50OiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJ2YWxDb3VudHM7XG4gIH0gXG5cblxuICBmdW5jdGlvbiBncm91cE5laWdoYm9yc0J5VGVtcG8oaW50ZXJ2YWxDb3VudHMsIHNhbXBsZVJhdGUpIHtcbiAgICB2YXIgdGVtcG9Db3VudHMgPSBbXTtcbiAgICBpbnRlcnZhbENvdW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnZhbENvdW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdGhlb3JldGljYWxUZW1wbyA9IE1hdGguYWJzKDYwIC8gKGludGVydmFsQ291bnQuaW50ZXJ2YWwgLyBzYW1wbGVSYXRlKSk7XG4gICAgICAgIHRoZW9yZXRpY2FsVGVtcG8gPSBtYXBUZW1wbyh0aGVvcmV0aWNhbFRlbXBvKTtcbiAgICAgICAgdmFyIGZvdW5kVGVtcG8gPSB0ZW1wb0NvdW50cy5zb21lKGZ1bmN0aW9uICh0ZW1wb0NvdW50KSB7XG4gICAgICAgICAgaWYgKHRlbXBvQ291bnQudGVtcG8gPT09IHRoZW9yZXRpY2FsVGVtcG8pIHJldHVybiB0ZW1wb0NvdW50LmNvdW50ICs9IGludGVydmFsQ291bnQuY291bnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZm91bmRUZW1wbykge1xuICAgICAgICAgIGlmIChpc05hTih0aGVvcmV0aWNhbFRlbXBvKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRlbXBvQ291bnRzLnB1c2goe1xuICAgICAgICAgICAgdGVtcG86IE1hdGgucm91bmQodGhlb3JldGljYWxUZW1wbyksXG4gICAgICAgICAgICBjb3VudDogaW50ZXJ2YWxDb3VudC5jb3VudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRlbXBvQ291bnRzO1xuICB9IFxuXG5cbiAgZnVuY3Rpb24gZ2V0UGVha3NBdFRvcFRlbXBvKHBlYWtzT2JqLCB0ZW1wbywgc2FtcGxlUmF0ZSwgYnBtVmFyaWFuY2UpIHtcbiAgICB2YXIgcGVha3NBdFRvcFRlbXBvID0gW107XG4gICAgdmFyIHBlYWtzQXJyYXkgPSBPYmplY3Qua2V5cyhwZWFrc09iaikuc29ydCgpOyBcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGVha3NBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHBlYWtzQXJyYXlbaV07XG4gICAgICB2YXIgcGVhayA9IHBlYWtzT2JqW2tleV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVhay5pbnRlcnZhbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGludGVydmFsQlBNID0gTWF0aC5yb3VuZChNYXRoLmFicyg2MCAvIChwZWFrLmludGVydmFsc1tqXSAvIHNhbXBsZVJhdGUpKSk7XG4gICAgICAgIGludGVydmFsQlBNID0gbWFwVGVtcG8oaW50ZXJ2YWxCUE0pO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhpbnRlcnZhbEJQTSAtIHRlbXBvKSA8IGJwbVZhcmlhbmNlKSB7XG4gICAgICAgICAgcGVha3NBdFRvcFRlbXBvLnB1c2gocGVhay5zYW1wbGVJbmRleCAvIHNhbXBsZVJhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBcblxuXG4gICAgcGVha3NBdFRvcFRlbXBvID0gcGVha3NBdFRvcFRlbXBvLmZpbHRlcihmdW5jdGlvbiAocGVha1RpbWUsIGluZGV4LCBhcnIpIHtcbiAgICAgIHZhciBkaWYgPSBhcnJbaW5kZXggKyAxXSAtIHBlYWtUaW1lO1xuXG4gICAgICBpZiAoZGlmID4gMC4wMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGVha3NBdFRvcFRlbXBvO1xuICB9IFxuXG5cbiAgZnVuY3Rpb24gbWFwVGVtcG8odGhlb3JldGljYWxUZW1wbykge1xuICAgIGlmICghaXNGaW5pdGUodGhlb3JldGljYWxUZW1wbykgfHwgdGhlb3JldGljYWxUZW1wbyA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gXG5cblxuICAgIHdoaWxlICh0aGVvcmV0aWNhbFRlbXBvIDwgOTApIHtcbiAgICAgIHRoZW9yZXRpY2FsVGVtcG8gKj0gMjtcbiAgICB9XG5cbiAgICB3aGlsZSAodGhlb3JldGljYWxUZW1wbyA+IDE4MCAmJiB0aGVvcmV0aWNhbFRlbXBvID4gOTApIHtcbiAgICAgIHRoZW9yZXRpY2FsVGVtcG8gLz0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhlb3JldGljYWxUZW1wbztcbiAgfVxuXG5cbiAgdmFyIEN1ZSA9IGZ1bmN0aW9uIEN1ZShjYWxsYmFjaywgdGltZSwgaWQsIHZhbCkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbiAgfTtcbiAgLyoqXG4gICAqICBTY2hlZHVsZSBldmVudHMgdG8gdHJpZ2dlciBldmVyeSB0aW1lIGEgTWVkaWFFbGVtZW50XG4gICAqICAoYXVkaW8vdmlkZW8pIHJlYWNoZXMgYSBwbGF5YmFjayBjdWUgcG9pbnQuXG4gICAqXG4gICAqICBBY2NlcHRzIGEgY2FsbGJhY2sgZnVuY3Rpb24sIGEgdGltZSAoaW4gc2Vjb25kcykgYXQgd2hpY2ggdG8gdHJpZ2dlclxuICAgKiAgdGhlIGNhbGxiYWNrLCBhbmQgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIGZvciB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqICBUaW1lIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLFxuICAgKiAgYW5kIHBhcmFtIHdpbGwgYmUgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqXG4gICAqICBAbWV0aG9kICBhZGRDdWVcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0ge051bWJlcn0gICB0aW1lICAgICBUaW1lIGluIHNlY29uZHMsIHJlbGF0aXZlIHRvIHRoaXMgbWVkaWFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQncyBwbGF5YmFjay4gRm9yIGV4YW1wbGUsIHRvIHRyaWdnZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV2ZW50IGV2ZXJ5IHRpbWUgcGxheWJhY2sgcmVhY2hlcyB0d29cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMsIHBhc3MgaW4gdGhlIG51bWJlciAyLiBUaGlzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBOYW1lIG9mIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWQgYXQgdGhlIGdpdmVuIHRpbWUuIFRoZSBjYWxsYmFjayB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlIHRpbWUgYW5kIChvcHRpb25hbGx5KSBwYXJhbSBhcyBpdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3byBwYXJhbWV0ZXJzLlxuICAgKiAgQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gICAgQW4gb2JqZWN0IHRvIGJlIHBhc3NlZCBhcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZCBwYXJhbWV0ZXIgdG8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogIEByZXR1cm4ge051bWJlcn0gaWQgSUQgb2YgdGhpcyBjdWUsXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHVzZWZ1bCBmb3IgcmVtb3ZlQ3VlKGlkKVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgbXlTb3VuZDtcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIG15U291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9EYW1zY3JheV9EYW5jaW5nVGlnZXIubXAzJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoY2FudmFzUHJlc3NlZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAxMCwgMjApO1xuICAgKlxuICAgKiAgICAvLyBzY2hlZHVsZSBjYWxscyB0byBjaGFuZ2VUZXh0XG4gICAqICAgIG15U291bmQuYWRkQ3VlKDAsIGNoYW5nZVRleHQsIFwiaGVsbG9cIiApO1xuICAgKiAgICBteVNvdW5kLmFkZEN1ZSgwLjUsIGNoYW5nZVRleHQsIFwiaGVsbG8sXCIgKTtcbiAgICogICAgbXlTb3VuZC5hZGRDdWUoMSwgY2hhbmdlVGV4dCwgXCJoZWxsbywgcDUhXCIpO1xuICAgKiAgICBteVNvdW5kLmFkZEN1ZSgxLjUsIGNoYW5nZVRleHQsIFwiaGVsbG8sIHA1ISFcIik7XG4gICAqICAgIG15U291bmQuYWRkQ3VlKDIsIGNoYW5nZVRleHQsIFwiaGVsbG8sIHA1ISEhISFcIik7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBjaGFuZ2VUZXh0KHZhbCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQodmFsLCAxMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgbXlTb3VuZC5wbGF5KCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5hZGRDdWUgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2ssIHZhbCkge1xuICAgIHZhciBpZCA9IHRoaXMuX2N1ZUlEQ291bnRlcisrO1xuICAgIHZhciBjdWUgPSBuZXcgQ3VlKGNhbGxiYWNrLCB0aW1lLCBpZCwgdmFsKTtcblxuICAgIHRoaXMuX2N1ZXMucHVzaChjdWUpOyBcblxuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuICAvKipcbiAgICogIFJlbW92ZSBhIGNhbGxiYWNrIGJhc2VkIG9uIGl0cyBJRC4gVGhlIElEIGlzIHJldHVybmVkIGJ5IHRoZVxuICAgKiAgYWRkQ3VlIG1ldGhvZC5cbiAgICpcbiAgICogIEBtZXRob2QgcmVtb3ZlQ3VlXG4gICAqICBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBpZCBJRCBvZiB0aGUgY3VlLCBhcyByZXR1cm5lZCBieSBhZGRDdWVcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnJlbW92ZUN1ZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBjdWVMZW5ndGggPSB0aGlzLl9jdWVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VlTGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSB0aGlzLl9jdWVzW2ldO1xuXG4gICAgICBpZiAoY3VlLmlkID09PSBpZCkge1xuICAgICAgICB0aGlzLl9jdWVzLnNwbGljZShpLCAxKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmVtb3ZlIGFsbCBvZiB0aGUgY2FsbGJhY2tzIHRoYXQgaGFkIG9yaWdpbmFsbHkgYmVlbiBzY2hlZHVsZWRcbiAgICogIHZpYSB0aGUgYWRkQ3VlIG1ldGhvZC5cbiAgICpcbiAgICogIEBtZXRob2QgIGNsZWFyQ3Vlc1xuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuY2xlYXJDdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2N1ZXMgPSBbXTsgXG4gIH07IFxuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5fb25UaW1lVXBkYXRlID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIHBsYXliYWNrVGltZSA9IHBvc2l0aW9uIC8gdGhpcy5idWZmZXIuc2FtcGxlUmF0ZTtcbiAgICB2YXIgY3VlTGVuZ3RoID0gdGhpcy5fY3Vlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZUxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VlID0gdGhpcy5fY3Vlc1tpXTtcbiAgICAgIHZhciBjYWxsYmFja1RpbWUgPSBjdWUudGltZTtcbiAgICAgIHZhciB2YWwgPSBjdWUudmFsO1xuXG4gICAgICBpZiAofn50aGlzLl9wcmV2VXBkYXRlVGltZSA8PSBjYWxsYmFja1RpbWUgJiYgY2FsbGJhY2tUaW1lIDw9IHBsYXliYWNrVGltZSkge1xuICAgICAgICBjdWUuY2FsbGJhY2sodmFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2VXBkYXRlVGltZSA9IHBsYXliYWNrVGltZTtcbiAgfTtcbiAgLyoqXG4gICAqIFNhdmUgYSBwNS5Tb3VuZEZpbGUgYXMgYSAud2F2IGZpbGUuIFRoZSBicm93c2VyIHdpbGwgcHJvbXB0IHRoZSB1c2VyXG4gICAqIHRvIGRvd25sb2FkIHRoZSBmaWxlIHRvIHRoZWlyIGRldmljZS4gVG8gdXBsb2FkIGEgZmlsZSB0byBhIHNlcnZlciwgc2VlXG4gICAqIDxhIGhyZWY9XCIvZG9jcy9yZWZlcmVuY2UvIy9wNS5Tb3VuZEZpbGUvZ2V0QmxvYlwiPmdldEJsb2I8L2E+XG4gICAqXG4gICAqIEBtZXRob2Qgc2F2ZVxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmaWxlTmFtZV0gICAgICBuYW1lIG9mIHRoZSByZXN1bHRpbmcgLndhdiBmaWxlLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBteVNvdW5kO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgbXlTb3VuZCA9IGxvYWRTb3VuZCgnYXNzZXRzL2Rvb3JiZWxsLm1wMycpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBkb3dubG9hZCcsIDEwLCAyMCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBjYW52YXNQcmVzc2VkKCkge1xuICAgKiAgICBteVNvdW5kLnNhdmUoJ215IGNvb2wgZmlsZW5hbWUnKTtcbiAgICogIH1cbiAgICogPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgIHA1LnByb3RvdHlwZS5zYXZlU291bmQodGhpcywgZmlsZU5hbWUsICd3YXYnKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3Igc2VuZGluZyBhIFNvdW5kRmlsZSB0byBhIHNlcnZlci4gSXQgcmV0dXJucyB0aGVcbiAgICogLndhdi1lbmNvZGVkIGF1ZGlvIGRhdGEgYXMgYSBcIjxhIHRhcmdldD1cIl9ibGFua1wiIHRpdGxlPVwiQmxvYiByZWZlcmVuY2UgYXRcbiAgICogTUROXCIgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iXCI+QmxvYjwvYT5cIi5cbiAgICogQSBCbG9iIGlzIGEgZmlsZS1saWtlIGRhdGEgb2JqZWN0IHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIGEgc2VydmVyXG4gICAqIHdpdGggYW4gPGEgaHJlZj1cIi9kb2NzL3JlZmVyZW5jZS8jL3A1L2h0dHBEb1wiPmh0dHA8L2E+IHJlcXVlc3QuIFdlJ2xsXG4gICAqIHVzZSB0aGUgYGh0dHBEb2Agb3B0aW9ucyBvYmplY3QgdG8gc2VuZCBhIFBPU1QgcmVxdWVzdCB3aXRoIHNvbWVcbiAgICogc3BlY2lmaWMgb3B0aW9uczogd2UgZW5jb2RlIHRoZSByZXF1ZXN0IGFzIGBtdWx0aXBhcnQvZm9ybS1kYXRhYCxcbiAgICogYW5kIGF0dGFjaCB0aGUgYmxvYiBhcyBvbmUgb2YgdGhlIGZvcm0gdmFsdWVzIHVzaW5nIGBGb3JtRGF0YWAuXG4gICAqXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0QmxvYlxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcmV0dXJucyB7QmxvYn0gQSBmaWxlLWxpa2UgZGF0YSBvYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBteVNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvZG9vcmJlbGwubXAzJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbm9DYW52YXMoKTtcbiAgICogICAgbGV0IHNvdW5kQmxvYiA9IG15U291bmQuZ2V0QmxvYigpO1xuICAgKlxuICAgKiAgICAvLyBOb3cgd2UgY2FuIHNlbmQgdGhlIGJsb2IgdG8gYSBzZXJ2ZXIuLi5cbiAgICogICAgbGV0IHNlcnZlclVybCA9ICdodHRwczovL2pzb25wbGFjZWhvbGRlci50eXBpY29kZS5jb20vcG9zdHMnO1xuICAgKiAgICBsZXQgaHR0cFJlcXVlc3RPcHRpb25zID0ge1xuICAgKiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgKiAgICAgIGJvZHk6IG5ldyBGb3JtRGF0YSgpLmFwcGVuZCgnc291bmRCbG9iJywgc291bmRCbG9iKSxcbiAgICogICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh7XG4gICAqICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAqICAgICAgfSlcbiAgICogICAgfTtcbiAgICogICAgaHR0cERvKHNlcnZlclVybCwgaHR0cFJlcXVlc3RPcHRpb25zKTtcbiAgICpcbiAgICogICAgLy8gV2UgY2FuIGFsc28gY3JlYXRlIGFuIGBPYmplY3RVUkxgIHBvaW50aW5nIHRvIHRoZSBCbG9iXG4gICAqICAgIGxldCBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzb3VuZEJsb2IpO1xuICAgKlxuICAgKiAgICAvLyBUaGUgYDxBdWRpbz5gIEVsZW1lbnQgYWNjZXB0cyBPYmplY3QgVVJMJ3NcbiAgICogICAgY3JlYXRlQXVkaW8oYmxvYlVybCkuc2hvd0NvbnRyb2xzKCk7XG4gICAqXG4gICAqICAgIGNyZWF0ZURpdigpO1xuICAgKlxuICAgKiAgICAvLyBUaGUgT2JqZWN0VVJMIGV4aXN0cyBhcyBsb25nIGFzIHRoaXMgdGFiIGlzIG9wZW5cbiAgICogICAgbGV0IGlucHV0ID0gY3JlYXRlSW5wdXQoYmxvYlVybCk7XG4gICAqICAgIGlucHV0LmF0dHJpYnV0ZSgncmVhZG9ubHknLCB0cnVlKTtcbiAgICogICAgaW5wdXQubW91c2VDbGlja2VkKGZ1bmN0aW9uKCkgeyBpbnB1dC5lbHQuc2VsZWN0KCkgfSk7XG4gICAqICB9XG4gICAqXG4gICAqIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmdldEJsb2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gY29udmVydFRvV2F2KHRoaXMuYnVmZmVyKTtcbiAgICByZXR1cm4gbmV3IEJsb2IoW2RhdGFWaWV3XSwge1xuICAgICAgdHlwZTogJ2F1ZGlvL3dhdidcbiAgICB9KTtcbiAgfTsgXG5cblxuICBmdW5jdGlvbiBfY2xlYXJPbkVuZChlKSB7XG4gICAgdmFyIHRoaXNCdWZmZXJTb3VyY2VOb2RlID0gZS50YXJnZXQ7XG4gICAgdmFyIHNvdW5kRmlsZSA9IHRoaXM7IFxuXG4gICAgdGhpc0J1ZmZlclNvdXJjZU5vZGUuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzQnVmZmVyU291cmNlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHNvdW5kRmlsZS5fY2xlYXJPbkVuZCk7IFxuXG4gICAgc291bmRGaWxlLl9vbmVuZGVkKHNvdW5kRmlsZSk7IFxuXG5cbiAgICBzb3VuZEZpbGUuYnVmZmVyU291cmNlTm9kZXMubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9KS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgdmFyIG4gPSBzb3VuZEZpbGUuYnVmZmVyU291cmNlTm9kZXNbaV07XG5cbiAgICAgIGlmIChuLl9wbGF5aW5nID09PSBmYWxzZSkge1xuICAgICAgICBzb3VuZEZpbGUuYnVmZmVyU291cmNlTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNvdW5kRmlsZS5idWZmZXJTb3VyY2VOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNvdW5kRmlsZS5fcGxheWluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgICAgc2FmZUJ1ZmZlclNpemUgPSBfcmVxdWlyZS5zYWZlQnVmZmVyU2l6ZTtcblxuICB2YXIgcHJvY2Vzc29yTmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbiAgLyoqXG4gICAqICBBbXBsaXR1ZGUgbWVhc3VyZXMgdm9sdW1lIGJldHdlZW4gMC4wIGFuZCAxLjAuXG4gICAqICBMaXN0ZW5zIHRvIGFsbCBwNXNvdW5kIGJ5IGRlZmF1bHQsIG9yIHVzZSBzZXRJbnB1dCgpXG4gICAqICB0byBsaXN0ZW4gdG8gYSBzcGVjaWZpYyBzb3VuZCBzb3VyY2UuIEFjY2VwdHMgYW4gb3B0aW9uYWxcbiAgICogIHNtb290aGluZyB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gMC5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5BbXBsaXR1ZGVcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtzbW9vdGhpbmddIGJldHdlZW4gMC4wIGFuZCAuOTk5IHRvIHNtb290aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1wbGl0dWRlIHJlYWRpbmdzIChkZWZhdWx0cyB0byAwKVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgc291bmQsIGFtcGxpdHVkZTtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKXtcbiAgICogICAgc291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Lm1wMycpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLDEwMCk7XG4gICAqICAgIGNudi5tb3VzZUNsaWNrZWQodG9nZ2xlU291bmQpO1xuICAgKiAgICBhbXBsaXR1ZGUgPSBuZXcgcDUuQW1wbGl0dWRlKCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMjAsIDIwKTtcbiAgICpcbiAgICogICAgbGV0IGxldmVsID0gYW1wbGl0dWRlLmdldExldmVsKCk7XG4gICAqICAgIGxldCBzaXplID0gbWFwKGxldmVsLCAwLCAxLCAwLCAyMDApO1xuICAgKiAgICBlbGxpcHNlKHdpZHRoLzIsIGhlaWdodC8yLCBzaXplLCBzaXplKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHRvZ2dsZVNvdW5kKCkge1xuICAgKiAgICBpZiAoc291bmQuaXNQbGF5aW5nKCkgKXtcbiAgICogICAgICBzb3VuZC5zdG9wKCk7XG4gICAqICAgIH0gZWxzZSB7XG4gICAqICAgICAgc291bmQucGxheSgpO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuQW1wbGl0dWRlID0gZnVuY3Rpb24gKHNtb290aGluZykge1xuICAgIHRoaXMuYnVmZmVyU2l6ZSA9IHNhZmVCdWZmZXJTaXplKDIwNDgpOyBcblxuICAgIHRoaXMuYXVkaW9jb250ZXh0ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7XG4gICAgdGhpcy5fd29ya2xldE5vZGUgPSBuZXcgQXVkaW9Xb3JrbGV0Tm9kZSh0aGlzLmF1ZGlvY29udGV4dCwgcHJvY2Vzc29yTmFtZXMuYW1wbGl0dWRlUHJvY2Vzc29yLCB7XG4gICAgICBvdXRwdXRDaGFubmVsQ291bnQ6IFsxXSxcbiAgICAgIHBhcmFtZXRlckRhdGE6IHtcbiAgICAgICAgc21vb3RoaW5nOiBzbW9vdGhpbmcgfHwgMFxuICAgICAgfSxcbiAgICAgIHByb2Nlc3Nvck9wdGlvbnM6IHtcbiAgICAgICAgbm9ybWFsaXplOiBmYWxzZSxcbiAgICAgICAgc21vb3RoaW5nOiBzbW9vdGhpbmcgfHwgMCxcbiAgICAgICAgbnVtSW5wdXRDaGFubmVsczogMixcbiAgICAgICAgYnVmZmVyU2l6ZTogdGhpcy5idWZmZXJTaXplXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl93b3JrbGV0Tm9kZS5wb3J0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRhdGEubmFtZSA9PT0gJ2FtcGxpdHVkZScpIHtcbiAgICAgICAgdGhpcy52b2x1bWUgPSBldmVudC5kYXRhLnZvbHVtZTtcbiAgICAgICAgdGhpcy52b2xOb3JtID0gZXZlbnQuZGF0YS52b2xOb3JtO1xuICAgICAgICB0aGlzLnN0ZXJlb1ZvbCA9IGV2ZW50LmRhdGEuc3RlcmVvVm9sO1xuICAgICAgICB0aGlzLnN0ZXJlb1ZvbE5vcm0gPSBldmVudC5kYXRhLnN0ZXJlb1ZvbE5vcm07XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpOyBcblxuXG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuX3dvcmtsZXROb2RlO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy5hdWRpb2NvbnRleHQuY3JlYXRlR2FpbigpOyBcblxuICAgIHRoaXMudm9sdW1lID0gMDtcbiAgICB0aGlzLnZvbE5vcm0gPSAwO1xuICAgIHRoaXMuc3RlcmVvVm9sID0gWzAsIDBdO1xuICAgIHRoaXMuc3RlcmVvVm9sTm9ybSA9IFswLCAwXTtcbiAgICB0aGlzLm5vcm1hbGl6ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fd29ya2xldE5vZGUuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cbiAgICB0aGlzLm91dHB1dC5nYWluLnZhbHVlID0gMDsgXG5cbiAgICB0aGlzLm91dHB1dC5jb25uZWN0KHRoaXMuYXVkaW9jb250ZXh0LmRlc3RpbmF0aW9uKTsgXG5cbiAgICBwNXNvdW5kLm1ldGVyLmNvbm5lY3QodGhpcy5fd29ya2xldE5vZGUpOyBcblxuICAgIHA1c291bmQuc291bmRBcnJheS5wdXNoKHRoaXMpO1xuICB9O1xuICAvKipcbiAgICogIENvbm5lY3RzIHRvIHRoZSBwNXNvdW5kIGluc3RhbmNlIChtYXN0ZXIgb3V0cHV0KSBieSBkZWZhdWx0LlxuICAgKiAgT3B0aW9uYWxseSwgeW91IGNhbiBwYXNzIGluIGEgc3BlY2lmaWMgc291cmNlIChpLmUuIGEgc291bmRmaWxlKS5cbiAgICpcbiAgICogIEBtZXRob2Qgc2V0SW5wdXRcbiAgICogIEBmb3IgcDUuQW1wbGl0dWRlXG4gICAqICBAcGFyYW0ge3NvdW5kT2JqZWN0fHVuZGVmaW5lZH0gW3NuZF0gc2V0IHRoZSBzb3VuZCBzb3VyY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0aW9uYWwsIGRlZmF1bHRzIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyIG91dHB1dClcbiAgICogIEBwYXJhbSB7TnVtYmVyfHVuZGVmaW5lZH0gW3Ntb290aGluZ10gYSByYW5nZSBiZXR3ZWVuIDAuMCBhbmQgMS4wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHNtb290aCBhbXBsaXR1ZGUgcmVhZGluZ3NcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpe1xuICAgKiAgICBzb3VuZDEgPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Lm1wMycpO1xuICAgKiAgICBzb3VuZDIgPSBsb2FkU291bmQoJ2Fzc2V0cy9kcnVtLm1wMycpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKXtcbiAgICogICAgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlQ2xpY2tlZCh0b2dnbGVTb3VuZCk7XG4gICAqXG4gICAqICAgIGFtcGxpdHVkZSA9IG5ldyBwNS5BbXBsaXR1ZGUoKTtcbiAgICogICAgYW1wbGl0dWRlLnNldElucHV0KHNvdW5kMik7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMjAsIDIwKTtcbiAgICpcbiAgICogICAgbGV0IGxldmVsID0gYW1wbGl0dWRlLmdldExldmVsKCk7XG4gICAqICAgIGxldCBzaXplID0gbWFwKGxldmVsLCAwLCAxLCAwLCAyMDApO1xuICAgKiAgICBlbGxpcHNlKHdpZHRoLzIsIGhlaWdodC8yLCBzaXplLCBzaXplKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHRvZ2dsZVNvdW5kKCl7XG4gICAqICAgIGlmIChzb3VuZDEuaXNQbGF5aW5nKCkgJiYgc291bmQyLmlzUGxheWluZygpKSB7XG4gICAqICAgICAgc291bmQxLnN0b3AoKTtcbiAgICogICAgICBzb3VuZDIuc3RvcCgpO1xuICAgKiAgICB9IGVsc2Uge1xuICAgKiAgICAgIHNvdW5kMS5wbGF5KCk7XG4gICAqICAgICAgc291bmQyLnBsYXkoKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkFtcGxpdHVkZS5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbiAoc291cmNlLCBzbW9vdGhpbmcpIHtcbiAgICBwNXNvdW5kLm1ldGVyLmRpc2Nvbm5lY3QoKTtcblxuICAgIGlmIChzbW9vdGhpbmcpIHtcbiAgICAgIHRoaXMuX3dvcmtsZXROb2RlLnBhcmFtZXRlcnMuZ2V0KCdzbW9vdGhpbmcnKS52YWx1ZSA9IHNtb290aGluZztcbiAgICB9IFxuXG5cbiAgICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBbXBsaXR1ZGUgaW5wdXQgc291cmNlIGlzIG5vdCByZWFkeSEgQ29ubmVjdGluZyB0byBtYXN0ZXIgb3V0cHV0IGluc3RlYWQnKTtcbiAgICAgIHA1c291bmQubWV0ZXIuY29ubmVjdCh0aGlzLl93b3JrbGV0Tm9kZSk7XG4gICAgfSBcbiAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBwNS5TaWduYWwpIHtcbiAgICAgICAgc291cmNlLm91dHB1dC5jb25uZWN0KHRoaXMuX3dvcmtsZXROb2RlKTtcbiAgICAgIH0gXG4gICAgICBlbHNlIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICBzb3VyY2UuY29ubmVjdCh0aGlzLl93b3JrbGV0Tm9kZSk7XG5cbiAgICAgICAgICB0aGlzLl93b3JrbGV0Tm9kZS5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICB0aGlzLl93b3JrbGV0Tm9kZS5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwNXNvdW5kLm1ldGVyLmNvbm5lY3QodGhpcy5fd29ya2xldE5vZGUpO1xuICAgICAgICAgIH1cbiAgfTtcblxuICBwNS5BbXBsaXR1ZGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIGlmICh1bml0KSB7XG4gICAgICBpZiAodW5pdC5oYXNPd25Qcm9wZXJ0eSgnaW5wdXQnKSkge1xuICAgICAgICB0aGlzLm91dHB1dC5jb25uZWN0KHVuaXQuaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdCh1bml0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdCh0aGlzLnBhbm5lci5jb25uZWN0KHA1c291bmQuaW5wdXQpKTtcbiAgICB9XG4gIH07XG5cbiAgcDUuQW1wbGl0dWRlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm5zIGEgc2luZ2xlIEFtcGxpdHVkZSByZWFkaW5nIGF0IHRoZSBtb21lbnQgaXQgaXMgY2FsbGVkLlxuICAgKiAgRm9yIGNvbnRpbnVvdXMgcmVhZGluZ3MsIHJ1biBpbiB0aGUgZHJhdyBsb29wLlxuICAgKlxuICAgKiAgQG1ldGhvZCBnZXRMZXZlbFxuICAgKiAgQGZvciBwNS5BbXBsaXR1ZGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbY2hhbm5lbF0gT3B0aW9uYWxseSByZXR1cm4gb25seSBjaGFubmVsIDAgKGxlZnQpIG9yIDEgKHJpZ2h0KVxuICAgKiAgQHJldHVybiB7TnVtYmVyfSAgICAgICBBbXBsaXR1ZGUgYXMgYSBudW1iZXIgYmV0d2VlbiAwLjAgYW5kIDEuMFxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCl7XG4gICAqICAgIHNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvYmVhdC5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlQ2xpY2tlZCh0b2dnbGVTb3VuZCk7XG4gICAqICAgIGFtcGxpdHVkZSA9IG5ldyBwNS5BbXBsaXR1ZGUoKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwLCAxNTApO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCB3aWR0aC8yLCAyMCk7XG4gICAqXG4gICAqICAgIGxldCBsZXZlbCA9IGFtcGxpdHVkZS5nZXRMZXZlbCgpO1xuICAgKiAgICBsZXQgc2l6ZSA9IG1hcChsZXZlbCwgMCwgMSwgMCwgMjAwKTtcbiAgICogICAgZWxsaXBzZSh3aWR0aC8yLCBoZWlnaHQvMiwgc2l6ZSwgc2l6ZSk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiB0b2dnbGVTb3VuZCgpe1xuICAgKiAgICBpZiAoc291bmQuaXNQbGF5aW5nKCkpIHtcbiAgICogICAgICBzb3VuZC5zdG9wKCk7XG4gICAqICAgIH0gZWxzZSB7XG4gICAqICAgICAgc291bmQucGxheSgpO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuQW1wbGl0dWRlLnByb3RvdHlwZS5nZXRMZXZlbCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgaWYgKHR5cGVvZiBjaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHRoaXMubm9ybWFsaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXJlb1ZvbE5vcm1bY2hhbm5lbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVyZW9Wb2xbY2hhbm5lbF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vcm1hbGl6ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudm9sTm9ybTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudm9sdW1lO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcmVzdWx0cyBvZiBBbXBsaXR1ZGUucHJvY2VzcygpIHdpbGwgYmVcbiAgICogTm9ybWFsaXplZC4gVG8gbm9ybWFsaXplLCBBbXBsaXR1ZGUgZmluZHMgdGhlIGRpZmZlcmVuY2UgdGhlXG4gICAqIGxvdWRlc3QgcmVhZGluZyBpdCBoYXMgcHJvY2Vzc2VkIGFuZCB0aGUgbWF4aW11bSBhbXBsaXR1ZGUgb2ZcbiAgICogMS4wLiBBbXBsaXR1ZGUgYWRkcyB0aGlzIGRpZmZlcmVuY2UgdG8gYWxsIHZhbHVlcyB0byBwcm9kdWNlXG4gICAqIHJlc3VsdHMgdGhhdCB3aWxsIHJlbGlhYmx5IG1hcCBiZXR3ZWVuIDAuMCBhbmQgMS4wLiBIb3dldmVyLFxuICAgKiBpZiBhIGxvdWRlciBtb21lbnQgb2NjdXJzLCB0aGUgYW1vdW50IHRoYXQgTm9ybWFsaXplIGFkZHMgdG9cbiAgICogYWxsIHRoZSB2YWx1ZXMgd2lsbCBjaGFuZ2UuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYm9vbGVhbiBwYXJhbWV0ZXJcbiAgICogKHRydWUgb3IgZmFsc2UpLiBOb3JtYWxpemluZyBpcyBvZmYgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQG1ldGhvZCB0b2dnbGVOb3JtYWxpemVcbiAgICogQGZvciBwNS5BbXBsaXR1ZGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbGVhbl0gc2V0IG5vcm1hbGl6ZSB0byB0cnVlICgxKSBvciBmYWxzZSAoMClcbiAgICovXG5cblxuICBwNS5BbXBsaXR1ZGUucHJvdG90eXBlLnRvZ2dsZU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgaWYgKHR5cGVvZiBib29sID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMubm9ybWFsaXplID0gYm9vbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3JtYWxpemUgPSAhdGhpcy5ub3JtYWxpemU7XG4gICAgfVxuXG4gICAgdGhpcy5fd29ya2xldE5vZGUucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICBuYW1lOiAndG9nZ2xlTm9ybWFsaXplJyxcbiAgICAgIG5vcm1hbGl6ZTogdGhpcy5ub3JtYWxpemVcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqICBTbW9vdGggQW1wbGl0dWRlIGFuYWx5c2lzIGJ5IGF2ZXJhZ2luZyB3aXRoIHRoZSBsYXN0IGFuYWx5c2lzXG4gICAqICBmcmFtZS4gT2ZmIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqICBAbWV0aG9kIHNtb290aFxuICAgKiAgQGZvciBwNS5BbXBsaXR1ZGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBzZXQgc21vb3RoaW5nIGZyb20gMC4wIDw9IDFcbiAgICovXG5cblxuICBwNS5BbXBsaXR1ZGUucHJvdG90eXBlLnNtb290aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMgPj0gMCAmJiBzIDwgMSkge1xuICAgICAgdGhpcy5fd29ya2xldE5vZGUucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIG5hbWU6ICdzbW9vdGhpbmcnLFxuICAgICAgICBzbW9vdGhpbmc6IHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnRXJyb3I6IHNtb290aGluZyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMScpO1xuICAgIH1cbiAgfTtcblxuICBwNS5BbXBsaXR1ZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gcDVzb3VuZC5zb3VuZEFycmF5LmluZGV4T2YodGhpcyk7XG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBpZiAodGhpcy5pbnB1dCkge1xuICAgICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5pbnB1dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm91dHB1dDtcbiAgICB9XG5cbiAgICB0aGlzLl93b3JrbGV0Tm9kZS5kaXNjb25uZWN0KCk7XG5cbiAgICBkZWxldGUgdGhpcy5fd29ya2xldE5vZGU7XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICAvKipcbiAgICogIDxwPkZGVCAoRmFzdCBGb3VyaWVyIFRyYW5zZm9ybSkgaXMgYW4gYW5hbHlzaXMgYWxnb3JpdGhtIHRoYXRcbiAgICogIGlzb2xhdGVzIGluZGl2aWR1YWxcbiAgICogIDxhIGhyZWY9XCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BdWRpb19mcmVxdWVuY3lcIj5cbiAgICogIGF1ZGlvIGZyZXF1ZW5jaWVzPC9hPiB3aXRoaW4gYSB3YXZlZm9ybS48L3A+XG4gICAqXG4gICAqICA8cD5PbmNlIGluc3RhbnRpYXRlZCwgYSBwNS5GRlQgb2JqZWN0IGNhbiByZXR1cm4gYW4gYXJyYXkgYmFzZWQgb25cbiAgICogIHR3byB0eXBlcyBvZiBhbmFseXNlczogPGJyPiDigKIgPGNvZGU+RkZULndhdmVmb3JtKCk8L2NvZGU+IGNvbXB1dGVzXG4gICAqICBhbXBsaXR1ZGUgdmFsdWVzIGFsb25nIHRoZSB0aW1lIGRvbWFpbi4gVGhlIGFycmF5IGluZGljZXMgY29ycmVzcG9uZFxuICAgKiAgdG8gc2FtcGxlcyBhY3Jvc3MgYSBicmllZiBtb21lbnQgaW4gdGltZS4gRWFjaCB2YWx1ZSByZXByZXNlbnRzXG4gICAqICBhbXBsaXR1ZGUgb2YgdGhlIHdhdmVmb3JtIGF0IHRoYXQgc2FtcGxlIG9mIHRpbWUuPGJyPlxuICAgKiAg4oCiIDxjb2RlPkZGVC5hbmFseXplKCkgPC9jb2RlPiBjb21wdXRlcyBhbXBsaXR1ZGUgdmFsdWVzIGFsb25nIHRoZVxuICAgKiAgZnJlcXVlbmN5IGRvbWFpbi4gVGhlIGFycmF5IGluZGljZXMgY29ycmVzcG9uZCB0byBmcmVxdWVuY2llcyAoaS5lLlxuICAgKiAgcGl0Y2hlcyksIGZyb20gdGhlIGxvd2VzdCB0byB0aGUgaGlnaGVzdCB0aGF0IGh1bWFucyBjYW4gaGVhci4gRWFjaFxuICAgKiAgdmFsdWUgcmVwcmVzZW50cyBhbXBsaXR1ZGUgYXQgdGhhdCBzbGljZSBvZiB0aGUgZnJlcXVlbmN5IHNwZWN0cnVtLlxuICAgKiAgVXNlIHdpdGggPGNvZGU+Z2V0RW5lcmd5KCk8L2NvZGU+IHRvIG1lYXN1cmUgYW1wbGl0dWRlIGF0IHNwZWNpZmljXG4gICAqICBmcmVxdWVuY2llcywgb3Igd2l0aGluIGEgcmFuZ2Ugb2YgZnJlcXVlbmNpZXMuIDwvcD5cbiAgICpcbiAgICogIDxwPkZGVCBhbmFseXplcyBhIHZlcnkgc2hvcnQgc25hcHNob3Qgb2Ygc291bmQgY2FsbGVkIGEgc2FtcGxlXG4gICAqICBidWZmZXIuIEl0IHJldHVybnMgYW4gYXJyYXkgb2YgYW1wbGl0dWRlIG1lYXN1cmVtZW50cywgcmVmZXJyZWRcbiAgICogIHRvIGFzIDxjb2RlPmJpbnM8L2NvZGU+LiBUaGUgYXJyYXkgaXMgMTAyNCBiaW5zIGxvbmcgYnkgZGVmYXVsdC5cbiAgICogIFlvdSBjYW4gY2hhbmdlIHRoZSBiaW4gYXJyYXkgbGVuZ3RoLCBidXQgaXQgbXVzdCBiZSBhIHBvd2VyIG9mIDJcbiAgICogIGJldHdlZW4gMTYgYW5kIDEwMjQgaW4gb3JkZXIgZm9yIHRoZSBGRlQgYWxnb3JpdGhtIHRvIGZ1bmN0aW9uXG4gICAqICBjb3JyZWN0bHkuIFRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgRkZUIGJ1ZmZlciBpcyB0d2ljZSB0aGVcbiAgICogIG51bWJlciBvZiBiaW5zLCBzbyBnaXZlbiBhIHN0YW5kYXJkIHNhbXBsZSByYXRlLCB0aGUgYnVmZmVyIGlzXG4gICAqICAyMDQ4LzQ0MTAwIHNlY29uZHMgbG9uZy48L3A+XG4gICAqXG4gICAqXG4gICAqICBAY2xhc3MgcDUuRkZUXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbc21vb3RoaW5nXSAgIFNtb290aCByZXN1bHRzIG9mIEZyZXEgU3BlY3RydW0uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAgPCBzbW9vdGhpbmcgPCAxLjAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byAwLjguXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2JpbnNdICAgIExlbmd0aCBvZiByZXN1bHRpbmcgYXJyYXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIE11c3QgYmUgYSBwb3dlciBvZiB0d28gYmV0d2VlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNiBhbmQgMTAyNC4gRGVmYXVsdHMgdG8gMTAyNC5cbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpe1xuICAgKiAgICBzb3VuZCA9IGxvYWRTb3VuZCgnYXNzZXRzL0RhbXNjcmF5X0RhbmNpbmdUaWdlci5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCl7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLDEwMCk7XG4gICAqICAgIGNudi5tb3VzZUNsaWNrZWQodG9nZ2xlUGxheSk7XG4gICAqICAgIGZmdCA9IG5ldyBwNS5GRlQoKTtcbiAgICogICAgc291bmQuYW1wKDAuMik7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCl7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICpcbiAgICogICAgbGV0IHNwZWN0cnVtID0gZmZ0LmFuYWx5emUoKTtcbiAgICogICAgbm9TdHJva2UoKTtcbiAgICogICAgZmlsbCgyNTUsIDAsIDI1NSk7XG4gICAqICAgIGZvciAobGV0IGkgPSAwOyBpPCBzcGVjdHJ1bS5sZW5ndGg7IGkrKyl7XG4gICAqICAgICAgbGV0IHggPSBtYXAoaSwgMCwgc3BlY3RydW0ubGVuZ3RoLCAwLCB3aWR0aCk7XG4gICAqICAgICAgbGV0IGggPSAtaGVpZ2h0ICsgbWFwKHNwZWN0cnVtW2ldLCAwLCAyNTUsIGhlaWdodCwgMCk7XG4gICAqICAgICAgcmVjdCh4LCBoZWlnaHQsIHdpZHRoIC8gc3BlY3RydW0ubGVuZ3RoLCBoIClcbiAgICogICAgfVxuICAgKlxuICAgKiAgICBsZXQgd2F2ZWZvcm0gPSBmZnQud2F2ZWZvcm0oKTtcbiAgICogICAgbm9GaWxsKCk7XG4gICAqICAgIGJlZ2luU2hhcGUoKTtcbiAgICogICAgc3Ryb2tlKDIwKTtcbiAgICogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3YXZlZm9ybS5sZW5ndGg7IGkrKyl7XG4gICAqICAgICAgbGV0IHggPSBtYXAoaSwgMCwgd2F2ZWZvcm0ubGVuZ3RoLCAwLCB3aWR0aCk7XG4gICAqICAgICAgbGV0IHkgPSBtYXAoIHdhdmVmb3JtW2ldLCAtMSwgMSwgMCwgaGVpZ2h0KTtcbiAgICogICAgICB2ZXJ0ZXgoeCx5KTtcbiAgICogICAgfVxuICAgKiAgICBlbmRTaGFwZSgpO1xuICAgKlxuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiB0b2dnbGVQbGF5KCkge1xuICAgKiAgICBpZiAoc291bmQuaXNQbGF5aW5nKCkpIHtcbiAgICogICAgICBzb3VuZC5wYXVzZSgpO1xuICAgKiAgICB9IGVsc2Uge1xuICAgKiAgICAgIHNvdW5kLmxvb3AoKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkZGVCA9IGZ1bmN0aW9uIChzbW9vdGhpbmcsIGJpbnMpIHtcbiAgICB0aGlzLmlucHV0ID0gdGhpcy5hbmFseXNlciA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgYmluczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXNlci5mZnRTaXplIC8gMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYikge1xuICAgICAgICAgIHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGIgKiAyO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBzbW9vdGhpbmc6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzKSB7XG4gICAgICAgICAgdGhpcy5hbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSBzO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgXG5cbiAgICB0aGlzLnNtb290aChzbW9vdGhpbmcpO1xuICAgIHRoaXMuYmlucyA9IGJpbnMgfHwgMTAyNDsgXG5cbiAgICBwNXNvdW5kLmZmdE1ldGVyLmNvbm5lY3QodGhpcy5hbmFseXNlcik7XG4gICAgdGhpcy5mcmVxRG9tYWluID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gICAgdGhpcy50aW1lRG9tYWluID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7IFxuXG4gICAgdGhpcy5iYXNzID0gWzIwLCAxNDBdO1xuICAgIHRoaXMubG93TWlkID0gWzE0MCwgNDAwXTtcbiAgICB0aGlzLm1pZCA9IFs0MDAsIDI2MDBdO1xuICAgIHRoaXMuaGlnaE1pZCA9IFsyNjAwLCA1MjAwXTtcbiAgICB0aGlzLnRyZWJsZSA9IFs1MjAwLCAxNDAwMF07IFxuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBpbnB1dCBzb3VyY2UgZm9yIHRoZSBGRlQgYW5hbHlzaXMuIElmIG5vIHNvdXJjZSBpc1xuICAgKiAgcHJvdmlkZWQsIEZGVCB3aWxsIGFuYWx5emUgYWxsIHNvdW5kIGluIHRoZSBza2V0Y2guXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRJbnB1dFxuICAgKiAgQGZvciBwNS5GRlRcbiAgICogIEBwYXJhbSB7T2JqZWN0fSBbc291cmNlXSBwNS5zb3VuZCBvYmplY3QgKG9yIHdlYiBhdWRpbyBBUEkgc291cmNlIG5vZGUpXG4gICAqL1xuXG5cbiAgcDUuRkZULnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcDVzb3VuZC5mZnRNZXRlci5jb25uZWN0KHRoaXMuYW5hbHlzZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc291cmNlLm91dHB1dCkge1xuICAgICAgICBzb3VyY2Uub3V0cHV0LmNvbm5lY3QodGhpcy5hbmFseXNlcik7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZS5jb25uZWN0KSB7XG4gICAgICAgIHNvdXJjZS5jb25uZWN0KHRoaXMuYW5hbHlzZXIpO1xuICAgICAgfVxuXG4gICAgICBwNXNvdW5kLmZmdE1ldGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBhcnJheSBvZiBhbXBsaXR1ZGUgdmFsdWVzIChiZXR3ZWVuIC0xLjAgYW5kICsxLjApIHRoYXQgcmVwcmVzZW50XG4gICAqICBhIHNuYXBzaG90IG9mIGFtcGxpdHVkZSByZWFkaW5ncyBpbiBhIHNpbmdsZSBidWZmZXIuIExlbmd0aCB3aWxsIGJlXG4gICAqICBlcXVhbCB0byBiaW5zIChkZWZhdWx0cyB0byAxMDI0KS4gQ2FuIGJlIHVzZWQgdG8gZHJhdyB0aGUgd2F2ZWZvcm1cbiAgICogIG9mIGEgc291bmQuXG4gICAqXG4gICAqICBAbWV0aG9kIHdhdmVmb3JtXG4gICAqICBAZm9yIHA1LkZGVFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtiaW5zXSAgICBNdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGJldHdlZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgMTYgYW5kIDEwMjQuIERlZmF1bHRzIHRvIDEwMjQuXG4gICAqICBAcGFyYW0ge1N0cmluZ30gW3ByZWNpc2lvbl0gSWYgYW55IHZhbHVlIGlzIHByb3ZpZGVkLCB3aWxsIHJldHVybiByZXN1bHRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gYSBGbG9hdDMyIEFycmF5IHdoaWNoIGlzIG1vcmUgcHJlY2lzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYW4gYSByZWd1bGFyIGFycmF5LlxuICAgKiAgQHJldHVybiB7QXJyYXl9ICBBcnJheSAgICBBcnJheSBvZiBhbXBsaXR1ZGUgdmFsdWVzICgtMSB0byAxKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyIHRpbWUuIEFycmF5IGxlbmd0aCA9IGJpbnMuXG4gICAqXG4gICAqL1xuXG5cbiAgcDUuRkZULnByb3RvdHlwZS53YXZlZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmlucywgbW9kZSwgbm9ybWFsQXJyYXk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJpbnMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGJpbnMgKiAyO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbW9kZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICB9IFxuXG5cbiAgICBpZiAobW9kZSAmJiAhcDUucHJvdG90eXBlLl9pc1NhZmFyaSgpKSB7XG4gICAgICB0aW1lVG9GbG9hdCh0aGlzLCB0aGlzLnRpbWVEb21haW4pO1xuICAgICAgdGhpcy5hbmFseXNlci5nZXRGbG9hdFRpbWVEb21haW5EYXRhKHRoaXMudGltZURvbWFpbik7XG4gICAgICByZXR1cm4gdGhpcy50aW1lRG9tYWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lVG9JbnQodGhpcywgdGhpcy50aW1lRG9tYWluKTtcbiAgICAgIHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKHRoaXMudGltZURvbWFpbik7XG4gICAgICB2YXIgbm9ybWFsQXJyYXkgPSBuZXcgQXJyYXkoKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnRpbWVEb21haW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IHA1LnByb3RvdHlwZS5tYXAodGhpcy50aW1lRG9tYWluW2pdLCAwLCAyNTUsIC0xLCAxKTtcbiAgICAgICAgbm9ybWFsQXJyYXkucHVzaChzY2FsZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9ybWFsQXJyYXk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgYW4gYXJyYXkgb2YgYW1wbGl0dWRlIHZhbHVlcyAoYmV0d2VlbiAwIGFuZCAyNTUpXG4gICAqICBhY3Jvc3MgdGhlIGZyZXF1ZW5jeSBzcGVjdHJ1bS4gTGVuZ3RoIGlzIGVxdWFsIHRvIEZGVCBiaW5zXG4gICAqICAoMTAyNCBieSBkZWZhdWx0KS4gVGhlIGFycmF5IGluZGljZXMgY29ycmVzcG9uZCB0byBmcmVxdWVuY2llc1xuICAgKiAgKGkuZS4gcGl0Y2hlcyksIGZyb20gdGhlIGxvd2VzdCB0byB0aGUgaGlnaGVzdCB0aGF0IGh1bWFucyBjYW5cbiAgICogIGhlYXIuIEVhY2ggdmFsdWUgcmVwcmVzZW50cyBhbXBsaXR1ZGUgYXQgdGhhdCBzbGljZSBvZiB0aGVcbiAgICogIGZyZXF1ZW5jeSBzcGVjdHJ1bS4gTXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gdXNpbmdcbiAgICogIDxjb2RlPmdldEVuZXJneSgpPC9jb2RlPi5cbiAgICpcbiAgICogIEBtZXRob2QgYW5hbHl6ZVxuICAgKiAgQGZvciBwNS5GRlRcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbYmluc10gICAgTXVzdCBiZSBhIHBvd2VyIG9mIHR3byBiZXR3ZWVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNiBhbmQgMTAyNC4gRGVmYXVsdHMgdG8gMTAyNC5cbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdICAgIElmIFwiZEIsXCIgcmV0dXJucyBkZWNpYmVsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBtZWFzdXJlbWVudHMgYmV0d2VlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTE0MCBhbmQgMCAobWF4KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSByZXR1cm5zIGludGVnZXJzIGZyb20gMC0yNTUuXG4gICAqICBAcmV0dXJuIHtBcnJheX0gc3BlY3RydW0gICAgQXJyYXkgb2YgZW5lcmd5IChhbXBsaXR1ZGUvdm9sdW1lKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhY3Jvc3MgdGhlIGZyZXF1ZW5jeSBzcGVjdHJ1bS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb3dlc3QgZW5lcmd5IChzaWxlbmNlKSA9IDAsIGhpZ2hlc3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZSBpcyAyNTUuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBvc2MsIGZmdDtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCl7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoc3RhcnRTb3VuZCk7XG4gICAqICAgIG9zYyA9IG5ldyBwNS5Pc2NpbGxhdG9yKCk7XG4gICAqICAgIG9zYy5hbXAoMCk7XG4gICAqICAgIGZmdCA9IG5ldyBwNS5GRlQoKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKXtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKlxuICAgKiAgICBsZXQgZnJlcSA9IG1hcChtb3VzZVgsIDAsIHdpbmRvd1dpZHRoLCAyMCwgMTAwMDApO1xuICAgKiAgICBmcmVxID0gY29uc3RyYWluKGZyZXEsIDEsIDIwMDAwKTtcbiAgICogICAgb3NjLmZyZXEoZnJlcSk7XG4gICAqXG4gICAqICAgIGxldCBzcGVjdHJ1bSA9IGZmdC5hbmFseXplKCk7XG4gICAqICAgIG5vU3Ryb2tlKCk7XG4gICAqICAgIGZpbGwoMjU1LCAwLCAyNTUpO1xuICAgKiAgICBmb3IgKGxldCBpID0gMDsgaTwgc3BlY3RydW0ubGVuZ3RoOyBpKyspe1xuICAgKiAgICAgIGxldCB4ID0gbWFwKGksIDAsIHNwZWN0cnVtLmxlbmd0aCwgMCwgd2lkdGgpO1xuICAgKiAgICAgIGxldCBoID0gLWhlaWdodCArIG1hcChzcGVjdHJ1bVtpXSwgMCwgMjU1LCBoZWlnaHQsIDApO1xuICAgKiAgICAgIHJlY3QoeCwgaGVpZ2h0LCB3aWR0aCAvIHNwZWN0cnVtLmxlbmd0aCwgaCApO1xuICAgKiAgICB9XG4gICAqXG4gICAqICAgIHN0cm9rZSgyNTUpO1xuICAgKiAgICBpZiAoIW9zYy5zdGFydGVkKSB7XG4gICAqICAgICAgdGV4dCgndGFwIGhlcmUgYW5kIGRyYWcgdG8gY2hhbmdlIGZyZXF1ZW5jeScsIDEwLCAyMCwgd2lkdGggLSAyMCk7XG4gICAqICAgIH0gZWxzZSB7XG4gICAqICAgICAgdGV4dChyb3VuZChmcmVxKSsnSHonLCAxMCwgMjApO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzdGFydFNvdW5kKCkge1xuICAgKiAgICBvc2Muc3RhcnQoKTtcbiAgICogICAgb3NjLmFtcCgwLjUsIDAuMik7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICBvc2MuYW1wKDAsIDAuMik7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqXG4gICAqXG4gICAqL1xuXG5cbiAgcDUuRkZULnByb3RvdHlwZS5hbmFseXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmJpbnMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IHRoaXMuYmlucyAqIDI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICBtb2RlID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RlICYmIG1vZGUudG9Mb3dlckNhc2UoKSA9PT0gJ2RiJykge1xuICAgICAgZnJlcVRvRmxvYXQodGhpcyk7XG4gICAgICB0aGlzLmFuYWx5c2VyLmdldEZsb2F0RnJlcXVlbmN5RGF0YSh0aGlzLmZyZXFEb21haW4pO1xuICAgICAgcmV0dXJuIHRoaXMuZnJlcURvbWFpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJlcVRvSW50KHRoaXMsIHRoaXMuZnJlcURvbWFpbik7XG4gICAgICB0aGlzLmFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKHRoaXMuZnJlcURvbWFpbik7XG4gICAgICB2YXIgbm9ybWFsQXJyYXkgPSBBcnJheS5hcHBseShbXSwgdGhpcy5mcmVxRG9tYWluKTtcbiAgICAgIHJldHVybiBub3JtYWxBcnJheTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyB0aGUgYW1vdW50IG9mIGVuZXJneSAodm9sdW1lKSBhdCBhIHNwZWNpZmljXG4gICAqICA8YSBocmVmPVwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXVkaW9fZnJlcXVlbmN5XCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAqICBmcmVxdWVuY3k8L2E+LCBvciB0aGUgYXZlcmFnZSBhbW91bnQgb2YgZW5lcmd5IGJldHdlZW4gdHdvXG4gICAqICBmcmVxdWVuY2llcy4gQWNjZXB0cyBOdW1iZXIocykgY29ycmVzcG9uZGluZ1xuICAgKiAgdG8gZnJlcXVlbmN5IChpbiBIeiksIG9yIGEgU3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gcHJlZGVmaW5lZFxuICAgKiAgZnJlcXVlbmN5IHJhbmdlcyAoXCJiYXNzXCIsIFwibG93TWlkXCIsIFwibWlkXCIsIFwiaGlnaE1pZFwiLCBcInRyZWJsZVwiKS5cbiAgICogIFJldHVybnMgYSByYW5nZSBiZXR3ZWVuIDAgKG5vIGVuZXJneS92b2x1bWUgYXQgdGhhdCBmcmVxdWVuY3kpIGFuZFxuICAgKiAgMjU1IChtYXhpbXVtIGVuZXJneSkuXG4gICAqICA8ZW0+Tk9URTogYW5hbHl6ZSgpIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvIGdldEVuZXJneSgpLiBBbmFseXplKClcbiAgICogIHRlbGxzIHRoZSBGRlQgdG8gYW5hbHl6ZSBmcmVxdWVuY3kgZGF0YSwgYW5kIGdldEVuZXJneSgpIHVzZXNcbiAgICogIHRoZSByZXN1bHRzIGRldGVybWluZSB0aGUgdmFsdWUgYXQgYSBzcGVjaWZpYyBmcmVxdWVuY3kgb3JcbiAgICogIHJhbmdlIG9mIGZyZXF1ZW5jaWVzLjwvZW0+PC9wPlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZ2V0RW5lcmd5XG4gICAqICBAZm9yIHA1LkZGVFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gZnJlcXVlbmN5MSAgIFdpbGwgcmV0dXJuIGEgdmFsdWUgcmVwcmVzZW50aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmVyZ3kgYXQgdGhpcyBmcmVxdWVuY3kuIEFsdGVybmF0ZWx5LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHN0cmluZ3MgXCJiYXNzXCIsIFwibG93TWlkXCIgXCJtaWRcIixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGlnaE1pZFwiLCBhbmQgXCJ0cmVibGVcIiB3aWxsIHJldHVyblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZGVmaW5lZCBmcmVxdWVuY3kgcmFuZ2VzLlxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbZnJlcXVlbmN5Ml0gSWYgYSBzZWNvbmQgZnJlcXVlbmN5IGlzIGdpdmVuLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCByZXR1cm4gYXZlcmFnZSBhbW91bnQgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZXJneSB0aGF0IGV4aXN0cyBiZXR3ZWVuIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdvIGZyZXF1ZW5jaWVzLlxuICAgKiAgQHJldHVybiB7TnVtYmVyfSAgIEVuZXJneSAgIEVuZXJneSAodm9sdW1lL2FtcGxpdHVkZSkgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgYW5kIDI1NS5cbiAgICpcbiAgICovXG5cblxuICBwNS5GRlQucHJvdG90eXBlLmdldEVuZXJneSA9IGZ1bmN0aW9uIChmcmVxdWVuY3kxLCBmcmVxdWVuY3kyKSB7XG4gICAgdmFyIG55cXVpc3QgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlIC8gMjtcblxuICAgIGlmIChmcmVxdWVuY3kxID09PSAnYmFzcycpIHtcbiAgICAgIGZyZXF1ZW5jeTEgPSB0aGlzLmJhc3NbMF07XG4gICAgICBmcmVxdWVuY3kyID0gdGhpcy5iYXNzWzFdO1xuICAgIH0gZWxzZSBpZiAoZnJlcXVlbmN5MSA9PT0gJ2xvd01pZCcpIHtcbiAgICAgIGZyZXF1ZW5jeTEgPSB0aGlzLmxvd01pZFswXTtcbiAgICAgIGZyZXF1ZW5jeTIgPSB0aGlzLmxvd01pZFsxXTtcbiAgICB9IGVsc2UgaWYgKGZyZXF1ZW5jeTEgPT09ICdtaWQnKSB7XG4gICAgICBmcmVxdWVuY3kxID0gdGhpcy5taWRbMF07XG4gICAgICBmcmVxdWVuY3kyID0gdGhpcy5taWRbMV07XG4gICAgfSBlbHNlIGlmIChmcmVxdWVuY3kxID09PSAnaGlnaE1pZCcpIHtcbiAgICAgIGZyZXF1ZW5jeTEgPSB0aGlzLmhpZ2hNaWRbMF07XG4gICAgICBmcmVxdWVuY3kyID0gdGhpcy5oaWdoTWlkWzFdO1xuICAgIH0gZWxzZSBpZiAoZnJlcXVlbmN5MSA9PT0gJ3RyZWJsZScpIHtcbiAgICAgIGZyZXF1ZW5jeTEgPSB0aGlzLnRyZWJsZVswXTtcbiAgICAgIGZyZXF1ZW5jeTIgPSB0aGlzLnRyZWJsZVsxXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeTEgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyAnaW52YWxpZCBpbnB1dCBmb3IgZ2V0RW5lcmd5KCknO1xuICAgIH0gZWxzZSBpZiAoIWZyZXF1ZW5jeTIpIHtcbiAgICAgIHZhciBpbmRleCA9IE1hdGgucm91bmQoZnJlcXVlbmN5MSAvIG55cXVpc3QgKiB0aGlzLmZyZXFEb21haW4ubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLmZyZXFEb21haW5baW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoZnJlcXVlbmN5MSAmJiBmcmVxdWVuY3kyKSB7XG4gICAgICBpZiAoZnJlcXVlbmN5MSA+IGZyZXF1ZW5jeTIpIHtcbiAgICAgICAgdmFyIHN3YXAgPSBmcmVxdWVuY3kyO1xuICAgICAgICBmcmVxdWVuY3kyID0gZnJlcXVlbmN5MTtcbiAgICAgICAgZnJlcXVlbmN5MSA9IHN3YXA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb3dJbmRleCA9IE1hdGgucm91bmQoZnJlcXVlbmN5MSAvIG55cXVpc3QgKiB0aGlzLmZyZXFEb21haW4ubGVuZ3RoKTtcbiAgICAgIHZhciBoaWdoSW5kZXggPSBNYXRoLnJvdW5kKGZyZXF1ZW5jeTIgLyBueXF1aXN0ICogdGhpcy5mcmVxRG9tYWluLmxlbmd0aCk7XG4gICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgdmFyIG51bUZyZXF1ZW5jaWVzID0gMDsgXG5cbiAgICAgIGZvciAodmFyIGkgPSBsb3dJbmRleDsgaSA8PSBoaWdoSW5kZXg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSB0aGlzLmZyZXFEb21haW5baV07XG4gICAgICAgIG51bUZyZXF1ZW5jaWVzICs9IDE7XG4gICAgICB9IFxuXG5cbiAgICAgIHZhciB0b1JldHVybiA9IHRvdGFsIC8gbnVtRnJlcXVlbmNpZXM7XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdpbnZhbGlkIGlucHV0IGZvciBnZXRFbmVyZ3koKSc7XG4gICAgfVxuICB9OyBcblxuXG4gIHA1LkZGVC5wcm90b3R5cGUuZ2V0RnJlcSA9IGZ1bmN0aW9uIChmcmVxMSwgZnJlcTIpIHtcbiAgICBjb25zb2xlLmxvZygnZ2V0RnJlcSgpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgZ2V0RW5lcmd5KCkgaW5zdGVhZC4nKTtcbiAgICB2YXIgeCA9IHRoaXMuZ2V0RW5lcmd5KGZyZXExLCBmcmVxMik7XG4gICAgcmV0dXJuIHg7XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyB0aGVcbiAgICogIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwZWN0cmFsX2NlbnRyb2lkXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAqICBzcGVjdHJhbCBjZW50cm9pZDwvYT4gb2YgdGhlIGlucHV0IHNpZ25hbC5cbiAgICogIDxlbT5OT1RFOiBhbmFseXplKCkgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gZ2V0Q2VudHJvaWQoKS4gQW5hbHl6ZSgpXG4gICAqICB0ZWxscyB0aGUgRkZUIHRvIGFuYWx5emUgZnJlcXVlbmN5IGRhdGEsIGFuZCBnZXRDZW50cm9pZCgpIHVzZXNcbiAgICogIHRoZSByZXN1bHRzIGRldGVybWluZSB0aGUgc3BlY3RyYWwgY2VudHJvaWQuPC9lbT48L3A+XG4gICAqXG4gICAqICBAbWV0aG9kICBnZXRDZW50cm9pZFxuICAgKiAgQGZvciBwNS5GRlRcbiAgICogIEByZXR1cm4ge051bWJlcn0gICBTcGVjdHJhbCBDZW50cm9pZCBGcmVxdWVuY3kgICBGcmVxdWVuY3kgb2YgdGhlIHNwZWN0cmFsIGNlbnRyb2lkIGluIEh6LlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogZnVuY3Rpb24gc2V0dXAoKXtcbiAgICogIGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsMTAwKTtcbiAgICogIGNudi5tb3VzZVByZXNzZWQodXNlclN0YXJ0QXVkaW8pO1xuICAgKiAgc291bmQgPSBuZXcgcDUuQXVkaW9JbigpO1xuICAgKiAgc291bmQuc3RhcnQoKTtcbiAgICogIGZmdCA9IG5ldyBwNS5GRlQoKTtcbiAgICogIHNvdW5kLmNvbm5lY3QoZmZ0KTtcbiAgICp9XG4gICAqXG4gICAqZnVuY3Rpb24gZHJhdygpIHtcbiAgICogIGlmIChnZXRBdWRpb0NvbnRleHQoKS5zdGF0ZSAhPT0gJ3J1bm5pbmcnKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIGhlcmUgYW5kIGVuYWJsZSBtaWMgdG8gYmVnaW4nLCAxMCwgMjAsIHdpZHRoIC0gMjApO1xuICAgKiAgICByZXR1cm47XG4gICAqICB9XG4gICAqICBsZXQgY2VudHJvaWRwbG90ID0gMC4wO1xuICAgKiAgbGV0IHNwZWN0cmFsQ2VudHJvaWQgPSAwO1xuICAgKlxuICAgKiAgYmFja2dyb3VuZCgwKTtcbiAgICogIHN0cm9rZSgwLDI1NSwwKTtcbiAgICogIGxldCBzcGVjdHJ1bSA9IGZmdC5hbmFseXplKCk7XG4gICAqICBmaWxsKDAsMjU1LDApOyAvLyBzcGVjdHJ1bSBpcyBncmVlblxuICAgKlxuICAgKiAgLy9kcmF3IHRoZSBzcGVjdHJ1bVxuICAgKiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjdHJ1bS5sZW5ndGg7IGkrKyl7XG4gICAqICAgIGxldCB4ID0gbWFwKGxvZyhpKSwgMCwgbG9nKHNwZWN0cnVtLmxlbmd0aCksIDAsIHdpZHRoKTtcbiAgICogICAgbGV0IGggPSBtYXAoc3BlY3RydW1baV0sIDAsIDI1NSwgMCwgaGVpZ2h0KTtcbiAgICogICAgbGV0IHJlY3RhbmdsZV93aWR0aCA9IChsb2coaSsxKS1sb2coaSkpKih3aWR0aC9sb2coc3BlY3RydW0ubGVuZ3RoKSk7XG4gICAqICAgIHJlY3QoeCwgaGVpZ2h0LCByZWN0YW5nbGVfd2lkdGgsIC1oIClcbiAgICogIH1cbiAgICogIGxldCBueXF1aXN0ID0gMjIwNTA7XG4gICAqXG4gICAqICAvLyBnZXQgdGhlIGNlbnRyb2lkXG4gICAqICBzcGVjdHJhbENlbnRyb2lkID0gZmZ0LmdldENlbnRyb2lkKCk7XG4gICAqXG4gICAqICAvLyB0aGUgbWVhbl9mcmVxX2luZGV4IGNhbGN1bGF0aW9uIGlzIGZvciB0aGUgZGlzcGxheS5cbiAgICogIGxldCBtZWFuX2ZyZXFfaW5kZXggPSBzcGVjdHJhbENlbnRyb2lkLyhueXF1aXN0L3NwZWN0cnVtLmxlbmd0aCk7XG4gICAqXG4gICAqICBjZW50cm9pZHBsb3QgPSBtYXAobG9nKG1lYW5fZnJlcV9pbmRleCksIDAsIGxvZyhzcGVjdHJ1bS5sZW5ndGgpLCAwLCB3aWR0aCk7XG4gICAqXG4gICAqICBzdHJva2UoMjU1LDAsMCk7IC8vIHRoZSBsaW5lIHNob3dpbmcgd2hlcmUgdGhlIGNlbnRyb2lkIGlzIHdpbGwgYmUgcmVkXG4gICAqXG4gICAqICByZWN0KGNlbnRyb2lkcGxvdCwgMCwgd2lkdGggLyBzcGVjdHJ1bS5sZW5ndGgsIGhlaWdodClcbiAgICogIG5vU3Ryb2tlKCk7XG4gICAqICBmaWxsKDI1NSwyNTUsMjU1KTsgIC8vIHRleHQgaXMgd2hpdGVcbiAgICogIHRleHQoJ2NlbnRyb2lkOiAnLCAxMCwgMjApO1xuICAgKiAgdGV4dChyb3VuZChzcGVjdHJhbENlbnRyb2lkKSsnIEh6JywgMTAsIDQwKTtcbiAgICp9XG4gICAqIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5GRlQucHJvdG90eXBlLmdldENlbnRyb2lkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBueXF1aXN0ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZSAvIDI7XG4gICAgdmFyIGN1bXVsYXRpdmVfc3VtID0gMDtcbiAgICB2YXIgY2VudHJvaWRfbm9ybWFsaXphdGlvbiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJlcURvbWFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgY3VtdWxhdGl2ZV9zdW0gKz0gaSAqIHRoaXMuZnJlcURvbWFpbltpXTtcbiAgICAgIGNlbnRyb2lkX25vcm1hbGl6YXRpb24gKz0gdGhpcy5mcmVxRG9tYWluW2ldO1xuICAgIH1cblxuICAgIHZhciBtZWFuX2ZyZXFfaW5kZXggPSAwO1xuXG4gICAgaWYgKGNlbnRyb2lkX25vcm1hbGl6YXRpb24gIT09IDApIHtcbiAgICAgIG1lYW5fZnJlcV9pbmRleCA9IGN1bXVsYXRpdmVfc3VtIC8gY2VudHJvaWRfbm9ybWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgc3BlY19jZW50cm9pZF9mcmVxID0gbWVhbl9mcmVxX2luZGV4ICogKG55cXVpc3QgLyB0aGlzLmZyZXFEb21haW4ubGVuZ3RoKTtcbiAgICByZXR1cm4gc3BlY19jZW50cm9pZF9mcmVxO1xuICB9O1xuICAvKipcbiAgICogIFNtb290aCBGRlQgYW5hbHlzaXMgYnkgYXZlcmFnaW5nIHdpdGggdGhlIGxhc3QgYW5hbHlzaXMgZnJhbWUuXG4gICAqXG4gICAqICBAbWV0aG9kIHNtb290aFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IHNtb290aGluZyAgICAwLjAgPCBzbW9vdGhpbmcgPCAxLjAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIDAuOC5cbiAgICovXG5cblxuICBwNS5GRlQucHJvdG90eXBlLnNtb290aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zbW9vdGhpbmcgPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNtb290aGluZztcbiAgfTtcblxuICBwNS5GRlQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gcDVzb3VuZC5zb3VuZEFycmF5LmluZGV4T2YodGhpcyk7XG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBpZiAodGhpcy5hbmFseXNlcikge1xuICAgICAgdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5hbmFseXNlcjtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBhcnJheSBvZiBhdmVyYWdlIGFtcGxpdHVkZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbnVtYmVyXG4gICAqICBvZiBmcmVxdWVuY3kgYmFuZHMgc3BsaXQgZXF1YWxseS4gTiBkZWZhdWx0cyB0byAxNi5cbiAgICogIDxlbT5OT1RFOiBhbmFseXplKCkgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gbGluQXZlcmFnZXMoKS4gQW5hbHl6ZSgpXG4gICAqICB0ZWxscyB0aGUgRkZUIHRvIGFuYWx5emUgZnJlcXVlbmN5IGRhdGEsIGFuZCBsaW5BdmVyYWdlcygpIHVzZXNcbiAgICogIHRoZSByZXN1bHRzIHRvIGdyb3VwIHRoZW0gaW50byBhIHNtYWxsZXIgc2V0IG9mIGF2ZXJhZ2VzLjwvZW0+PC9wPlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbGluQXZlcmFnZXNcbiAgICogIEBmb3IgcDUuRkZUXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9ICBOICAgICAgICAgICAgICAgIE51bWJlciBvZiByZXR1cm5lZCBmcmVxdWVuY3kgZ3JvdXBzXG4gICAqICBAcmV0dXJuIHtBcnJheX0gICBsaW5lYXJBdmVyYWdlcyAgIEFycmF5IG9mIGF2ZXJhZ2UgYW1wbGl0dWRlIHZhbHVlcyBmb3IgZWFjaCBncm91cFxuICAgKi9cblxuXG4gIHA1LkZGVC5wcm90b3R5cGUubGluQXZlcmFnZXMgPSBmdW5jdGlvbiAoTikge1xuICAgIHZhciBOID0gTiB8fCAxNjsgXG5cbiAgICB2YXIgc3BlY3RydW0gPSB0aGlzLmZyZXFEb21haW47XG4gICAgdmFyIHNwZWN0cnVtTGVuZ3RoID0gc3BlY3RydW0ubGVuZ3RoO1xuICAgIHZhciBzcGVjdHJ1bVN0ZXAgPSBNYXRoLmZsb29yKHNwZWN0cnVtTGVuZ3RoIC8gTik7XG4gICAgdmFyIGxpbmVhckF2ZXJhZ2VzID0gbmV3IEFycmF5KE4pOyBcblxuICAgIHZhciBncm91cEluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIHNwZWNJbmRleCA9IDA7IHNwZWNJbmRleCA8IHNwZWN0cnVtTGVuZ3RoOyBzcGVjSW5kZXgrKykge1xuICAgICAgbGluZWFyQXZlcmFnZXNbZ3JvdXBJbmRleF0gPSBsaW5lYXJBdmVyYWdlc1tncm91cEluZGV4XSAhPT0gdW5kZWZpbmVkID8gKGxpbmVhckF2ZXJhZ2VzW2dyb3VwSW5kZXhdICsgc3BlY3RydW1bc3BlY0luZGV4XSkgLyAyIDogc3BlY3RydW1bc3BlY0luZGV4XTsgXG5cbiAgICAgIGlmIChzcGVjSW5kZXggJSBzcGVjdHJ1bVN0ZXAgPT09IHNwZWN0cnVtU3RlcCAtIDEpIHtcbiAgICAgICAgZ3JvdXBJbmRleCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaW5lYXJBdmVyYWdlcztcbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGFycmF5IG9mIGF2ZXJhZ2UgYW1wbGl0dWRlIHZhbHVlcyBvZiB0aGUgc3BlY3RydW0sIGZvciBhIGdpdmVuXG4gICAqICBzZXQgb2YgPGEgaHJlZj1cImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09jdGF2ZV9iYW5kXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAqICBPY3RhdmUgQmFuZHM8L2E+XG4gICAqICA8ZW0+Tk9URTogYW5hbHl6ZSgpIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvIGxvZ0F2ZXJhZ2VzKCkuIEFuYWx5emUoKVxuICAgKiAgdGVsbHMgdGhlIEZGVCB0byBhbmFseXplIGZyZXF1ZW5jeSBkYXRhLCBhbmQgbG9nQXZlcmFnZXMoKSB1c2VzXG4gICAqICB0aGUgcmVzdWx0cyB0byBncm91cCB0aGVtIGludG8gYSBzbWFsbGVyIHNldCBvZiBhdmVyYWdlcy48L2VtPjwvcD5cbiAgICpcbiAgICogIEBtZXRob2QgIGxvZ0F2ZXJhZ2VzXG4gICAqICBAZm9yIHA1LkZGVFxuICAgKiAgQHBhcmFtICB7QXJyYXl9ICAgb2N0YXZlQmFuZHMgICAgQXJyYXkgb2YgT2N0YXZlIEJhbmRzIG9iamVjdHMgZm9yIGdyb3VwaW5nXG4gICAqICBAcmV0dXJuIHtBcnJheX0gICBsb2dBdmVyYWdlcyAgICBBcnJheSBvZiBhdmVyYWdlIGFtcGxpdHVkZSB2YWx1ZXMgZm9yIGVhY2ggZ3JvdXBcbiAgICovXG5cblxuICBwNS5GRlQucHJvdG90eXBlLmxvZ0F2ZXJhZ2VzID0gZnVuY3Rpb24gKG9jdGF2ZUJhbmRzKSB7XG4gICAgdmFyIG55cXVpc3QgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlIC8gMjtcbiAgICB2YXIgc3BlY3RydW0gPSB0aGlzLmZyZXFEb21haW47XG4gICAgdmFyIHNwZWN0cnVtTGVuZ3RoID0gc3BlY3RydW0ubGVuZ3RoO1xuICAgIHZhciBsb2dBdmVyYWdlcyA9IG5ldyBBcnJheShvY3RhdmVCYW5kcy5sZW5ndGgpOyBcblxuICAgIHZhciBvY3RhdmVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBzcGVjSW5kZXggPSAwOyBzcGVjSW5kZXggPCBzcGVjdHJ1bUxlbmd0aDsgc3BlY0luZGV4KyspIHtcbiAgICAgIHZhciBzcGVjSW5kZXhGcmVxdWVuY3kgPSBNYXRoLnJvdW5kKHNwZWNJbmRleCAqIG55cXVpc3QgLyB0aGlzLmZyZXFEb21haW4ubGVuZ3RoKTsgXG5cbiAgICAgIGlmIChzcGVjSW5kZXhGcmVxdWVuY3kgPiBvY3RhdmVCYW5kc1tvY3RhdmVJbmRleF0uaGkpIHtcbiAgICAgICAgb2N0YXZlSW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgbG9nQXZlcmFnZXNbb2N0YXZlSW5kZXhdID0gbG9nQXZlcmFnZXNbb2N0YXZlSW5kZXhdICE9PSB1bmRlZmluZWQgPyAobG9nQXZlcmFnZXNbb2N0YXZlSW5kZXhdICsgc3BlY3RydW1bc3BlY0luZGV4XSkgLyAyIDogc3BlY3RydW1bc3BlY0luZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9nQXZlcmFnZXM7XG4gIH07XG4gIC8qKlxuICAgKiAgQ2FsY3VsYXRlcyBhbmQgUmV0dXJucyB0aGUgMS9OXG4gICAqICA8YSBocmVmPVwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2N0YXZlX2JhbmRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5PY3RhdmUgQmFuZHM8L2E+XG4gICAqICBOIGRlZmF1bHRzIHRvIDMgYW5kIG1pbmltdW0gY2VudHJhbCBmcmVxdWVuY3kgdG8gMTUuNjI1SHouXG4gICAqICAoMS8zIE9jdGF2ZSBCYW5kcyB+PSAzMSBGcmVxdWVuY3kgQmFuZHMpXG4gICAqICBTZXR0aW5nIGZDdHIwIHRvIGEgY2VudHJhbCB2YWx1ZSBvZiBhIGhpZ2hlciBvY3RhdmUgd2lsbCBpZ25vcmUgdGhlIGxvd2VyIGJhbmRzXG4gICAqICBhbmQgcHJvZHVjZSBsZXNzIGZyZXF1ZW5jeSBncm91cHMuXG4gICAqXG4gICAqICBAbWV0aG9kICAgZ2V0T2N0YXZlQmFuZHNcbiAgICogIEBmb3IgcDUuRkZUXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9ICBOICAgICAgICAgICAgIFNwZWNpZmllcyB0aGUgMS9OIHR5cGUgb2YgZ2VuZXJhdGVkIG9jdGF2ZSBiYW5kc1xuICAgKiAgQHBhcmFtICB7TnVtYmVyfSAgZkN0cjAgICAgICAgICBNaW5pbXVtIGNlbnRyYWwgZnJlcXVlbmN5IGZvciB0aGUgbG93ZXN0IGJhbmRcbiAgICogIEByZXR1cm4ge0FycmF5fSAgIG9jdGF2ZUJhbmRzICAgQXJyYXkgb2Ygb2N0YXZlIGJhbmQgb2JqZWN0cyB3aXRoIHRoZWlyIGJvdW5kc1xuICAgKi9cblxuXG4gIHA1LkZGVC5wcm90b3R5cGUuZ2V0T2N0YXZlQmFuZHMgPSBmdW5jdGlvbiAoTiwgZkN0cjApIHtcbiAgICB2YXIgTiA9IE4gfHwgMzsgXG5cbiAgICB2YXIgZkN0cjAgPSBmQ3RyMCB8fCAxNS42MjU7IFxuXG4gICAgdmFyIG9jdGF2ZUJhbmRzID0gW107XG4gICAgdmFyIGxhc3RGcmVxdWVuY3lCYW5kID0ge1xuICAgICAgbG86IGZDdHIwIC8gTWF0aC5wb3coMiwgMSAvICgyICogTikpLFxuICAgICAgY3RyOiBmQ3RyMCxcbiAgICAgIGhpOiBmQ3RyMCAqIE1hdGgucG93KDIsIDEgLyAoMiAqIE4pKVxuICAgIH07XG4gICAgb2N0YXZlQmFuZHMucHVzaChsYXN0RnJlcXVlbmN5QmFuZCk7XG4gICAgdmFyIG55cXVpc3QgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlIC8gMjtcblxuICAgIHdoaWxlIChsYXN0RnJlcXVlbmN5QmFuZC5oaSA8IG55cXVpc3QpIHtcbiAgICAgIHZhciBuZXdGcmVxdWVuY3lCYW5kID0ge307XG4gICAgICBuZXdGcmVxdWVuY3lCYW5kLmxvID0gbGFzdEZyZXF1ZW5jeUJhbmQuaGk7XG4gICAgICBuZXdGcmVxdWVuY3lCYW5kLmN0ciA9IGxhc3RGcmVxdWVuY3lCYW5kLmN0ciAqIE1hdGgucG93KDIsIDEgLyBOKTtcbiAgICAgIG5ld0ZyZXF1ZW5jeUJhbmQuaGkgPSBuZXdGcmVxdWVuY3lCYW5kLmN0ciAqIE1hdGgucG93KDIsIDEgLyAoMiAqIE4pKTtcbiAgICAgIG9jdGF2ZUJhbmRzLnB1c2gobmV3RnJlcXVlbmN5QmFuZCk7XG4gICAgICBsYXN0RnJlcXVlbmN5QmFuZCA9IG5ld0ZyZXF1ZW5jeUJhbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9jdGF2ZUJhbmRzO1xuICB9OyBcblxuXG4gIHZhciBmcmVxVG9GbG9hdCA9IGZ1bmN0aW9uIGZyZXFUb0Zsb2F0KGZmdCkge1xuICAgIGlmIChmZnQuZnJlcURvbWFpbiBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA9PT0gZmFsc2UpIHtcbiAgICAgIGZmdC5mcmVxRG9tYWluID0gbmV3IEZsb2F0MzJBcnJheShmZnQuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZnJlcVRvSW50ID0gZnVuY3Rpb24gZnJlcVRvSW50KGZmdCkge1xuICAgIGlmIChmZnQuZnJlcURvbWFpbiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPT09IGZhbHNlKSB7XG4gICAgICBmZnQuZnJlcURvbWFpbiA9IG5ldyBVaW50OEFycmF5KGZmdC5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB0aW1lVG9GbG9hdCA9IGZ1bmN0aW9uIHRpbWVUb0Zsb2F0KGZmdCkge1xuICAgIGlmIChmZnQudGltZURvbWFpbiBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA9PT0gZmFsc2UpIHtcbiAgICAgIGZmdC50aW1lRG9tYWluID0gbmV3IEZsb2F0MzJBcnJheShmZnQuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdGltZVRvSW50ID0gZnVuY3Rpb24gdGltZVRvSW50KGZmdCkge1xuICAgIGlmIChmZnQudGltZURvbWFpbiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPT09IGZhbHNlKSB7XG4gICAgICBmZnQudGltZURvbWFpbiA9IG5ldyBVaW50OEFycmF5KGZmdC5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gICAgfVxuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBTaWduYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4gIHZhciBBZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG4gIHZhciBNdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuICB2YXIgU2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgLyoqXG4gICAqICA8cD5wNS5TaWduYWwgaXMgYSBjb25zdGFudCBhdWRpby1yYXRlIHNpZ25hbCB1c2VkIGJ5IHA1Lk9zY2lsbGF0b3JcbiAgICogIGFuZCBwNS5FbnZlbG9wZSBmb3IgbW9kdWxhdGlvbiBtYXRoLjwvcD5cbiAgICpcbiAgICogIDxwPlRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgV2ViIEF1ZGlvIGlzIHByb2Nlc3NlZCBvbiBhIHNlcHJhdGUgY2xvY2suXG4gICAqICBGb3IgZXhhbXBsZSwgdGhlIHA1IGRyYXcgbG9vcCBydW5zIGFib3V0IDYwIHRpbWVzIHBlciBzZWNvbmQuIEJ1dFxuICAgKiAgdGhlIGF1ZGlvIGNsb2NrIG11c3QgcHJvY2VzcyBzYW1wbGVzIDQ0MTAwIHRpbWVzIHBlciBzZWNvbmQuIElmIHdlXG4gICAqICB3YW50IHRvIGFkZCBhIHZhbHVlIHRvIGVhY2ggb2YgdGhvc2Ugc2FtcGxlcywgd2UgY2FuJ3QgZG8gaXQgaW4gdGhlXG4gICAqICBkcmF3IGxvb3AsIGJ1dCB3ZSBjYW4gZG8gaXQgYnkgYWRkaW5nIGEgY29uc3RhbnQtcmF0ZSBhdWRpbyBzaWduYWwuPC9wLlxuICAgKlxuICAgKiAgPHA+VGhpcyBjbGFzcyBtb3N0bHkgZnVuY3Rpb25zIGJlaGluZCB0aGUgc2NlbmVzIGluIHA1LnNvdW5kLCBhbmQgcmV0dXJuc1xuICAgKiAgYSBUb25lLlNpZ25hbCBmcm9tIHRoZSBUb25lLmpzIGxpYnJhcnkgYnkgWW90YW0gTWFubi5cbiAgICogIElmIHlvdSB3YW50IHRvIHdvcmsgZGlyZWN0bHkgd2l0aCBhdWRpbyBzaWduYWxzIGZvciBtb2R1bGFyXG4gICAqICBzeW50aGVzaXMsIGNoZWNrIG91dFxuICAgKiAgPGEgaHJlZj0naHR0cDovL2JpdC5seS8xb0lvRW5nJyB0YXJnZXQ9XydibGFuayc+dG9uZS5qcy48L2E+PC9wPlxuICAgKlxuICAgKiAgQGNsYXNzICBwNS5TaWduYWxcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHJldHVybiB7VG9uZS5TaWduYWx9IEEgU2lnbmFsIG9iamVjdCBmcm9tIHRoZSBUb25lLmpzIGxpYnJhcnlcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGNhcnJpZXIsIG1vZHVsYXRvcjtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqXG4gICAqICAgIGNhcnJpZXIgPSBuZXcgcDUuT3NjaWxsYXRvcignc2luZScpO1xuICAgKiAgICBjYXJyaWVyLnN0YXJ0KCk7XG4gICAqICAgIGNhcnJpZXIuYW1wKDEpOyAvLyBzZXQgYW1wbGl0dWRlXG4gICAqICAgIGNhcnJpZXIuZnJlcSgyMjApOyAvLyBzZXQgZnJlcXVlbmN5XG4gICAqXG4gICAqICAgIG1vZHVsYXRvciA9IG5ldyBwNS5Pc2NpbGxhdG9yKCdzYXd0b290aCcpO1xuICAgKiAgICBtb2R1bGF0b3IuZGlzY29ubmVjdCgpO1xuICAgKiAgICBtb2R1bGF0b3Iuc3RhcnQoKTtcbiAgICogICAgbW9kdWxhdG9yLmFtcCgxKTtcbiAgICogICAgbW9kdWxhdG9yLmZyZXEoNCk7XG4gICAqXG4gICAqICAgIC8vIE1vZHVsYXRvcidzIGRlZmF1bHQgYW1wbGl0dWRlIHJhbmdlIGlzIC0xIHRvIDEuXG4gICAqICAgIC8vIE11bHRpcGx5IGl0IGJ5IC0yMDAsIHNvIHRoZSByYW5nZSBpcyAtMjAwIHRvIDIwMFxuICAgKiAgICAvLyB0aGVuIGFkZCAyMjAgc28gdGhlIHJhbmdlIGlzIDIwIHRvIDQyMFxuICAgKiAgICBjYXJyaWVyLmZyZXEoIG1vZHVsYXRvci5tdWx0KC00MDApLmFkZCgyMjApICk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBjYW52YXNQcmVzc2VkKCkge1xuICAgKiAgICB1c2VyU3RhcnRBdWRpbygpO1xuICAgKiAgICBjYXJyaWVyLmFtcCgxLjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgY2Fycmllci5hbXAoMCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuU2lnbmFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHMgPSBuZXcgU2lnbmFsKHZhbHVlKTsgXG5cbiAgICByZXR1cm4gczsgXG4gIH07XG4gIC8qKlxuICAgKiAgRmFkZSB0byB2YWx1ZSwgZm9yIHNtb290aCB0cmFuc2l0aW9uc1xuICAgKlxuICAgKiAgQG1ldGhvZCAgZmFkZVxuICAgKiAgQGZvciBwNS5TaWduYWxcbiAgICogIEBwYXJhbSAge051bWJlcn0gdmFsdWUgICAgICAgICAgVmFsdWUgdG8gc2V0IHRoaXMgc2lnbmFsXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzZWNvbmRzRnJvbU5vd10gTGVuZ3RoIG9mIGZhZGUsIGluIHNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBTaWduYWwucHJvdG90eXBlLmZhZGUgPSBTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lO1xuICBNdWx0LnByb3RvdHlwZS5mYWRlID0gU2lnbmFsLnByb3RvdHlwZS5mYWRlO1xuICBBZGQucHJvdG90eXBlLmZhZGUgPSBTaWduYWwucHJvdG90eXBlLmZhZGU7XG4gIFNjYWxlLnByb3RvdHlwZS5mYWRlID0gU2lnbmFsLnByb3RvdHlwZS5mYWRlO1xuICAvKipcbiAgICogIENvbm5lY3QgYSBwNS5zb3VuZCBvYmplY3Qgb3IgV2ViIEF1ZGlvIG5vZGUgdG8gdGhpc1xuICAgKiAgcDUuU2lnbmFsIHNvIHRoYXQgaXRzIGFtcGxpdHVkZSB2YWx1ZXMgY2FuIGJlIHNjYWxlZC5cbiAgICpcbiAgICogIEBtZXRob2Qgc2V0SW5wdXRcbiAgICogIEBmb3IgcDUuU2lnbmFsXG4gICAqICBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cbiAgU2lnbmFsLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uIChfaW5wdXQpIHtcbiAgICBfaW5wdXQuY29ubmVjdCh0aGlzKTtcbiAgfTtcblxuICBNdWx0LnByb3RvdHlwZS5zZXRJbnB1dCA9IFNpZ25hbC5wcm90b3R5cGUuc2V0SW5wdXQ7XG4gIEFkZC5wcm90b3R5cGUuc2V0SW5wdXQgPSBTaWduYWwucHJvdG90eXBlLnNldElucHV0O1xuICBTY2FsZS5wcm90b3R5cGUuc2V0SW5wdXQgPSBTaWduYWwucHJvdG90eXBlLnNldElucHV0OyBcblxuICAvKipcbiAgICogIEFkZCBhIGNvbnN0YW50IHZhbHVlIHRvIHRoaXMgYXVkaW8gc2lnbmFsLFxuICAgKiAgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGF1ZGlvIHNpZ25hbC4gRG9lc1xuICAgKiAgbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgdGhlIG9yaWdpbmFsIHNpZ25hbCxcbiAgICogIGluc3RlYWQgaXQgcmV0dXJucyBhIG5ldyBwNS5TaWduYWxBZGQuXG4gICAqXG4gICAqICBAbWV0aG9kICBhZGRcbiAgICogIEBmb3IgcDUuU2lnbmFsXG4gICAqICBAcGFyYW0ge051bWJlcn0gbnVtYmVyXG4gICAqICBAcmV0dXJuIHtwNS5TaWduYWx9IG9iamVjdFxuICAgKi9cblxuICBTaWduYWwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB2YXIgYWRkID0gbmV3IEFkZChudW0pOyBcblxuICAgIHRoaXMuY29ubmVjdChhZGQpO1xuICAgIHJldHVybiBhZGQ7XG4gIH07XG5cbiAgTXVsdC5wcm90b3R5cGUuYWRkID0gU2lnbmFsLnByb3RvdHlwZS5hZGQ7XG4gIEFkZC5wcm90b3R5cGUuYWRkID0gU2lnbmFsLnByb3RvdHlwZS5hZGQ7XG4gIFNjYWxlLnByb3RvdHlwZS5hZGQgPSBTaWduYWwucHJvdG90eXBlLmFkZDtcbiAgLyoqXG4gICAqICBNdWx0aXBseSB0aGlzIHNpZ25hbCBieSBhIGNvbnN0YW50IHZhbHVlLFxuICAgKiAgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGF1ZGlvIHNpZ25hbC4gRG9lc1xuICAgKiAgbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgdGhlIG9yaWdpbmFsIHNpZ25hbCxcbiAgICogIGluc3RlYWQgaXQgcmV0dXJucyBhIG5ldyBwNS5TaWduYWxNdWx0LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbXVsdFxuICAgKiAgQGZvciBwNS5TaWduYWxcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgdG8gbXVsdGlwbHlcbiAgICogIEByZXR1cm4ge3A1LlNpZ25hbH0gb2JqZWN0XG4gICAqL1xuXG4gIFNpZ25hbC5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB2YXIgbXVsdCA9IG5ldyBNdWx0KG51bSk7IFxuXG4gICAgdGhpcy5jb25uZWN0KG11bHQpO1xuICAgIHJldHVybiBtdWx0O1xuICB9O1xuXG4gIE11bHQucHJvdG90eXBlLm11bHQgPSBTaWduYWwucHJvdG90eXBlLm11bHQ7XG4gIEFkZC5wcm90b3R5cGUubXVsdCA9IFNpZ25hbC5wcm90b3R5cGUubXVsdDtcbiAgU2NhbGUucHJvdG90eXBlLm11bHQgPSBTaWduYWwucHJvdG90eXBlLm11bHQ7XG4gIC8qKlxuICAgKiAgU2NhbGUgdGhpcyBzaWduYWwgdmFsdWUgdG8gYSBnaXZlbiByYW5nZSxcbiAgICogIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhbiBhdWRpbyBzaWduYWwuIERvZXNcbiAgICogIG5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBzaWduYWwsXG4gICAqICBpbnN0ZWFkIGl0IHJldHVybnMgYSBuZXcgcDUuU2lnbmFsU2NhbGUuXG4gICAqXG4gICAqICBAbWV0aG9kICBzY2FsZVxuICAgKiAgQGZvciBwNS5TaWduYWxcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgdG8gbXVsdGlwbHlcbiAgICogIEBwYXJhbSAge051bWJlcn0gaW5NaW4gIGlucHV0IHJhbmdlIG1pbnVtdW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gaW5NYXggIGlucHV0IHJhbmdlIG1heGltdW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gb3V0TWluIGlucHV0IHJhbmdlIG1pbnVtdW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gb3V0TWF4IGlucHV0IHJhbmdlIG1heGltdW1cbiAgICogIEByZXR1cm4ge3A1LlNpZ25hbH0gb2JqZWN0XG4gICAqL1xuXG4gIFNpZ25hbC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCkge1xuICAgIHZhciBtYXBPdXRNaW4sIG1hcE91dE1heDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICBtYXBPdXRNaW4gPSBwNS5wcm90b3R5cGUubWFwKG91dE1pbiwgaW5NaW4sIGluTWF4LCAwLCAxKSAtIDAuNTtcbiAgICAgIG1hcE91dE1heCA9IHA1LnByb3RvdHlwZS5tYXAob3V0TWF4LCBpbk1pbiwgaW5NYXgsIDAsIDEpIC0gMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXBPdXRNaW4gPSBhcmd1bWVudHNbMF07XG4gICAgICBtYXBPdXRNYXggPSBhcmd1bWVudHNbMV07XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gbmV3IFNjYWxlKG1hcE91dE1pbiwgbWFwT3V0TWF4KTtcbiAgICB0aGlzLmNvbm5lY3Qoc2NhbGUpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBNdWx0LnByb3RvdHlwZS5zY2FsZSA9IFNpZ25hbC5wcm90b3R5cGUuc2NhbGU7XG4gIEFkZC5wcm90b3R5cGUuc2NhbGUgPSBTaWduYWwucHJvdG90eXBlLnNjYWxlO1xuICBTY2FsZS5wcm90b3R5cGUuc2NhbGUgPSBTaWduYWwucHJvdG90eXBlLnNjYWxlO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKG8pe28uRnJlcXVlbmN5PWZ1bmN0aW9uKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2Ygby5GcmVxdWVuY3kpKXJldHVybiBuZXcgby5GcmVxdWVuY3koZSx0KTtvLlRpbWVCYXNlLmNhbGwodGhpcyxlLHQpfSxvLmV4dGVuZChvLkZyZXF1ZW5jeSxvLlRpbWVCYXNlKSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucz1PYmplY3QuY3JlYXRlKG8uVGltZUJhc2UucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMpLG8uRnJlcXVlbmN5LnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zLm1pZGk9e3JlZ2V4cDovXihcXGQrKD86XFwuXFxkKyk/bWlkaSkvLG1ldGhvZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5taWRpVG9GcmVxdWVuY3koZSl9fSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucy5ub3RlPXtyZWdleHA6L14oW2EtZ117MX0oPzpifCN8eHxiYik/KSgtP1swLTldKykvaSxtZXRob2Q6ZnVuY3Rpb24oZSx0KXt2YXIgcj1uW2UudG9Mb3dlckNhc2UoKV0rMTIqKHBhcnNlSW50KHQpKzEpO3JldHVybiB0aGlzLm1pZGlUb0ZyZXF1ZW5jeShyKX19LG8uRnJlcXVlbmN5LnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zLnRyPXtyZWdleHA6L14oXFxkKyg/OlxcLlxcZCspPyk6KFxcZCsoPzpcXC5cXGQrKT8pOj8oXFxkKyg/OlxcLlxcZCspPyk/LyxtZXRob2Q6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPTE7cmV0dXJuIGUmJlwiMFwiIT09ZSYmKG4qPXRoaXMuX2JlYXRzVG9Vbml0cyh0aGlzLl90aW1lU2lnbmF0dXJlKCkqcGFyc2VGbG9hdChlKSkpLHQmJlwiMFwiIT09dCYmKG4qPXRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHQpKSksciYmXCIwXCIhPT1yJiYobio9dGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocikvNCkpLG59fSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9leHByPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUoKSp0aGlzLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyh0KX0uYmluZCh0aGlzLHRoaXMuX2V4cHIsZSksdGhpc30sby5GcmVxdWVuY3kucHJvdG90eXBlLmhhcm1vbml6ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fZXhwcj1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj1lKCksbj1bXSxvPTA7bzx0Lmxlbmd0aDtvKyspbltvXT1yKnRoaXMuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKHRbb10pO3JldHVybiBufS5iaW5kKHRoaXMsdGhpcy5fZXhwcixlKSx0aGlzfSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9NaWRpPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZnJlcXVlbmN5VG9NaWRpKHRoaXMudmFsdWVPZigpKX0sby5GcmVxdWVuY3kucHJvdG90eXBlLnRvTm90ZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMudmFsdWVPZigpLHQ9TWF0aC5sb2coZS9vLkZyZXF1ZW5jeS5BNCkvTWF0aC5MTjIscj1NYXRoLnJvdW5kKDEyKnQpKzU3LG49TWF0aC5mbG9vcihyLzEyKTtyZXR1cm4gbjwwJiYocis9LTEyKm4pLGlbciUxMl0rbi50b1N0cmluZygpfSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9TZWNvbmRzPWZ1bmN0aW9uKCl7cmV0dXJuIDEvdGhpcy52YWx1ZU9mKCl9LG8uRnJlcXVlbmN5LnByb3RvdHlwZS50b0ZyZXF1ZW5jeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlT2YoKX0sby5GcmVxdWVuY3kucHJvdG90eXBlLnRvVGlja3M9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9iZWF0c1RvVW5pdHMoMSksdD10aGlzLnZhbHVlT2YoKS9lO3JldHVybiBNYXRoLmZsb29yKHQqby5UcmFuc3BvcnQuUFBRKX0sby5GcmVxdWVuY3kucHJvdG90eXBlLl9mcmVxdWVuY3lUb1VuaXRzPWZ1bmN0aW9uKGUpe3JldHVybiBlfSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3RpY2tzVG9Vbml0cz1mdW5jdGlvbihlKXtyZXR1cm4gMS8oNjAqZS8oby5UcmFuc3BvcnQuYnBtLnZhbHVlKm8uVHJhbnNwb3J0LlBQUSkpfSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cz1mdW5jdGlvbihlKXtyZXR1cm4gMS9vLlRpbWVCYXNlLnByb3RvdHlwZS5fYmVhdHNUb1VuaXRzLmNhbGwodGhpcyxlKX0sby5GcmVxdWVuY3kucHJvdG90eXBlLl9zZWNvbmRzVG9Vbml0cz1mdW5jdGlvbihlKXtyZXR1cm4gMS9lfSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUuX2RlZmF1bHRVbml0cz1cImh6XCI7dmFyIG49e2NiYjotMixjYjotMSxjOjAsXCJjI1wiOjEsY3g6MixkYmI6MCxkYjoxLGQ6MixcImQjXCI6MyxkeDo0LGViYjoyLGViOjMsZTo0LFwiZSNcIjo1LGV4OjYsZmJiOjMsZmI6NCxmOjUsXCJmI1wiOjYsZng6NyxnYmI6NSxnYjo2LGc6NyxcImcjXCI6OCxneDo5LGFiYjo3LGFiOjgsYTo5LFwiYSNcIjoxMCxheDoxMSxiYmI6OSxiYjoxMCxiOjExLFwiYiNcIjoxMixieDoxM30saT1bXCJDXCIsXCJDI1wiLFwiRFwiLFwiRCNcIixcIkVcIixcIkZcIixcIkYjXCIsXCJHXCIsXCJHI1wiLFwiQVwiLFwiQSNcIixcIkJcIl07cmV0dXJuIG8uRnJlcXVlbmN5LkE0PTQ0MCxvLkZyZXF1ZW5jeS5wcm90b3R5cGUubWlkaVRvRnJlcXVlbmN5PWZ1bmN0aW9uKGUpe3JldHVybiBvLkZyZXF1ZW5jeS5BNCpNYXRoLnBvdygyLChlLTY5KS8xMil9LG8uRnJlcXVlbmN5LnByb3RvdHlwZS5mcmVxdWVuY3lUb01pZGk9ZnVuY3Rpb24oZSl7cmV0dXJuIDY5KzEyKk1hdGgubG9nKGUvby5GcmVxdWVuY3kuQTQpL01hdGguTE4yfSxvLkZyZXF1ZW5jeX0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKG8pe3JldHVybiBvLlRyYW5zcG9ydFRpbWU9ZnVuY3Rpb24odCxyKXtpZighKHRoaXMgaW5zdGFuY2VvZiBvLlRyYW5zcG9ydFRpbWUpKXJldHVybiBuZXcgby5UcmFuc3BvcnRUaW1lKHQscik7by5UaW1lLmNhbGwodGhpcyx0LHIpfSxvLmV4dGVuZChvLlRyYW5zcG9ydFRpbWUsby5UaW1lKSxvLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zPU9iamVjdC5jcmVhdGUoby5UaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyksby5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucy5xdWFudGl6ZT17cmVnZXhwOi9eQC8sbWV0aG9kOmZ1bmN0aW9uKHQpe3ZhciByPXRoaXMuX3NlY29uZHNUb1RpY2tzKHQoKSksZT1NYXRoLmNlaWwoby5UcmFuc3BvcnQudGlja3Mvcik7cmV0dXJuIHRoaXMuX3RpY2tzVG9Vbml0cyhlKnIpfX0sby5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5fc2Vjb25kc1RvVGlja3M9ZnVuY3Rpb24odCl7dmFyIHI9dC90aGlzLl9iZWF0c1RvVW5pdHMoMSk7cmV0dXJuIE1hdGgucm91bmQocipvLlRyYW5zcG9ydC5QUFEpfSxvLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2Vjb25kc1RvVGlja3ModGhpcy5fZXhwcigpKSsodGhpcy5fcGx1c05vdz9vLlRyYW5zcG9ydC50aWNrczowKX0sby5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS50b1RpY2tzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVPZigpfSxvLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLnRvU2Vjb25kcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9leHByKCkrKHRoaXMuX3BsdXNOb3c/by5UcmFuc3BvcnQuc2Vjb25kczowKX0sby5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS50b0ZyZXF1ZW5jeT1mdW5jdGlvbigpe3JldHVybiAxL3RoaXMudG9TZWNvbmRzKCl9LG8uVHJhbnNwb3J0VGltZX0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgQWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuICB2YXIgTXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbiAgdmFyIFNjYWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbiAgdmFyIFRpbWVsaW5lU2lnbmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4gIC8qKlxuICAgKiAgPHA+RW52ZWxvcGVzIGFyZSBwcmUtZGVmaW5lZCBhbXBsaXR1ZGUgZGlzdHJpYnV0aW9uIG92ZXIgdGltZS5cbiAgICogIFR5cGljYWxseSwgZW52ZWxvcGVzIGFyZSB1c2VkIHRvIGNvbnRyb2wgdGhlIG91dHB1dCB2b2x1bWVcbiAgICogIG9mIGFuIG9iamVjdCwgYSBzZXJpZXMgb2YgZmFkZXMgcmVmZXJyZWQgdG8gYXMgQXR0YWNrLCBEZWNheSxcbiAgICogIFN1c3RhaW4gYW5kIFJlbGVhc2UgKFxuICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvZS9lYS9BRFNSX3BhcmFtZXRlci5zdmdcIj5BRFNSPC9hPlxuICAgKiAgKS4gRW52ZWxvcGVzIGNhbiBhbHNvIGNvbnRyb2wgb3RoZXIgV2ViIEF1ZGlvIFBhcmFtZXRlcnPigJRmb3IgZXhhbXBsZSwgYSBwNS5FbnZlbG9wZSBjYW5cbiAgICogIGNvbnRyb2wgYW4gT3NjaWxsYXRvcidzIGZyZXF1ZW5jeSBsaWtlIHRoaXM6IDxjb2RlPm9zYy5mcmVxKGVudik8L2NvZGU+LjwvcD5cbiAgICogIDxwPlVzZSA8Y29kZT48YSBocmVmPVwiIy9wNS5FbnZlbG9wZS9zZXRSYW5nZVwiPnNldFJhbmdlPC9hPjwvY29kZT4gdG8gY2hhbmdlIHRoZSBhdHRhY2svcmVsZWFzZSBsZXZlbC5cbiAgICogIFVzZSA8Y29kZT48YSBocmVmPVwiIy9wNS5FbnZlbG9wZS9zZXRBRFNSXCI+c2V0QURTUjwvYT48L2NvZGU+IHRvIGNoYW5nZSBhdHRhY2tUaW1lLCBkZWNheVRpbWUsIHN1c3RhaW5QZXJjZW50IGFuZCByZWxlYXNlVGltZS48L3A+XG4gICAqICA8cD5Vc2UgdGhlIDxjb2RlPjxhIGhyZWY9XCIjL3A1LkVudmVsb3BlL3BsYXlcIj5wbGF5PC9hPjwvY29kZT4gbWV0aG9kIHRvIHBsYXkgdGhlIGVudGlyZSBlbnZlbG9wZSxcbiAgICogIHRoZSA8Y29kZT48YSBocmVmPVwiIy9wNS5FbnZlbG9wZS9yYW1wXCI+cmFtcDwvYT48L2NvZGU+IG1ldGhvZCBmb3IgYSBwaW5nYWJsZSB0cmlnZ2VyLFxuICAgKiAgb3IgPGNvZGU+PGEgaHJlZj1cIiMvcDUuRW52ZWxvcGUvdHJpZ2dlckF0dGFja1wiPnRyaWdnZXJBdHRhY2s8L2E+PC9jb2RlPi9cbiAgICogIDxjb2RlPjxhIGhyZWY9XCIjL3A1LkVudmVsb3BlL3RyaWdnZXJSZWxlYXNlXCI+dHJpZ2dlclJlbGVhc2U8L2E+PC9jb2RlPiB0byB0cmlnZ2VyIG5vdGVPbi9ub3RlT2ZmLjwvcD5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5FbnZlbG9wZVxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCB0MSA9IDAuMTsgLy8gYXR0YWNrIHRpbWUgaW4gc2Vjb25kc1xuICAgKiAgbGV0IGwxID0gMC43OyAvLyBhdHRhY2sgbGV2ZWwgMC4wIHRvIDEuMFxuICAgKiAgbGV0IHQyID0gMC4zOyAvLyBkZWNheSB0aW1lIGluIHNlY29uZHNcbiAgICogIGxldCBsMiA9IDAuMTsgLy8gZGVjYXkgbGV2ZWwgIDAuMCB0byAxLjBcbiAgICpcbiAgICogIGxldCBlbnY7XG4gICAqICBsZXQgdHJpT3NjO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMjAsIDIwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5U291bmQpO1xuICAgKlxuICAgKiAgICBlbnYgPSBuZXcgcDUuRW52ZWxvcGUodDEsIGwxLCB0MiwgbDIpO1xuICAgKiAgICB0cmlPc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigndHJpYW5nbGUnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlTb3VuZCgpIHtcbiAgICogICAgLy8gc3RhcnRpbmcgdGhlIG9zY2lsbGF0b3IgZW5zdXJlcyB0aGF0IGF1ZGlvIGlzIGVuYWJsZWQuXG4gICAqICAgIHRyaU9zYy5zdGFydCgpO1xuICAgKiAgICBlbnYucGxheSh0cmlPc2MpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlID0gZnVuY3Rpb24gKHQxLCBsMSwgdDIsIGwyLCB0MywgbDMpIHtcbiAgICAvKipcbiAgICAgKiBUaW1lIHVudGlsIGVudmVsb3BlIHJlYWNoZXMgYXR0YWNrTGV2ZWxcbiAgICAgKiBAcHJvcGVydHkgYXR0YWNrVGltZVxuICAgICAqL1xuICAgIHRoaXMuYVRpbWUgPSB0MSB8fCAwLjE7XG4gICAgLyoqXG4gICAgICogTGV2ZWwgb25jZSBhdHRhY2sgaXMgY29tcGxldGUuXG4gICAgICogQHByb3BlcnR5IGF0dGFja0xldmVsXG4gICAgICovXG5cbiAgICB0aGlzLmFMZXZlbCA9IGwxIHx8IDE7XG4gICAgLyoqXG4gICAgICogVGltZSB1bnRpbCBlbnZlbG9wZSByZWFjaGVzIGRlY2F5TGV2ZWwuXG4gICAgICogQHByb3BlcnR5IGRlY2F5VGltZVxuICAgICAqL1xuXG4gICAgdGhpcy5kVGltZSA9IHQyIHx8IDAuNTtcbiAgICAvKipcbiAgICAgKiBMZXZlbCBhZnRlciBkZWNheS4gVGhlIGVudmVsb3BlIHdpbGwgc3VzdGFpbiBoZXJlIHVudGlsIGl0IGlzIHJlbGVhc2VkLlxuICAgICAqIEBwcm9wZXJ0eSBkZWNheUxldmVsXG4gICAgICovXG5cbiAgICB0aGlzLmRMZXZlbCA9IGwyIHx8IDA7XG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2YgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUuXG4gICAgICogQHByb3BlcnR5IHJlbGVhc2VUaW1lXG4gICAgICovXG5cbiAgICB0aGlzLnJUaW1lID0gdDMgfHwgMDtcbiAgICAvKipcbiAgICAgKiBMZXZlbCBhdCB0aGUgZW5kIG9mIHRoZSByZWxlYXNlLlxuICAgICAqIEBwcm9wZXJ0eSByZWxlYXNlTGV2ZWxcbiAgICAgKi9cblxuICAgIHRoaXMuckxldmVsID0gbDMgfHwgMDtcbiAgICB0aGlzLl9yYW1wSGlnaFBlcmNlbnRhZ2UgPSAwLjk4O1xuICAgIHRoaXMuX3JhbXBMb3dQZXJjZW50YWdlID0gMC4wMjtcbiAgICB0aGlzLm91dHB1dCA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLmNvbnRyb2wgPSBuZXcgVGltZWxpbmVTaWduYWwoKTtcblxuICAgIHRoaXMuX2luaXQoKTsgXG5cblxuICAgIHRoaXMuY29udHJvbC5jb25uZWN0KHRoaXMub3V0cHV0KTsgXG5cbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsOyBcblxuICAgIHRoaXMubWF0aE9wcyA9IFt0aGlzLmNvbnRyb2xdOyBcblxuICAgIHRoaXMuaXNFeHBvbmVudGlhbCA9IGZhbHNlOyBcblxuICAgIHRoaXMuc291cmNlVG9DbGVhciA9IG51bGw7IFxuXG4gICAgdGhpcy53YXNUcmlnZ2VyZWQgPSBmYWxzZTsgXG5cbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTsgXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciB0ID0gbm93O1xuICAgIHRoaXMuY29udHJvbC5zZXRUYXJnZXRBdFRpbWUoMC4wMDAwMSwgdCwgLjAwMSk7IFxuXG4gICAgdGhpcy5fc2V0UmFtcEFEKHRoaXMuYVRpbWUsIHRoaXMuZFRpbWUpO1xuICB9O1xuICAvKipcbiAgICogIFJlc2V0IHRoZSBlbnZlbG9wZSB3aXRoIGEgc2VyaWVzIG9mIHRpbWUvdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRcbiAgICogIEBmb3IgcDUuRW52ZWxvcGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBhdHRhY2tUaW1lICAgICBUaW1lIChpbiBzZWNvbmRzKSBiZWZvcmUgbGV2ZWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFjaGVzIGF0dGFja0xldmVsXG4gICAqICBAcGFyYW0ge051bWJlcn0gYXR0YWNrTGV2ZWwgICAgVHlwaWNhbGx5IGFuIGFtcGxpdHVkZSBiZXR3ZWVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wIGFuZCAxLjBcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBkZWNheVRpbWUgICAgICBUaW1lXG4gICAqICBAcGFyYW0ge051bWJlcn0gZGVjYXlMZXZlbCAgIEFtcGxpdHVkZSAoSW4gYSBzdGFuZGFyZCBBRFNSIGVudmVsb3BlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2F5TGV2ZWwgPSBzdXN0YWluTGV2ZWwpXG4gICAqICBAcGFyYW0ge051bWJlcn0gcmVsZWFzZVRpbWUgICBSZWxlYXNlIFRpbWUgKGluIHNlY29uZHMpXG4gICAqICBAcGFyYW0ge051bWJlcn0gcmVsZWFzZUxldmVsICBBbXBsaXR1ZGVcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGF0dGFja1RpbWU7XG4gICAqICBsZXQgbDEgPSAwLjc7IC8vIGF0dGFjayBsZXZlbCAwLjAgdG8gMS4wXG4gICAqICBsZXQgdDIgPSAwLjM7IC8vIGRlY2F5IHRpbWUgaW4gc2Vjb25kc1xuICAgKiAgbGV0IGwyID0gMC4xOyAvLyBkZWNheSBsZXZlbCAgMC4wIHRvIDEuMFxuICAgKiAgbGV0IGwzID0gMC4yOyAvLyByZWxlYXNlIHRpbWUgaW4gc2Vjb25kc1xuICAgKlxuICAgKiAgbGV0IGVudiwgdHJpT3NjO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTb3VuZCk7XG4gICAqXG4gICAqICAgIGVudiA9IG5ldyBwNS5FbnZlbG9wZSgpO1xuICAgKiAgICB0cmlPc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigndHJpYW5nbGUnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIGhlcmUgdG8gcGxheScsIDUsIDIwKTtcbiAgICpcbiAgICogICAgYXR0YWNrVGltZSA9IG1hcChtb3VzZVgsIDAsIHdpZHRoLCAwLjAsIDEuMCk7XG4gICAqICAgIHRleHQoJ2F0dGFjayB0aW1lOiAnICsgYXR0YWNrVGltZSwgNSwgaGVpZ2h0IC0gMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgLy8gbW91c2VDbGljayB0cmlnZ2VycyBlbnZlbG9wZSBpZiBvdmVyIGNhbnZhc1xuICAgKiAgZnVuY3Rpb24gcGxheVNvdW5kKCkge1xuICAgKiAgICBlbnYuc2V0KGF0dGFja1RpbWUsIGwxLCB0MiwgbDIsIGwzKTtcbiAgICpcbiAgICogICAgdHJpT3NjLnN0YXJ0KCk7XG4gICAqICAgIGVudi5wbGF5KHRyaU9zYyk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqXG4gICAqL1xuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0MSwgbDEsIHQyLCBsMiwgdDMsIGwzKSB7XG4gICAgdGhpcy5hVGltZSA9IHQxO1xuICAgIHRoaXMuYUxldmVsID0gbDE7XG4gICAgdGhpcy5kVGltZSA9IHQyIHx8IDA7XG4gICAgdGhpcy5kTGV2ZWwgPSBsMiB8fCAwO1xuICAgIHRoaXMuclRpbWUgPSB0MyB8fCAwO1xuICAgIHRoaXMuckxldmVsID0gbDMgfHwgMDsgXG5cbiAgICB0aGlzLl9zZXRSYW1wQUQodDEsIHQyKTtcbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdmFsdWVzIGxpa2UgYSB0cmFkaXRpb25hbFxuICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bnRoZXNpemVyIy9tZWRpYS9GaWxlOkFEU1JfcGFyYW1ldGVyLnN2Z1wiPlxuICAgKiAgQURTUiBlbnZlbG9wZVxuICAgKiAgPC9hPi5cbiAgICpcbiAgICogIEBtZXRob2QgIHNldEFEU1JcbiAgICogIEBmb3IgcDUuRW52ZWxvcGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBhdHRhY2tUaW1lICAgIFRpbWUgKGluIHNlY29uZHMgYmVmb3JlIGVudmVsb3BlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFjaGVzIEF0dGFjayBMZXZlbFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtkZWNheVRpbWVdICAgIFRpbWUgKGluIHNlY29uZHMpIGJlZm9yZSBlbnZlbG9wZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhY2hlcyBEZWNheS9TdXN0YWluIExldmVsXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3N1c1JhdGlvXSAgICBSYXRpbyBiZXR3ZWVuIGF0dGFja0xldmVsIGFuZCByZWxlYXNlTGV2ZWwsIG9uIGEgc2NhbGUgZnJvbSAwIHRvIDEsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSAxLjAgPSBhdHRhY2tMZXZlbCwgMC4wID0gcmVsZWFzZUxldmVsLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHN1c1JhdGlvIGRldGVybWluZXMgdGhlIGRlY2F5TGV2ZWwgYW5kIHRoZSBsZXZlbCBhdCB3aGljaCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3RhaW4gcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUgd2lsbCBzdXN0YWluLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUsIGlmIGF0dGFja0xldmVsIGlzIDAuNCwgcmVsZWFzZUxldmVsIGlzIDAsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc3VzQW10IGlzIDAuNSwgdGhlIGRlY2F5TGV2ZWwgd291bGQgYmUgMC4yLiBJZiBhdHRhY2tMZXZlbCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVhc2VkIHRvIDEuMCAodXNpbmcgPGNvZGU+c2V0UmFuZ2U8L2NvZGU+KSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gZGVjYXlMZXZlbCB3b3VsZCBpbmNyZWFzZSBwcm9wb3J0aW9uYWxseSwgdG8gYmVjb21lIDAuNS5cbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbcmVsZWFzZVRpbWVdICAgVGltZSBpbiBzZWNvbmRzIGZyb20gbm93IChkZWZhdWx0cyB0byAwKVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgYXR0YWNrTGV2ZWwgPSAxLjA7XG4gICAqICBsZXQgcmVsZWFzZUxldmVsID0gMDtcbiAgICpcbiAgICogIGxldCBhdHRhY2tUaW1lID0gMC4wMDE7XG4gICAqICBsZXQgZGVjYXlUaW1lID0gMC4yO1xuICAgKiAgbGV0IHN1c1BlcmNlbnQgPSAwLjI7XG4gICAqICBsZXQgcmVsZWFzZVRpbWUgPSAwLjU7XG4gICAqXG4gICAqICBsZXQgZW52LCB0cmlPc2M7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheUVudik7XG4gICAqXG4gICAqICAgIGVudiA9IG5ldyBwNS5FbnZlbG9wZSgpO1xuICAgKiAgICB0cmlPc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigndHJpYW5nbGUnKTtcbiAgICogICAgdHJpT3NjLmFtcChlbnYpO1xuICAgKiAgICB0cmlPc2MuZnJlcSgyMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgaGVyZSB0byBwbGF5JywgNSwgMjApO1xuICAgKiAgICBhdHRhY2tUaW1lID0gbWFwKG1vdXNlWCwgMCwgd2lkdGgsIDAsIDEuMCk7XG4gICAqICAgIHRleHQoJ2F0dGFjayB0aW1lOiAnICsgYXR0YWNrVGltZSwgNSwgaGVpZ2h0IC0gNDApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheUVudigpIHtcbiAgICogICAgdHJpT3NjLnN0YXJ0KCk7XG4gICAqICAgIGVudi5zZXRBRFNSKGF0dGFja1RpbWUsIGRlY2F5VGltZSwgc3VzUGVyY2VudCwgcmVsZWFzZVRpbWUpO1xuICAgKiAgICBlbnYucGxheSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5zZXRBRFNSID0gZnVuY3Rpb24gKGFUaW1lLCBkVGltZSwgc1BlcmNlbnQsIHJUaW1lKSB7XG4gICAgdGhpcy5hVGltZSA9IGFUaW1lO1xuICAgIHRoaXMuZFRpbWUgPSBkVGltZSB8fCAwOyBcblxuICAgIHRoaXMuc1BlcmNlbnQgPSBzUGVyY2VudCB8fCAwO1xuICAgIHRoaXMuZExldmVsID0gdHlwZW9mIHNQZXJjZW50ICE9PSAndW5kZWZpbmVkJyA/IHNQZXJjZW50ICogKHRoaXMuYUxldmVsIC0gdGhpcy5yTGV2ZWwpICsgdGhpcy5yTGV2ZWwgOiAwO1xuICAgIHRoaXMuclRpbWUgPSByVGltZSB8fCAwOyBcblxuICAgIHRoaXMuX3NldFJhbXBBRChhVGltZSwgZFRpbWUpO1xuICB9O1xuICAvKipcbiAgICogIFNldCBtYXggKGF0dGFja0xldmVsKSBhbmQgbWluIChyZWxlYXNlTGV2ZWwpIG9mIGVudmVsb3BlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0UmFuZ2VcbiAgICogIEBmb3IgcDUuRW52ZWxvcGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBhTGV2ZWwgYXR0YWNrIGxldmVsIChkZWZhdWx0cyB0byAxKVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IHJMZXZlbCByZWxlYXNlIGxldmVsIChkZWZhdWx0cyB0byAwKVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgYXR0YWNrTGV2ZWwgPSAxLjA7XG4gICAqICBsZXQgcmVsZWFzZUxldmVsID0gMDtcbiAgICpcbiAgICogIGxldCBhdHRhY2tUaW1lID0gMC4wMDE7XG4gICAqICBsZXQgZGVjYXlUaW1lID0gMC4yO1xuICAgKiAgbGV0IHN1c1BlcmNlbnQgPSAwLjI7XG4gICAqICBsZXQgcmVsZWFzZVRpbWUgPSAwLjU7XG4gICAqXG4gICAqICBsZXQgZW52LCB0cmlPc2M7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheUVudik7XG4gICAqXG4gICAqICAgIGVudiA9IG5ldyBwNS5FbnZlbG9wZSgpO1xuICAgKiAgICB0cmlPc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigndHJpYW5nbGUnKTtcbiAgICogICAgdHJpT3NjLmFtcChlbnYpO1xuICAgKiAgICB0cmlPc2MuZnJlcSgyMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgaGVyZSB0byBwbGF5JywgNSwgMjApO1xuICAgKiAgICBhdHRhY2tMZXZlbCA9IG1hcChtb3VzZVksIGhlaWdodCwgMCwgMCwgMS4wKTtcbiAgICogICAgdGV4dCgnYXR0YWNrIGxldmVsOiAnICsgYXR0YWNrTGV2ZWwsIDUsIGhlaWdodCAtIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlFbnYoKSB7XG4gICAqICAgIHRyaU9zYy5zdGFydCgpO1xuICAgKiAgICBlbnYuc2V0UmFuZ2UoYXR0YWNrTGV2ZWwsIHJlbGVhc2VMZXZlbCk7XG4gICAqICAgIGVudi5wbGF5KCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24gKGFMZXZlbCwgckxldmVsKSB7XG4gICAgdGhpcy5hTGV2ZWwgPSBhTGV2ZWwgfHwgMTtcbiAgICB0aGlzLnJMZXZlbCA9IHJMZXZlbCB8fCAwOyBcbiAgfTsgXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuX3NldFJhbXBBRCA9IGZ1bmN0aW9uICh0MSwgdDIpIHtcbiAgICB0aGlzLl9yYW1wQXR0YWNrVGltZSA9IHRoaXMuY2hlY2tFeHBJbnB1dCh0MSk7XG4gICAgdGhpcy5fcmFtcERlY2F5VGltZSA9IHRoaXMuY2hlY2tFeHBJbnB1dCh0Mik7XG4gICAgdmFyIFRDRGVub21pbmF0b3IgPSAxLjA7IFxuXG4gICAgVENEZW5vbWluYXRvciA9IE1hdGgubG9nKDEuMCAvIHRoaXMuY2hlY2tFeHBJbnB1dCgxLjAgLSB0aGlzLl9yYW1wSGlnaFBlcmNlbnRhZ2UpKTtcbiAgICB0aGlzLl9yYW1wQXR0YWNrVEMgPSB0MSAvIHRoaXMuY2hlY2tFeHBJbnB1dChUQ0Rlbm9taW5hdG9yKTtcbiAgICBUQ0Rlbm9taW5hdG9yID0gTWF0aC5sb2coMS4wIC8gdGhpcy5fcmFtcExvd1BlcmNlbnRhZ2UpO1xuICAgIHRoaXMuX3JhbXBEZWNheVRDID0gdDIgLyB0aGlzLmNoZWNrRXhwSW5wdXQoVENEZW5vbWluYXRvcik7XG4gIH07IFxuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLnNldFJhbXBQZXJjZW50YWdlcyA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICB0aGlzLl9yYW1wSGlnaFBlcmNlbnRhZ2UgPSB0aGlzLmNoZWNrRXhwSW5wdXQocDEpO1xuICAgIHRoaXMuX3JhbXBMb3dQZXJjZW50YWdlID0gdGhpcy5jaGVja0V4cElucHV0KHAyKTtcbiAgICB2YXIgVENEZW5vbWluYXRvciA9IDEuMDsgXG5cbiAgICBUQ0Rlbm9taW5hdG9yID0gTWF0aC5sb2coMS4wIC8gdGhpcy5jaGVja0V4cElucHV0KDEuMCAtIHRoaXMuX3JhbXBIaWdoUGVyY2VudGFnZSkpO1xuICAgIHRoaXMuX3JhbXBBdHRhY2tUQyA9IHRoaXMuX3JhbXBBdHRhY2tUaW1lIC8gdGhpcy5jaGVja0V4cElucHV0KFRDRGVub21pbmF0b3IpO1xuICAgIFRDRGVub21pbmF0b3IgPSBNYXRoLmxvZygxLjAgLyB0aGlzLl9yYW1wTG93UGVyY2VudGFnZSk7XG4gICAgdGhpcy5fcmFtcERlY2F5VEMgPSB0aGlzLl9yYW1wRGVjYXlUaW1lIC8gdGhpcy5jaGVja0V4cElucHV0KFRDRGVub21pbmF0b3IpO1xuICB9O1xuICAvKipcbiAgICogIEFzc2lnbiBhIHBhcmFtZXRlciB0byBiZSBjb250cm9sbGVkIGJ5IHRoaXMgZW52ZWxvcGUuXG4gICAqICBJZiBhIHA1LlNvdW5kIG9iamVjdCBpcyBnaXZlbiwgdGhlbiB0aGUgcDUuRW52ZWxvcGUgd2lsbCBjb250cm9sIGl0c1xuICAgKiAgb3V0cHV0IGdhaW4uIElmIG11bHRpcGxlIGlucHV0cyBhcmUgcHJvdmlkZWQsIHRoZSBlbnYgd2lsbFxuICAgKiAgY29udHJvbCBhbGwgb2YgdGhlbS5cbiAgICpcbiAgICogIEBtZXRob2QgIHNldElucHV0XG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IFsuLi5pbnB1dHNdICAgICAgICAgQSBwNS5zb3VuZCBvYmplY3Qgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYiBBdWRpbyBQYXJhbS5cbiAgICovXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuY29ubmVjdChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgd2hldGhlciB0aGUgZW52ZWxvcGUgcmFtcCBpcyBsaW5lYXIgKGRlZmF1bHQpIG9yIGV4cG9uZW50aWFsLlxuICAgKiAgRXhwb25lbnRpYWwgcmFtcHMgY2FuIGJlIHVzZWZ1bCBiZWNhdXNlIHdlIHBlcmNlaXZlIGFtcGxpdHVkZVxuICAgKiAgYW5kIGZyZXF1ZW5jeSBsb2dhcml0aG1pY2FsbHkuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRFeHBcbiAgICogIEBmb3IgcDUuRW52ZWxvcGVcbiAgICogIEBwYXJhbSB7Qm9vbGVhbn0gaXNFeHAgdHJ1ZSBpcyBleHBvbmVudGlhbCwgZmFsc2UgaXMgbGluZWFyXG4gICAqL1xuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLnNldEV4cCA9IGZ1bmN0aW9uIChpc0V4cCkge1xuICAgIHRoaXMuaXNFeHBvbmVudGlhbCA9IGlzRXhwO1xuICB9OyBcblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5jaGVja0V4cElucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDw9IDApIHtcbiAgICAgIHZhbHVlID0gMC4wMDAwMDAwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiAgPHA+UGxheSB0ZWxscyB0aGUgZW52ZWxvcGUgdG8gc3RhcnQgYWN0aW5nIG9uIGEgZ2l2ZW4gaW5wdXQuXG4gICAqICBJZiB0aGUgaW5wdXQgaXMgYSBwNS5zb3VuZCBvYmplY3QgKGkuZS4gQXVkaW9JbiwgT3NjaWxsYXRvcixcbiAgICogIFNvdW5kRmlsZSksIHRoZW4gRW52ZWxvcGUgd2lsbCBjb250cm9sIGl0cyBvdXRwdXQgdm9sdW1lLlxuICAgKiAgRW52ZWxvcGVzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29udHJvbCBhbnkgPGEgaHJlZj1cIlxuICAgKiAgaHR0cDovL2RvY3Mud2VicGxhdGZvcm0ub3JnL3dpa2kvYXBpcy93ZWJhdWRpby9BdWRpb1BhcmFtXCI+XG4gICAqICBXZWIgQXVkaW8gQXVkaW8gUGFyYW0uPC9hPjwvcD5cbiAgICpcbiAgICogIEBtZXRob2QgIHBsYXlcbiAgICogIEBmb3IgcDUuRW52ZWxvcGVcbiAgICogIEBwYXJhbSAge09iamVjdH0gdW5pdCAgICAgICAgIEEgcDUuc291bmQgb2JqZWN0IG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWIgQXVkaW8gUGFyYW0uXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzdGFydFRpbWVdICB0aW1lIGZyb20gbm93IChpbiBzZWNvbmRzKSBhdCB3aGljaCB0byBwbGF5XG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzdXN0YWluVGltZV0gdGltZSB0byBzdXN0YWluIGJlZm9yZSByZWxlYXNpbmcgdGhlIGVudmVsb3BlXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBhdHRhY2tMZXZlbCA9IDEuMDtcbiAgICogIGxldCByZWxlYXNlTGV2ZWwgPSAwO1xuICAgKlxuICAgKiAgbGV0IGF0dGFja1RpbWUgPSAwLjAwMTtcbiAgICogIGxldCBkZWNheVRpbWUgPSAwLjI7XG4gICAqICBsZXQgc3VzUGVyY2VudCA9IDAuMjtcbiAgICogIGxldCByZWxlYXNlVGltZSA9IDAuNTtcbiAgICpcbiAgICogIGxldCBlbnYsIHRyaU9zYztcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5RW52KTtcbiAgICpcbiAgICogICAgZW52ID0gbmV3IHA1LkVudmVsb3BlKCk7XG4gICAqICAgIHRyaU9zYyA9IG5ldyBwNS5Pc2NpbGxhdG9yKCd0cmlhbmdsZScpO1xuICAgKiAgICB0cmlPc2MuYW1wKGVudik7XG4gICAqICAgIHRyaU9zYy5mcmVxKDIyMCk7XG4gICAqICAgIHRyaU9zYy5zdGFydCgpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgaGVyZSB0byBwbGF5JywgNSwgMjApO1xuICAgKiAgICBhdHRhY2tUaW1lID0gbWFwKG1vdXNlWCwgMCwgd2lkdGgsIDAsIDEuMCk7XG4gICAqICAgIGF0dGFja0xldmVsID0gbWFwKG1vdXNlWSwgaGVpZ2h0LCAwLCAwLCAxLjApO1xuICAgKiAgICB0ZXh0KCdhdHRhY2sgdGltZTogJyArIGF0dGFja1RpbWUsIDUsIGhlaWdodCAtIDQwKTtcbiAgICogICAgdGV4dCgnYXR0YWNrIGxldmVsOiAnICsgYXR0YWNrTGV2ZWwsIDUsIGhlaWdodCAtIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlFbnYoKSB7XG4gICAqICAgIC8vIGVuc3VyZSB0aGF0IGF1ZGlvIGlzIGVuYWJsZWRcbiAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICpcbiAgICogICAgZW52LnNldEFEU1IoYXR0YWNrVGltZSwgZGVjYXlUaW1lLCBzdXNQZXJjZW50LCByZWxlYXNlVGltZSk7XG4gICAqICAgIGVudi5zZXRSYW5nZShhdHRhY2tMZXZlbCwgcmVsZWFzZUxldmVsKTtcbiAgICogICAgZW52LnBsYXkoKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICh1bml0LCBzZWNvbmRzRnJvbU5vdywgc3VzVGltZSkge1xuICAgIHZhciB0RnJvbU5vdyA9IHNlY29uZHNGcm9tTm93IHx8IDA7XG4gICAgdmFyIHN1c1RpbWUgPSBzdXNUaW1lIHx8IDA7XG5cbiAgICBpZiAodW5pdCkge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiAhPT0gdW5pdCkge1xuICAgICAgICB0aGlzLmNvbm5lY3QodW5pdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyQXR0YWNrKHVuaXQsIHRGcm9tTm93KTtcbiAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKHVuaXQsIHRGcm9tTm93ICsgdGhpcy5hVGltZSArIHRoaXMuZFRpbWUgKyBzdXNUaW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqICBUcmlnZ2VyIHRoZSBBdHRhY2ssIGFuZCBEZWNheSBwb3J0aW9uIG9mIHRoZSBFbnZlbG9wZS5cbiAgICogIFNpbWlsYXIgdG8gaG9sZGluZyBkb3duIGEga2V5IG9uIGEgcGlhbm8sIGJ1dCBpdCB3aWxsXG4gICAqICBob2xkIHRoZSBzdXN0YWluIGxldmVsIHVudGlsIHlvdSBsZXQgZ28uIElucHV0IGNhbiBiZVxuICAgKiAgYW55IHA1LnNvdW5kIG9iamVjdCwgb3IgYSA8YSBocmVmPVwiXG4gICAqICBodHRwOi8vZG9jcy53ZWJwbGF0Zm9ybS5vcmcvd2lraS9hcGlzL3dlYmF1ZGlvL0F1ZGlvUGFyYW1cIj5cbiAgICogIFdlYiBBdWRpbyBQYXJhbTwvYT4uXG4gICAqXG4gICAqICBAbWV0aG9kICB0cmlnZ2VyQXR0YWNrXG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHVuaXQgcDUuc291bmQgT2JqZWN0IG9yIFdlYiBBdWRpbyBQYXJhbVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBzZWNvbmRzRnJvbU5vdyB0aW1lIGZyb20gbm93IChpbiBzZWNvbmRzKVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgYXR0YWNrVGltZSA9IDAuMDAxO1xuICAgKiAgbGV0IGRlY2F5VGltZSA9IDAuMjtcbiAgICogIGxldCBzdXNQZXJjZW50ID0gMC4zO1xuICAgKiAgbGV0IHJlbGVhc2VUaW1lID0gMC40O1xuICAgKiAgbGV0IGVudiwgdHJpT3NjO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHRBbGlnbihDRU5URVIpO1xuICAgKiAgICB0ZXh0U2l6ZSgxMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byB0cmlnZ2VyQXR0YWNrJywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKlxuICAgKiAgICBlbnYgPSBuZXcgcDUuRW52ZWxvcGUoKTtcbiAgICogICAgZW52LnNldEFEU1IoYXR0YWNrVGltZSwgZGVjYXlUaW1lLCBzdXNQZXJjZW50LCByZWxlYXNlVGltZSk7XG4gICAqICAgIGVudi5zZXRSYW5nZSgxLjAsIDAuMCk7XG4gICAqICAgIHRyaU9zYyA9IG5ldyBwNS5Pc2NpbGxhdG9yKCd0cmlhbmdsZScpO1xuICAgKiAgICB0cmlPc2MuZnJlcSgyMjApO1xuICAgKlxuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGVudkF0dGFjayk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBlbnZBdHRhY2soKSAge1xuICAgKiAgICBiYWNrZ3JvdW5kKDAsIDI1NSwgMjU1KTtcbiAgICogICAgdGV4dCgncmVsZWFzZSB0byByZWxlYXNlJywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKlxuICAgKiAgICAvLyBlbnN1cmVzIGF1ZGlvIGlzIGVuYWJsZWQuIFNlZSBhbHNvOiBgdXNlclN0YXJ0QXVkaW9gXG4gICAqICAgIHRyaU9zYy5zdGFydCgpO1xuICAgKlxuICAgKiAgICBlbnYudHJpZ2dlckF0dGFjayh0cmlPc2MpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gdHJpZ2dlckF0dGFjaycsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICpcbiAgICogICAgZW52LnRyaWdnZXJSZWxlYXNlKHRyaU9zYyk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAodW5pdCwgc2Vjb25kc0Zyb21Ob3cpIHtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIHRGcm9tTm93ID0gc2Vjb25kc0Zyb21Ob3cgfHwgMDtcbiAgICB2YXIgdCA9IG5vdyArIHRGcm9tTm93O1xuICAgIHRoaXMubGFzdEF0dGFjayA9IHQ7XG4gICAgdGhpcy53YXNUcmlnZ2VyZWQgPSB0cnVlO1xuXG4gICAgaWYgKHVuaXQpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gIT09IHVuaXQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KHVuaXQpO1xuICAgICAgfVxuICAgIH0gXG5cblxuICAgIHZhciB2YWxUb1NldCA9IHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KTtcblxuICAgIGlmICh0aGlzLmlzRXhwb25lbnRpYWwgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY29udHJvbC5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuY2hlY2tFeHBJbnB1dCh2YWxUb1NldCksIHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRyb2wubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsVG9TZXQsIHQpO1xuICAgIH0gXG5cblxuICAgIHQgKz0gdGhpcy5hVGltZTtcblxuICAgIGlmICh0aGlzLmlzRXhwb25lbnRpYWwgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY29udHJvbC5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuY2hlY2tFeHBJbnB1dCh0aGlzLmFMZXZlbCksIHQpO1xuICAgICAgdmFsVG9TZXQgPSB0aGlzLmNoZWNrRXhwSW5wdXQodGhpcy5jb250cm9sLmdldFZhbHVlQXRUaW1lKHQpKTtcbiAgICAgIHRoaXMuY29udHJvbC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModCk7XG4gICAgICB0aGlzLmNvbnRyb2wuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWxUb1NldCwgdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udHJvbC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmFMZXZlbCwgdCk7XG4gICAgICB2YWxUb1NldCA9IHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KTtcbiAgICAgIHRoaXMuY29udHJvbC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModCk7XG4gICAgICB0aGlzLmNvbnRyb2wubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsVG9TZXQsIHQpO1xuICAgIH0gXG5cblxuICAgIHQgKz0gdGhpcy5kVGltZTtcblxuICAgIGlmICh0aGlzLmlzRXhwb25lbnRpYWwgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY29udHJvbC5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuY2hlY2tFeHBJbnB1dCh0aGlzLmRMZXZlbCksIHQpO1xuICAgICAgdmFsVG9TZXQgPSB0aGlzLmNoZWNrRXhwSW5wdXQodGhpcy5jb250cm9sLmdldFZhbHVlQXRUaW1lKHQpKTtcbiAgICAgIHRoaXMuY29udHJvbC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModCk7XG4gICAgICB0aGlzLmNvbnRyb2wuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWxUb1NldCwgdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udHJvbC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmRMZXZlbCwgdCk7XG4gICAgICB2YWxUb1NldCA9IHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KTtcbiAgICAgIHRoaXMuY29udHJvbC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModCk7XG4gICAgICB0aGlzLmNvbnRyb2wubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsVG9TZXQsIHQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBUcmlnZ2VyIHRoZSBSZWxlYXNlIG9mIHRoZSBFbnZlbG9wZS4gVGhpcyBpcyBzaW1pbGFyIHRvIHJlbGVhc2luZ1xuICAgKiAgdGhlIGtleSBvbiBhIHBpYW5vIGFuZCBsZXR0aW5nIHRoZSBzb3VuZCBmYWRlIGFjY29yZGluZyB0byB0aGVcbiAgICogIHJlbGVhc2UgbGV2ZWwgYW5kIHJlbGVhc2UgdGltZS5cbiAgICpcbiAgICogIEBtZXRob2QgIHRyaWdnZXJSZWxlYXNlXG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHVuaXQgcDUuc291bmQgT2JqZWN0IG9yIFdlYiBBdWRpbyBQYXJhbVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBzZWNvbmRzRnJvbU5vdyB0aW1lIHRvIHRyaWdnZXIgdGhlIHJlbGVhc2VcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGF0dGFja1RpbWUgPSAwLjAwMTtcbiAgICogIGxldCBkZWNheVRpbWUgPSAwLjI7XG4gICAqICBsZXQgc3VzUGVyY2VudCA9IDAuMztcbiAgICogIGxldCByZWxlYXNlVGltZSA9IDAuNDtcbiAgICogIGxldCBlbnYsIHRyaU9zYztcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICogICAgdGV4dFNpemUoMTApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gdHJpZ2dlckF0dGFjaycsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICpcbiAgICogICAgZW52ID0gbmV3IHA1LkVudmVsb3BlKCk7XG4gICAqICAgIGVudi5zZXRBRFNSKGF0dGFja1RpbWUsIGRlY2F5VGltZSwgc3VzUGVyY2VudCwgcmVsZWFzZVRpbWUpO1xuICAgKiAgICBlbnYuc2V0UmFuZ2UoMS4wLCAwLjApO1xuICAgKiAgICB0cmlPc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigndHJpYW5nbGUnKTtcbiAgICogICAgdHJpT3NjLmZyZXEoMjIwKTtcbiAgICpcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChlbnZBdHRhY2spO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZW52QXR0YWNrKCkgIHtcbiAgICogICAgYmFja2dyb3VuZCgwLCAyNTUsIDI1NSk7XG4gICAqICAgIHRleHQoJ3JlbGVhc2UgdG8gcmVsZWFzZScsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICpcbiAgICogICAgLy8gZW5zdXJlcyBhdWRpbyBpcyBlbmFibGVkLiBTZWUgYWxzbzogYHVzZXJTdGFydEF1ZGlvYFxuICAgKiAgICB0cmlPc2Muc3RhcnQoKTtcbiAgICpcbiAgICogICAgZW52LnRyaWdnZXJBdHRhY2sodHJpT3NjKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIG1vdXNlUmVsZWFzZWQoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHRyaWdnZXJBdHRhY2snLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqXG4gICAqICAgIGVudi50cmlnZ2VyUmVsZWFzZSh0cmlPc2MpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uICh1bml0LCBzZWNvbmRzRnJvbU5vdykge1xuICAgIGlmICghdGhpcy53YXNUcmlnZ2VyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIHRGcm9tTm93ID0gc2Vjb25kc0Zyb21Ob3cgfHwgMDtcbiAgICB2YXIgdCA9IG5vdyArIHRGcm9tTm93O1xuXG4gICAgaWYgKHVuaXQpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gIT09IHVuaXQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KHVuaXQpO1xuICAgICAgfVxuICAgIH0gXG5cblxuICAgIHZhciB2YWxUb1NldCA9IHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KTtcblxuICAgIGlmICh0aGlzLmlzRXhwb25lbnRpYWwgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY29udHJvbC5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuY2hlY2tFeHBJbnB1dCh2YWxUb1NldCksIHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRyb2wubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsVG9TZXQsIHQpO1xuICAgIH0gXG5cblxuICAgIHQgKz0gdGhpcy5yVGltZTtcblxuICAgIGlmICh0aGlzLmlzRXhwb25lbnRpYWwgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY29udHJvbC5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuY2hlY2tFeHBJbnB1dCh0aGlzLnJMZXZlbCksIHQpO1xuICAgICAgdmFsVG9TZXQgPSB0aGlzLmNoZWNrRXhwSW5wdXQodGhpcy5jb250cm9sLmdldFZhbHVlQXRUaW1lKHQpKTtcbiAgICAgIHRoaXMuY29udHJvbC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModCk7XG4gICAgICB0aGlzLmNvbnRyb2wuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWxUb1NldCwgdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udHJvbC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLnJMZXZlbCwgdCk7XG4gICAgICB2YWxUb1NldCA9IHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KTtcbiAgICAgIHRoaXMuY29udHJvbC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModCk7XG4gICAgICB0aGlzLmNvbnRyb2wubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsVG9TZXQsIHQpO1xuICAgIH1cblxuICAgIHRoaXMud2FzVHJpZ2dlcmVkID0gZmFsc2U7XG4gIH07XG4gIC8qKlxuICAgKiAgRXhwb25lbnRpYWxseSByYW1wIHRvIGEgdmFsdWUgdXNpbmcgdGhlIGZpcnN0IHR3b1xuICAgKiAgdmFsdWVzIGZyb20gPGNvZGU+PGEgaHJlZj1cIiMvcDUuRW52ZWxvcGUvc2V0QURTUlwiPnNldEFEU1IoYXR0YWNrVGltZSwgZGVjYXlUaW1lKTwvYT48L2NvZGU+XG4gICAqICBhcyA8YSBocmVmPVwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUkNfdGltZV9jb25zdGFudFwiPlxuICAgKiAgdGltZSBjb25zdGFudHM8L2E+IGZvciBzaW1wbGUgZXhwb25lbnRpYWwgcmFtcHMuXG4gICAqICBJZiB0aGUgdmFsdWUgaXMgaGlnaGVyIHRoYW4gY3VycmVudCB2YWx1ZSwgaXQgdXNlcyBhdHRhY2tUaW1lLFxuICAgKiAgd2hpbGUgYSBkZWNyZWFzZSB1c2VzIGRlY2F5VGltZS5cbiAgICpcbiAgICogIEBtZXRob2QgIHJhbXBcbiAgICogIEBmb3IgcDUuRW52ZWxvcGVcbiAgICogIEBwYXJhbSAge09iamVjdH0gdW5pdCAgICAgICAgICAgcDUuc291bmQgT2JqZWN0IG9yIFdlYiBBdWRpbyBQYXJhbVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBzZWNvbmRzRnJvbU5vdyBXaGVuIHRvIHRyaWdnZXIgdGhlIHJhbXBcbiAgICogIEBwYXJhbSAge051bWJlcn0gdiAgICAgICAgICAgICAgVGFyZ2V0IHZhbHVlXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt2Ml0gICAgICAgICAgIFNlY29uZCB0YXJnZXQgdmFsdWUgKG9wdGlvbmFsKVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgZW52LCBvc2MsIGFtcDtcbiAgICpcbiAgICogIGxldCBhdHRhY2tUaW1lID0gMC4wMDE7XG4gICAqICBsZXQgZGVjYXlUaW1lID0gMC4yO1xuICAgKiAgbGV0IGF0dGFja0xldmVsID0gMTtcbiAgICogIGxldCBkZWNheUxldmVsID0gMDtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgZmlsbCgwLDI1NSwwKTtcbiAgICogICAgbm9TdHJva2UoKTtcbiAgICpcbiAgICogICAgZW52ID0gbmV3IHA1LkVudmVsb3BlKCk7XG4gICAqICAgIGVudi5zZXRBRFNSKGF0dGFja1RpbWUsIGRlY2F5VGltZSk7XG4gICAqICAgIG9zYyA9IG5ldyBwNS5Pc2NpbGxhdG9yKCk7XG4gICAqICAgIG9zYy5hbXAoZW52KTtcbiAgICogICAgYW1wID0gbmV3IHA1LkFtcGxpdHVkZSgpO1xuICAgKlxuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHRyaWdnZXJSYW1wKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHRyaWdnZXJSYW1wKCkge1xuICAgKiAgICAvLyBlbnN1cmVzIGF1ZGlvIGlzIGVuYWJsZWQuIFNlZSBhbHNvOiBgdXNlclN0YXJ0QXVkaW9gXG4gICAqICAgIG9zYy5zdGFydCgpO1xuICAgKlxuICAgKiAgICBlbnYucmFtcChvc2MsIDAsIGF0dGFja0xldmVsLCBkZWNheUxldmVsKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDEwLCAyMCk7XG4gICAqICAgIGxldCBoID0gbWFwKGFtcC5nZXRMZXZlbCgpLCAwLCAwLjQsIDAsIGhlaWdodCk7O1xuICAgKiAgICByZWN0KDAsIGhlaWdodCwgd2lkdGgsIC1oKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUucmFtcCA9IGZ1bmN0aW9uICh1bml0LCBzZWNvbmRzRnJvbU5vdywgdjEsIHYyKSB7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciB0RnJvbU5vdyA9IHNlY29uZHNGcm9tTm93IHx8IDA7XG4gICAgdmFyIHQgPSBub3cgKyB0RnJvbU5vdztcbiAgICB2YXIgZGVzdGluYXRpb24xID0gdGhpcy5jaGVja0V4cElucHV0KHYxKTtcbiAgICB2YXIgZGVzdGluYXRpb24yID0gdHlwZW9mIHYyICE9PSAndW5kZWZpbmVkJyA/IHRoaXMuY2hlY2tFeHBJbnB1dCh2MikgOiB1bmRlZmluZWQ7IFxuXG4gICAgaWYgKHVuaXQpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gIT09IHVuaXQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KHVuaXQpO1xuICAgICAgfVxuICAgIH0gXG5cblxuICAgIHZhciBjdXJyZW50VmFsID0gdGhpcy5jaGVja0V4cElucHV0KHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KSk7IFxuXG4gICAgaWYgKGRlc3RpbmF0aW9uMSA+IGN1cnJlbnRWYWwpIHtcbiAgICAgIHRoaXMuY29udHJvbC5zZXRUYXJnZXRBdFRpbWUoZGVzdGluYXRpb24xLCB0LCB0aGlzLl9yYW1wQXR0YWNrVEMpO1xuICAgICAgdCArPSB0aGlzLl9yYW1wQXR0YWNrVGltZTtcbiAgICB9IFxuICAgIGVsc2UgaWYgKGRlc3RpbmF0aW9uMSA8IGN1cnJlbnRWYWwpIHtcbiAgICAgICAgdGhpcy5jb250cm9sLnNldFRhcmdldEF0VGltZShkZXN0aW5hdGlvbjEsIHQsIHRoaXMuX3JhbXBEZWNheVRDKTtcbiAgICAgICAgdCArPSB0aGlzLl9yYW1wRGVjYXlUaW1lO1xuICAgICAgfSBcblxuXG4gICAgaWYgKGRlc3RpbmF0aW9uMiA9PT0gdW5kZWZpbmVkKSByZXR1cm47IFxuXG4gICAgaWYgKGRlc3RpbmF0aW9uMiA+IGRlc3RpbmF0aW9uMSkge1xuICAgICAgdGhpcy5jb250cm9sLnNldFRhcmdldEF0VGltZShkZXN0aW5hdGlvbjIsIHQsIHRoaXMuX3JhbXBBdHRhY2tUQyk7XG4gICAgfSBcbiAgICBlbHNlIGlmIChkZXN0aW5hdGlvbjIgPCBkZXN0aW5hdGlvbjEpIHtcbiAgICAgICAgdGhpcy5jb250cm9sLnNldFRhcmdldEF0VGltZShkZXN0aW5hdGlvbjIsIHQsIHRoaXMuX3JhbXBEZWNheVRDKTtcbiAgICAgIH1cbiAgfTtcblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gdW5pdDsgXG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIHA1Lk9zY2lsbGF0b3IgfHwgdW5pdCBpbnN0YW5jZW9mIHA1LlNvdW5kRmlsZSB8fCB1bml0IGluc3RhbmNlb2YgcDUuQXVkaW9JbiB8fCB1bml0IGluc3RhbmNlb2YgcDUuUmV2ZXJiIHx8IHVuaXQgaW5zdGFuY2VvZiBwNS5Ob2lzZSB8fCB1bml0IGluc3RhbmNlb2YgcDUuRmlsdGVyIHx8IHVuaXQgaW5zdGFuY2VvZiBwNS5EZWxheSkge1xuICAgICAgdW5pdCA9IHVuaXQub3V0cHV0LmdhaW47XG4gICAgfVxuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSB7XG4gICAgICB1bml0LnNldFZhbHVlQXRUaW1lKDAsIHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIHA1LlNpZ25hbCkge1xuICAgICAgdW5pdC5zZXRWYWx1ZSgwKTtcbiAgICB9XG5cbiAgICB0aGlzLm91dHB1dC5jb25uZWN0KHVuaXQpO1xuICB9O1xuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfTsgXG5cbiAgLyoqXG4gICAqICBBZGQgYSB2YWx1ZSB0byB0aGUgcDUuT3NjaWxsYXRvcidzIG91dHB1dCBhbXBsaXR1ZGUsXG4gICAqICBhbmQgcmV0dXJuIHRoZSBvc2NpbGxhdG9yLiBDYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqICBhZ2FpbiB3aWxsIG92ZXJyaWRlIHRoZSBpbml0aWFsIGFkZCgpIHdpdGggbmV3IHZhbHVlcy5cbiAgICpcbiAgICogIEBtZXRob2QgIGFkZFxuICAgKiAgQGZvciBwNS5FbnZlbG9wZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBDb25zdGFudCBudW1iZXIgdG8gYWRkXG4gICAqICBAcmV0dXJuIHtwNS5FbnZlbG9wZX0gRW52ZWxvcGUgUmV0dXJucyB0aGlzIGVudmVsb3BlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggc2NhbGVkIG91dHB1dFxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdmFyIGFkZCA9IG5ldyBBZGQobnVtKTtcbiAgICB2YXIgdGhpc0NoYWluID0gdGhpcy5tYXRoT3BzLmxlbmd0aDtcbiAgICB2YXIgbmV4dENoYWluID0gdGhpcy5vdXRwdXQ7XG4gICAgcmV0dXJuIHA1LnByb3RvdHlwZS5fbWF0aENoYWluKHRoaXMsIGFkZCwgdGhpc0NoYWluLCBuZXh0Q2hhaW4sIEFkZCk7XG4gIH07XG4gIC8qKlxuICAgKiAgTXVsdGlwbHkgdGhlIHA1LkVudmVsb3BlJ3Mgb3V0cHV0IGFtcGxpdHVkZVxuICAgKiAgYnkgYSBmaXhlZCB2YWx1ZS4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiAgYWdhaW4gd2lsbCBvdmVycmlkZSB0aGUgaW5pdGlhbCBtdWx0KCkgd2l0aCBuZXcgdmFsdWVzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbXVsdFxuICAgKiAgQGZvciBwNS5FbnZlbG9wZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBDb25zdGFudCBudW1iZXIgdG8gbXVsdGlwbHlcbiAgICogIEByZXR1cm4ge3A1LkVudmVsb3BlfSBFbnZlbG9wZSBSZXR1cm5zIHRoaXMgZW52ZWxvcGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBzY2FsZWQgb3V0cHV0XG4gICAqL1xuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLm11bHQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdmFyIG11bHQgPSBuZXcgTXVsdChudW0pO1xuICAgIHZhciB0aGlzQ2hhaW4gPSB0aGlzLm1hdGhPcHMubGVuZ3RoO1xuICAgIHZhciBuZXh0Q2hhaW4gPSB0aGlzLm91dHB1dDtcbiAgICByZXR1cm4gcDUucHJvdG90eXBlLl9tYXRoQ2hhaW4odGhpcywgbXVsdCwgdGhpc0NoYWluLCBuZXh0Q2hhaW4sIE11bHQpO1xuICB9O1xuICAvKipcbiAgICogIFNjYWxlIHRoaXMgZW52ZWxvcGUncyBhbXBsaXR1ZGUgdmFsdWVzIHRvIGEgZ2l2ZW5cbiAgICogIHJhbmdlLCBhbmQgcmV0dXJuIHRoZSBlbnZlbG9wZS4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiAgYWdhaW4gd2lsbCBvdmVycmlkZSB0aGUgaW5pdGlhbCBzY2FsZSgpIHdpdGggbmV3IHZhbHVlcy5cbiAgICpcbiAgICogIEBtZXRob2QgIHNjYWxlXG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IGluTWluICBpbnB1dCByYW5nZSBtaW51bXVtXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IGluTWF4ICBpbnB1dCByYW5nZSBtYXhpbXVtXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IG91dE1pbiBpbnB1dCByYW5nZSBtaW51bXVtXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IG91dE1heCBpbnB1dCByYW5nZSBtYXhpbXVtXG4gICAqICBAcmV0dXJuIHtwNS5FbnZlbG9wZX0gRW52ZWxvcGUgUmV0dXJucyB0aGlzIGVudmVsb3BlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggc2NhbGVkIG91dHB1dFxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4KSB7XG4gICAgdmFyIHNjYWxlID0gbmV3IFNjYWxlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgpO1xuICAgIHZhciB0aGlzQ2hhaW4gPSB0aGlzLm1hdGhPcHMubGVuZ3RoO1xuICAgIHZhciBuZXh0Q2hhaW4gPSB0aGlzLm91dHB1dDtcbiAgICByZXR1cm4gcDUucHJvdG90eXBlLl9tYXRoQ2hhaW4odGhpcywgc2NhbGUsIHRoaXNDaGFpbiwgbmV4dENoYWluLCBTY2FsZSk7XG4gIH07IFxuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gcDVzb3VuZC5zb3VuZEFycmF5LmluZGV4T2YodGhpcyk7XG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5kaXNjb25uZWN0KCk7XG5cbiAgICBpZiAodGhpcy5jb250cm9sKSB7XG4gICAgICB0aGlzLmNvbnRyb2wuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5jb250cm9sID0gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubWF0aE9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5tYXRoT3BzW2ldLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07IFxuXG5cbiAgcDUuRW52ID0gZnVuY3Rpb24gKHQxLCBsMSwgdDIsIGwyLCB0MywgbDMpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IHA1LkVudiBpcyBub3cgZGVwcmVjYXRlZCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLiAnICsgJ1BsZWFzZSB1c2UgdGhlIG5ldyBwNS5FbnZlbG9wZSBpbnN0ZWFkLicpO1xuICAgIHA1LkVudmVsb3BlLmNhbGwodGhpcywgdDEsIGwxLCB0MiwgbDIsIHQzLCBsMyk7XG4gIH07XG5cbiAgcDUuRW52LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocDUuRW52ZWxvcGUucHJvdG90eXBlKTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhIFB1bHNlIG9iamVjdCwgYW4gb3NjaWxsYXRvciB0aGF0IGltcGxlbWVudHNcbiAgICogIFB1bHNlIFdpZHRoIE1vZHVsYXRpb24uXG4gICAqICBUaGUgcHVsc2UgaXMgY3JlYXRlZCB3aXRoIHR3byBvc2NpbGxhdG9ycy5cbiAgICogIEFjY2VwdHMgYSBwYXJhbWV0ZXIgZm9yIGZyZXF1ZW5jeSwgYW5kIHRvIHNldCB0aGVcbiAgICogIHdpZHRoIGJldHdlZW4gdGhlIHB1bHNlcy4gU2VlIDxhIGhyZWY9XCJcbiAgICogIGh0dHA6Ly9wNWpzLm9yZy9yZWZlcmVuY2UvIy9wNS5Pc2NpbGxhdG9yXCI+XG4gICAqICA8Y29kZT5wNS5Pc2NpbGxhdG9yPC9jb2RlPiBmb3IgYSBmdWxsIGxpc3Qgb2YgbWV0aG9kcy5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5QdWxzZVxuICAgKiAgQGV4dGVuZHMgcDUuT3NjaWxsYXRvclxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyZXFdIEZyZXF1ZW5jeSBpbiBvc2NpbGxhdGlvbnMgcGVyIHNlY29uZCAoSHopXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3ddICAgIFdpZHRoIGJldHdlZW4gdGhlIHB1bHNlcyAoMCB0byAxLjAsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzIHRvIDApXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBwdWxzZTtcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChzdGFydFB1bHNlKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKlxuICAgKiAgICBwdWxzZSA9IG5ldyBwNS5QdWxzZSgpO1xuICAgKiAgICBwdWxzZS5hbXAoMC41KTtcbiAgICogICAgcHVsc2UuZnJlcSgyMjApO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gc3RhcnRQdWxzZSgpIHtcbiAgICogICAgcHVsc2Uuc3RhcnQoKTtcbiAgICogICAgcHVsc2UuYW1wKDAuNSwgMC4wMik7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICBwdWxzZS5hbXAoMCwgMC4yKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCA1LCAyMCwgd2lkdGggLSAyMCk7XG4gICAqICAgIGxldCB3ID0gbWFwKG1vdXNlWCwgMCwgd2lkdGgsIDAsIDEpO1xuICAgKiAgICB3ID0gY29uc3RyYWluKHcsIDAsIDEpO1xuICAgKiAgICBwdWxzZS53aWR0aCh3KTtcbiAgICogICAgdGV4dCgncHVsc2Ugd2lkdGg6ICcgKyB3LCA1LCBoZWlnaHQgLSAyMCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuUHVsc2UgPSBmdW5jdGlvbiAoZnJlcSwgdykge1xuICAgIHA1Lk9zY2lsbGF0b3IuY2FsbCh0aGlzLCBmcmVxLCAnc2F3dG9vdGgnKTsgXG5cbiAgICB0aGlzLncgPSB3IHx8IDA7IFxuXG4gICAgdGhpcy5vc2MyID0gbmV3IHA1LlNhd09zYyhmcmVxKTsgXG5cbiAgICB0aGlzLmROb2RlID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlRGVsYXkoKTsgXG5cbiAgICB0aGlzLmRjT2Zmc2V0ID0gY3JlYXRlRENPZmZzZXQoKTtcbiAgICB0aGlzLmRjR2FpbiA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLmRjT2Zmc2V0LmNvbm5lY3QodGhpcy5kY0dhaW4pO1xuICAgIHRoaXMuZGNHYWluLmNvbm5lY3QodGhpcy5vdXRwdXQpOyBcblxuICAgIHRoaXMuZiA9IGZyZXEgfHwgNDQwO1xuICAgIHZhciBtVyA9IHRoaXMudyAvIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWU7XG4gICAgdGhpcy5kTm9kZS5kZWxheVRpbWUudmFsdWUgPSBtVztcbiAgICB0aGlzLmRjR2Fpbi5nYWluLnZhbHVlID0gMS43ICogKDAuNSAtIHRoaXMudyk7IFxuXG4gICAgdGhpcy5vc2MyLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLm9zYzIucGFubmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLm9zYzIuYW1wKC0xKTsgXG5cbiAgICB0aGlzLm9zYzIub3V0cHV0LmNvbm5lY3QodGhpcy5kTm9kZSk7XG4gICAgdGhpcy5kTm9kZS5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICB0aGlzLm91dHB1dC5nYWluLnZhbHVlID0gMTtcbiAgICB0aGlzLm91dHB1dC5jb25uZWN0KHRoaXMucGFubmVyKTtcbiAgfTtcblxuICBwNS5QdWxzZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIHdpZHRoIG9mIGEgUHVsc2Ugb2JqZWN0IChhbiBvc2NpbGxhdG9yIHRoYXQgaW1wbGVtZW50c1xuICAgKiAgUHVsc2UgV2lkdGggTW9kdWxhdGlvbikuXG4gICAqXG4gICAqICBAbWV0aG9kICB3aWR0aFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aF0gICAgV2lkdGggYmV0d2VlbiB0aGUgcHVsc2VzICgwIHRvIDEuMCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgdG8gMClcbiAgICovXG5cbiAgcDUuUHVsc2UucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKHcpIHtcbiAgICBpZiAodHlwZW9mIHcgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodyA8PSAxLjAgJiYgdyA+PSAwLjApIHtcbiAgICAgICAgdGhpcy53ID0gdzsgXG5cbiAgICAgICAgdmFyIG1XID0gdGhpcy53IC8gdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZTtcbiAgICAgICAgdGhpcy5kTm9kZS5kZWxheVRpbWUudmFsdWUgPSBtVztcbiAgICAgIH1cblxuICAgICAgdGhpcy5kY0dhaW4uZ2Fpbi52YWx1ZSA9IDEuNyAqICgwLjUgLSB0aGlzLncpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3LmNvbm5lY3QodGhpcy5kTm9kZS5kZWxheVRpbWUpO1xuICAgICAgdmFyIHNpZyA9IG5ldyBwNS5TaWduYWxBZGQoLTAuNSk7XG4gICAgICBzaWcuc2V0SW5wdXQodyk7XG4gICAgICBzaWcgPSBzaWcubXVsdCgtMSk7XG4gICAgICBzaWcgPSBzaWcubXVsdCgxLjcpO1xuICAgICAgc2lnLmNvbm5lY3QodGhpcy5kY0dhaW4uZ2Fpbik7XG4gICAgfVxuICB9O1xuXG4gIHA1LlB1bHNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChmLCB0aW1lKSB7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHZhciBmcmVxID0gZiB8fCB0aGlzLmY7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMub3NjaWxsYXRvci50eXBlO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZShmcmVxLCBub3cpO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLnN0YXJ0KHQgKyBub3cpOyBcblxuICAgICAgdGhpcy5vc2MyLm9zY2lsbGF0b3IgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgICB0aGlzLm9zYzIub3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUoZnJlcSwgdCArIG5vdyk7XG4gICAgICB0aGlzLm9zYzIub3NjaWxsYXRvci50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMub3NjMi5vc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5vc2MyLm91dHB1dCk7XG4gICAgICB0aGlzLm9zYzIuc3RhcnQodCArIG5vdyk7XG4gICAgICB0aGlzLmZyZXFOb2RlID0gW3RoaXMub3NjaWxsYXRvci5mcmVxdWVuY3ksIHRoaXMub3NjMi5vc2NpbGxhdG9yLmZyZXF1ZW5jeV07IFxuXG4gICAgICB0aGlzLmRjT2Zmc2V0ID0gY3JlYXRlRENPZmZzZXQoKTtcbiAgICAgIHRoaXMuZGNPZmZzZXQuY29ubmVjdCh0aGlzLmRjR2Fpbik7XG4gICAgICB0aGlzLmRjT2Zmc2V0LnN0YXJ0KHQgKyBub3cpOyBcblxuICAgICAgaWYgKHRoaXMubW9kcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMubW9kcy5mcmVxdWVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1vZHMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5mcmVxTm9kZVswXSk7XG4gICAgICAgIHRoaXMubW9kcy5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLmZyZXFOb2RlWzFdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMub3NjMi5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcDUuUHVsc2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHZhciB0ID0gdGltZSB8fCAwO1xuICAgICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLnN0b3AodCArIG5vdyk7XG5cbiAgICAgIGlmICh0aGlzLm9zYzIub3NjaWxsYXRvcikge1xuICAgICAgICB0aGlzLm9zYzIub3NjaWxsYXRvci5zdG9wKHQgKyBub3cpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRjT2Zmc2V0LnN0b3AodCArIG5vdyk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMub3NjMi5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHA1LlB1bHNlLnByb3RvdHlwZS5mcmVxID0gZnVuY3Rpb24gKHZhbCwgcmFtcFRpbWUsIHRGcm9tTm93KSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmYgPSB2YWw7XG4gICAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICB2YXIgcmFtcFRpbWUgPSByYW1wVGltZSB8fCAwO1xuICAgICAgdmFyIHRGcm9tTm93ID0gdEZyb21Ob3cgfHwgMDtcbiAgICAgIHZhciBjdXJyZW50RnJlcSA9IHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWU7XG4gICAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhub3cpO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZShjdXJyZW50RnJlcSwgbm93ICsgdEZyb21Ob3cpO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdEZyb21Ob3cgKyByYW1wVGltZSArIG5vdyk7XG4gICAgICB0aGlzLm9zYzIub3NjaWxsYXRvci5mcmVxdWVuY3kuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKG5vdyk7XG4gICAgICB0aGlzLm9zYzIub3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUoY3VycmVudEZyZXEsIG5vdyArIHRGcm9tTm93KTtcbiAgICAgIHRoaXMub3NjMi5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdEZyb21Ob3cgKyByYW1wVGltZSArIG5vdyk7XG5cbiAgICAgIGlmICh0aGlzLmZyZXFNb2QpIHtcbiAgICAgICAgdGhpcy5mcmVxTW9kLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuZnJlcU1vZCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWwub3V0cHV0KSB7XG4gICAgICB2YWwub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHZhbC5vdXRwdXQuY29ubmVjdCh0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5KTtcbiAgICAgIHZhbC5vdXRwdXQuY29ubmVjdCh0aGlzLm9zYzIub3NjaWxsYXRvci5mcmVxdWVuY3kpO1xuICAgICAgdGhpcy5mcmVxTW9kID0gdmFsO1xuICAgIH1cbiAgfTsgXG5cblxuICBmdW5jdGlvbiBjcmVhdGVEQ09mZnNldCgpIHtcbiAgICB2YXIgYWMgPSBwNXNvdW5kLmF1ZGlvY29udGV4dDtcbiAgICB2YXIgYnVmZmVyID0gYWMuY3JlYXRlQnVmZmVyKDEsIDIwNDgsIGFjLnNhbXBsZVJhdGUpO1xuICAgIHZhciBkYXRhID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDQ4OyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSAxLjA7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlclNvdXJjZSA9IGFjLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgIGJ1ZmZlclNvdXJjZS5idWZmZXIgPSBidWZmZXI7XG4gICAgYnVmZmVyU291cmNlLmxvb3AgPSB0cnVlO1xuICAgIHJldHVybiBidWZmZXJTb3VyY2U7XG4gIH1cbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIC8qKlxuICAgKiAgTm9pc2UgaXMgYSB0eXBlIG9mIG9zY2lsbGF0b3IgdGhhdCBnZW5lcmF0ZXMgYSBidWZmZXIgd2l0aCByYW5kb20gdmFsdWVzLlxuICAgKlxuICAgKiAgQGNsYXNzIHA1Lk5vaXNlXG4gICAqICBAZXh0ZW5kcyBwNS5Pc2NpbGxhdG9yXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2Ygbm9pc2UgY2FuIGJlICd3aGl0ZScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgJ2Jyb3duJyBvciAncGluaycuXG4gICAqL1xuXG5cbiAgcDUuTm9pc2UgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBhc3NpZ25UeXBlO1xuICAgIHA1Lk9zY2lsbGF0b3IuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgdGhpcy5mO1xuICAgIGRlbGV0ZSB0aGlzLmZyZXE7XG4gICAgZGVsZXRlIHRoaXMub3NjaWxsYXRvcjtcblxuICAgIGlmICh0eXBlID09PSAnYnJvd24nKSB7XG4gICAgICBhc3NpZ25UeXBlID0gX2Jyb3duTm9pc2U7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAncGluaycpIHtcbiAgICAgIGFzc2lnblR5cGUgPSBfcGlua05vaXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25UeXBlID0gX3doaXRlTm9pc2U7XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgPSBhc3NpZ25UeXBlO1xuICB9O1xuXG4gIHA1Lk5vaXNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocDUuT3NjaWxsYXRvci5wcm90b3R5cGUpOyBcblxuICB2YXIgX3doaXRlTm9pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1ZmZlclNpemUgPSAyICogcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZTtcbiAgICB2YXIgd2hpdGVCdWZmZXIgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVCdWZmZXIoMSwgYnVmZmVyU2l6ZSwgcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgdmFyIG5vaXNlRGF0YSA9IHdoaXRlQnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJTaXplOyBpKyspIHtcbiAgICAgIG5vaXNlRGF0YVtpXSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICB9XG5cbiAgICB3aGl0ZUJ1ZmZlci50eXBlID0gJ3doaXRlJztcbiAgICByZXR1cm4gd2hpdGVCdWZmZXI7XG4gIH0oKTtcblxuICB2YXIgX3BpbmtOb2lzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnVmZmVyU2l6ZSA9IDIgKiBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlO1xuICAgIHZhciBwaW5rQnVmZmVyID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIGJ1ZmZlclNpemUsIHA1c291bmQuYXVkaW9jb250ZXh0LnNhbXBsZVJhdGUpO1xuICAgIHZhciBub2lzZURhdGEgPSBwaW5rQnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgIHZhciBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNjtcbiAgICBiMCA9IGIxID0gYjIgPSBiMyA9IGI0ID0gYjUgPSBiNiA9IDAuMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgd2hpdGUgPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICBiMCA9IDAuOTk4ODYgKiBiMCArIHdoaXRlICogMC4wNTU1MTc5O1xuICAgICAgYjEgPSAwLjk5MzMyICogYjEgKyB3aGl0ZSAqIDAuMDc1MDc1OTtcbiAgICAgIGIyID0gMC45NjkwMCAqIGIyICsgd2hpdGUgKiAwLjE1Mzg1MjA7XG4gICAgICBiMyA9IDAuODY2NTAgKiBiMyArIHdoaXRlICogMC4zMTA0ODU2O1xuICAgICAgYjQgPSAwLjU1MDAwICogYjQgKyB3aGl0ZSAqIDAuNTMyOTUyMjtcbiAgICAgIGI1ID0gLTAuNzYxNiAqIGI1IC0gd2hpdGUgKiAwLjAxNjg5ODA7XG4gICAgICBub2lzZURhdGFbaV0gPSBiMCArIGIxICsgYjIgKyBiMyArIGI0ICsgYjUgKyBiNiArIHdoaXRlICogMC41MzYyO1xuICAgICAgbm9pc2VEYXRhW2ldICo9IDAuMTE7IFxuXG4gICAgICBiNiA9IHdoaXRlICogMC4xMTU5MjY7XG4gICAgfVxuXG4gICAgcGlua0J1ZmZlci50eXBlID0gJ3BpbmsnO1xuICAgIHJldHVybiBwaW5rQnVmZmVyO1xuICB9KCk7XG5cbiAgdmFyIF9icm93bk5vaXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBidWZmZXJTaXplID0gMiAqIHA1c291bmQuYXVkaW9jb250ZXh0LnNhbXBsZVJhdGU7XG4gICAgdmFyIGJyb3duQnVmZmVyID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIGJ1ZmZlclNpemUsIHA1c291bmQuYXVkaW9jb250ZXh0LnNhbXBsZVJhdGUpO1xuICAgIHZhciBub2lzZURhdGEgPSBicm93bkJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICB2YXIgbGFzdE91dCA9IDAuMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgd2hpdGUgPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICBub2lzZURhdGFbaV0gPSAobGFzdE91dCArIDAuMDIgKiB3aGl0ZSkgLyAxLjAyO1xuICAgICAgbGFzdE91dCA9IG5vaXNlRGF0YVtpXTtcbiAgICAgIG5vaXNlRGF0YVtpXSAqPSAzLjU7XG4gICAgfVxuXG4gICAgYnJvd25CdWZmZXIudHlwZSA9ICdicm93bic7XG4gICAgcmV0dXJuIGJyb3duQnVmZmVyO1xuICB9KCk7XG4gIC8qKlxuICAgKiAgU2V0IHR5cGUgb2Ygbm9pc2UgdG8gJ3doaXRlJywgJ3BpbmsnIG9yICdicm93bicuXG4gICAqICBXaGl0ZSBpcyB0aGUgZGVmYXVsdC5cbiAgICpcbiAgICogIEBtZXRob2Qgc2V0VHlwZVxuICAgKiAgQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAnd2hpdGUnLCAncGluaycgb3IgJ2Jyb3duJ1xuICAgKi9cblxuXG4gIHA1Lk5vaXNlLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3doaXRlJzpcbiAgICAgICAgdGhpcy5idWZmZXIgPSBfd2hpdGVOb2lzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BpbmsnOlxuICAgICAgICB0aGlzLmJ1ZmZlciA9IF9waW5rTm9pc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdicm93bic6XG4gICAgICAgIHRoaXMuYnVmZmVyID0gX2Jyb3duTm9pc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmJ1ZmZlciA9IF93aGl0ZU5vaXNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RvcChub3cpO1xuICAgICAgdGhpcy5zdGFydChub3cgKyAuMDEpO1xuICAgIH1cbiAgfTtcblxuICBwNS5Ob2lzZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIudHlwZTtcbiAgfTtcblxuICBwNS5Ob2lzZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ub2lzZSA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgIHRoaXMubm9pc2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgdGhpcy5ub2lzZS5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLm5vaXNlLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB0aGlzLm5vaXNlLnN0YXJ0KG5vdyk7XG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgfTtcblxuICBwNS5Ob2lzZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG5cbiAgICBpZiAodGhpcy5ub2lzZSkge1xuICAgICAgdGhpcy5ub2lzZS5zdG9wKG5vdyk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcDUuTm9pc2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lOyBcblxuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgaWYgKHRoaXMubm9pc2UpIHtcbiAgICAgIHRoaXMubm9pc2UuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5zdG9wKG5vdyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFubmVyKSB7XG4gICAgICB0aGlzLnBhbm5lci5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5vdXRwdXQgPSBudWxsO1xuICAgIHRoaXMucGFubmVyID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5ub2lzZSA9IG51bGw7XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpOyBcblxuXG4gIHA1c291bmQuaW5wdXRTb3VyY2VzID0gW107XG4gIC8qKlxuICAgKiAgPHA+R2V0IGF1ZGlvIGZyb20gYW4gaW5wdXQsIGkuZS4geW91ciBjb21wdXRlcidzIG1pY3JvcGhvbmUuPC9wPlxuICAgKlxuICAgKiAgPHA+VHVybiB0aGUgbWljIG9uL29mZiB3aXRoIHRoZSBzdGFydCgpIGFuZCBzdG9wKCkgbWV0aG9kcy4gV2hlbiB0aGUgbWljXG4gICAqICBpcyBvbiwgaXRzIHZvbHVtZSBjYW4gYmUgbWVhc3VyZWQgd2l0aCBnZXRMZXZlbCBvciBieSBjb25uZWN0aW5nIGFuXG4gICAqICBGRlQgb2JqZWN0LjwvcD5cbiAgICpcbiAgICogIDxwPklmIHlvdSB3YW50IHRvIGhlYXIgdGhlIEF1ZGlvSW4sIHVzZSB0aGUgLmNvbm5lY3QoKSBtZXRob2QuXG4gICAqICBBdWRpb0luIGRvZXMgbm90IGNvbm5lY3QgdG8gcDUuc291bmQgb3V0cHV0IGJ5IGRlZmF1bHQgdG8gcHJldmVudFxuICAgKiAgZmVlZGJhY2suPC9wPlxuICAgKlxuICAgKiAgPHA+PGVtPk5vdGU6IFRoaXMgdXNlcyB0aGUgPGEgaHJlZj1cImh0dHA6Ly9jYW5pdXNlLmNvbS9zdHJlYW1cIj5nZXRVc2VyTWVkaWEvXG4gICAqICBTdHJlYW08L2E+IEFQSSwgd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBieSBjZXJ0YWluIGJyb3dzZXJzLiBBY2Nlc3MgaW4gQ2hyb21lIGJyb3dzZXJcbiAgICogIGlzIGxpbWl0ZWQgdG8gbG9jYWxob3N0IGFuZCBodHRwcywgYnV0IGFjY2VzcyBvdmVyIGh0dHAgbWF5IGJlIGxpbWl0ZWQuPC9lbT48L3A+XG4gICAqXG4gICAqICBAY2xhc3MgcDUuQXVkaW9JblxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JDYWxsYmFja10gQSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoZXJlIGlzIGFuIGVycm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzaW5nIHRoZSBBdWRpb0luLiBGb3IgZXhhbXBsZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTYWZhcmkgYW5kIGlPUyBkZXZpY2VzIGRvIG5vdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseSBhbGxvdyBtaWNyb3Bob25lIGFjY2Vzcy5cbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IG1pYztcbiAgICpcbiAgICogICBmdW5jdGlvbiBzZXR1cCgpe1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZCh1c2VyU3RhcnRBdWRpbyk7XG4gICAqICAgIHRleHRBbGlnbihDRU5URVIpO1xuICAgKiAgICBtaWMgPSBuZXcgcDUuQXVkaW9JbigpO1xuICAgKiAgICBtaWMuc3RhcnQoKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKXtcbiAgICogICAgYmFja2dyb3VuZCgwKTtcbiAgICogICAgZmlsbCgyNTUpO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gc3RhcnQnLCB3aWR0aC8yLCAyMCk7XG4gICAqXG4gICAqICAgIG1pY0xldmVsID0gbWljLmdldExldmVsKCk7XG4gICAqICAgIGxldCB5ID0gaGVpZ2h0IC0gbWljTGV2ZWwgKiBoZWlnaHQ7XG4gICAqICAgIGVsbGlwc2Uod2lkdGgvMiwgeSwgMTAsIDEwKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cbiAgcDUuQXVkaW9JbiA9IGZ1bmN0aW9uIChlcnJvckNhbGxiYWNrKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0dhaW5Ob2RlfSBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuaW5wdXQgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtHYWluTm9kZX0gb3V0cHV0XG4gICAgICovXG5cbiAgICB0aGlzLm91dHB1dCA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01lZGlhU3RyZWFtfG51bGx9IHN0cmVhbVxuICAgICAqL1xuXG4gICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGV8bnVsbH0gbWVkaWFTdHJlYW1cbiAgICAgKi9cblxuICAgIHRoaXMubWVkaWFTdHJlYW0gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IGN1cnJlbnRTb3VyY2VcbiAgICAgKi9cblxuICAgIHRoaXMuY3VycmVudFNvdXJjZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogIENsaWVudCBtdXN0IGFsbG93IGJyb3dzZXIgdG8gYWNjZXNzIHRoZWlyIG1pY3JvcGhvbmUgLyBhdWRpb2luIHNvdXJjZS5cbiAgICAgKiAgRGVmYXVsdDogZmFsc2UuIFdpbGwgYmVjb21lIHRydWUgd2hlbiB0aGUgY2xpZW50IGVuYWJsZXMgYWNjZXNzLlxuICAgICAqXG4gICAgICogIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqL1xuXG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogSW5wdXQgYW1wbGl0dWRlLCBjb25uZWN0IHRvIGl0IGJ5IGRlZmF1bHQgYnV0IG5vdCB0byBtYXN0ZXIgb3V0XG4gICAgICpcbiAgICAgKiAgQHByb3BlcnR5IHtwNS5BbXBsaXR1ZGV9IGFtcGxpdHVkZVxuICAgICAqL1xuXG4gICAgdGhpcy5hbXBsaXR1ZGUgPSBuZXcgcDUuQW1wbGl0dWRlKCk7XG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh0aGlzLmFtcGxpdHVkZS5pbnB1dCk7XG5cbiAgICBpZiAoIXdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrIHx8ICF3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyB8fCAhd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgICBlcnJvckNhbGxiYWNrID8gZXJyb3JDYWxsYmFjaygpIDogd2luZG93LmFsZXJ0KCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNZWRpYVN0cmVhbVRyYWNrIGFuZCBtZWRpYURldmljZXMnKTtcbiAgICB9IFxuXG5cbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqICBTdGFydCBwcm9jZXNzaW5nIGF1ZGlvIGlucHV0LiBUaGlzIGVuYWJsZXMgdGhlIHVzZSBvZiBvdGhlclxuICAgKiAgQXVkaW9JbiBtZXRob2RzIGxpa2UgZ2V0TGV2ZWwoKS4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQsIEF1ZGlvSW5cbiAgICogIGlzIG5vdCBjb25uZWN0ZWQgdG8gcDUuc291bmQncyBvdXRwdXQuIFNvIHlvdSB3b24ndCBoZWFyXG4gICAqICBhbnl0aGluZyB1bmxlc3MgeW91IHVzZSB0aGUgY29ubmVjdCgpIG1ldGhvZC48YnIvPlxuICAgKlxuICAgKiAgQ2VydGFpbiBicm93c2VycyBsaW1pdCBhY2Nlc3MgdG8gdGhlIHVzZXIncyBtaWNyb3Bob25lLiBGb3IgZXhhbXBsZSxcbiAgICogIENocm9tZSBvbmx5IGFsbG93cyBhY2Nlc3MgZnJvbSBsb2NhbGhvc3QgYW5kIG92ZXIgaHR0cHMuIEZvciB0aGlzIHJlYXNvbixcbiAgICogIHlvdSBtYXkgd2FudCB0byBpbmNsdWRlIGFuIGVycm9yQ2FsbGJhY2vigJRhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGluIGNhc2VcbiAgICogIHRoZSBicm93c2VyIHdvbid0IHByb3ZpZGUgbWljIGFjY2Vzcy5cbiAgICpcbiAgICogIEBtZXRob2Qgc3RhcnRcbiAgICogIEBmb3IgcDUuQXVkaW9JblxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NDYWxsYmFja10gTmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGNhbGwgb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yQ2FsbGJhY2tdIE5hbWUgb2YgYSBmdW5jdGlvbiB0byBjYWxsIGlmXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlcmUgd2FzIGFuIGVycm9yLiBGb3IgZXhhbXBsZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXNlck1lZGlhLlxuICAgKi9cblxuXG4gIHA1LkF1ZGlvSW4ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfSBcblxuXG4gICAgdmFyIGF1ZGlvU291cmNlID0gcDVzb3VuZC5pbnB1dFNvdXJjZXNbc2VsZi5jdXJyZW50U291cmNlXTtcbiAgICB2YXIgY29uc3RyYWludHMgPSB7XG4gICAgICBhdWRpbzoge1xuICAgICAgICBzYW1wbGVSYXRlOiBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlLFxuICAgICAgICBlY2hvQ2FuY2VsbGF0aW9uOiBmYWxzZVxuICAgICAgfVxuICAgIH07IFxuXG4gICAgaWYgKHA1c291bmQuaW5wdXRTb3VyY2VzW3RoaXMuY3VycmVudFNvdXJjZV0pIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvLmRldmljZUlkID0gYXVkaW9Tb3VyY2UuZGV2aWNlSWQ7XG4gICAgfVxuXG4gICAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHNlbGYuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgc2VsZi5lbmFibGVkID0gdHJ1ZTsgXG5cbiAgICAgIHNlbGYubWVkaWFTdHJlYW0gPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuICAgICAgc2VsZi5tZWRpYVN0cmVhbS5jb25uZWN0KHNlbGYub3V0cHV0KTsgXG5cbiAgICAgIHNlbGYuYW1wbGl0dWRlLnNldElucHV0KHNlbGYub3V0cHV0KTtcbiAgICAgIGlmIChzdWNjZXNzQ2FsbGJhY2spIHN1Y2Nlc3NDYWxsYmFjaygpO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIGVycm9yQ2FsbGJhY2soZXJyKTtlbHNlIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqICBUdXJuIHRoZSBBdWRpb0luIG9mZi4gSWYgdGhlIEF1ZGlvSW4gaXMgc3RvcHBlZCwgaXQgY2Fubm90IGdldExldmVsKCkuXG4gICAqICBJZiByZS1zdGFydGluZywgdGhlIHVzZXIgbWF5IGJlIHByb21wdGVkIGZvciBwZXJtaXNzaW9uIGFjY2Vzcy5cbiAgICpcbiAgICogIEBtZXRob2Qgc3RvcFxuICAgKiAgQGZvciBwNS5BdWRpb0luXG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Jbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgIHRoaXMuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tZWRpYVN0cmVhbS5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5tZWRpYVN0cmVhbTtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgQ29ubmVjdCB0byBhbiBhdWRpbyB1bml0LiBJZiBubyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHdpbGxcbiAgICogIGNvbm5lY3QgdG8gdGhlIG1hc3RlciBvdXRwdXQgKGkuZS4geW91ciBzcGVha2VycykuPGJyLz5cbiAgICpcbiAgICogIEBtZXRob2QgIGNvbm5lY3RcbiAgICogIEBmb3IgcDUuQXVkaW9JblxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSBbdW5pdF0gQW4gb2JqZWN0IHRoYXQgYWNjZXB0cyBhdWRpbyBpbnB1dCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2ggYXMgYW4gRkZUXG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Jbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgaWYgKHVuaXQpIHtcbiAgICAgIGlmICh1bml0Lmhhc093blByb3BlcnR5KCdpbnB1dCcpKSB7XG4gICAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodW5pdC5pbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQuaGFzT3duUHJvcGVydHkoJ2FuYWx5c2VyJykpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdCh1bml0LmFuYWx5c2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodW5pdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QocDVzb3VuZC5pbnB1dCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIERpc2Nvbm5lY3QgdGhlIEF1ZGlvSW4gZnJvbSBhbGwgYXVkaW8gdW5pdHMuIEZvciBleGFtcGxlLCBpZlxuICAgKiAgY29ubmVjdCgpIGhhZCBiZWVuIGNhbGxlZCwgZGlzY29ubmVjdCgpIHdpbGwgc3RvcCBzZW5kaW5nXG4gICAqICBzaWduYWwgdG8geW91ciBzcGVha2Vycy48YnIvPlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZGlzY29ubmVjdFxuICAgKiAgQGZvciBwNS5BdWRpb0luXG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Jbi5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTsgXG5cbiAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodGhpcy5hbXBsaXR1ZGUuaW5wdXQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBSZWFkIHRoZSBBbXBsaXR1ZGUgKHZvbHVtZSBsZXZlbCkgb2YgYW4gQXVkaW9Jbi4gVGhlIEF1ZGlvSW5cbiAgICogIGNsYXNzIGNvbnRhaW5zIGl0cyBvd24gaW5zdGFuY2Ugb2YgdGhlIEFtcGxpdHVkZSBjbGFzcyB0byBoZWxwXG4gICAqICBtYWtlIGl0IGVhc3kgdG8gZ2V0IGEgbWljcm9waG9uZSdzIHZvbHVtZSBsZXZlbC4gQWNjZXB0cyBhblxuICAgKiAgb3B0aW9uYWwgc21vb3RoaW5nIHZhbHVlICgwLjAgPCAxLjApLiA8ZW0+Tk9URTogQXVkaW9JbiBtdXN0XG4gICAqICAuc3RhcnQoKSBiZWZvcmUgdXNpbmcgLmdldExldmVsKCkuPC9lbT48YnIvPlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZ2V0TGV2ZWxcbiAgICogIEBmb3IgcDUuQXVkaW9JblxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbc21vb3RoaW5nXSBTbW9vdGhpbmcgaXMgMC4wIGJ5IGRlZmF1bHQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNtb290aHMgdmFsdWVzIGJhc2VkIG9uIHByZXZpb3VzIHZhbHVlcy5cbiAgICogIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFZvbHVtZSBsZXZlbCAoYmV0d2VlbiAwLjAgYW5kIDEuMClcbiAgICovXG5cblxuICBwNS5BdWRpb0luLnByb3RvdHlwZS5nZXRMZXZlbCA9IGZ1bmN0aW9uIChzbW9vdGhpbmcpIHtcbiAgICBpZiAoc21vb3RoaW5nKSB7XG4gICAgICB0aGlzLmFtcGxpdHVkZS5zbW9vdGhpbmcgPSBzbW9vdGhpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYW1wbGl0dWRlLmdldExldmVsKCk7XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IGFtcGxpdHVkZSAodm9sdW1lKSBvZiBhIG1pYyBpbnB1dCBiZXR3ZWVuIDAgYW5kIDEuMC4gPGJyLz5cbiAgICpcbiAgICogIEBtZXRob2QgIGFtcFxuICAgKiAgQGZvciBwNS5BdWRpb0luXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IHZvbCBiZXR3ZWVuIDAgYW5kIDEuMFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt0aW1lXSByYW1wIHRpbWUgKG9wdGlvbmFsKVxuICAgKi9cblxuXG4gIHA1LkF1ZGlvSW4ucHJvdG90eXBlLmFtcCA9IGZ1bmN0aW9uICh2b2wsIHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgdmFyIHJhbXBUaW1lID0gdCB8fCAwO1xuICAgICAgdmFyIGN1cnJlbnRWb2wgPSB0aGlzLm91dHB1dC5nYWluLnZhbHVlO1xuICAgICAgdGhpcy5vdXRwdXQuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMocDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgdGhpcy5vdXRwdXQuZ2Fpbi5zZXRWYWx1ZUF0VGltZShjdXJyZW50Vm9sLCBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICB0aGlzLm91dHB1dC5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZvbCwgcmFtcFRpbWUgKyBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3V0cHV0LmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgIHRoaXMub3V0cHV0LmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sLCBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIGlucHV0IHNvdXJjZXMuIFRoaXMgaXMgYSB3cmFwcGVyXG4gICAqIGZvciA8YSB0aXRsZT1cIk1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkgLSBXZWIgQVBJcyB8IE1ETlwiIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XG4gICAqICBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZW51bWVyYXRlRGV2aWNlc1wiXG4gICAqICA+IGFuZCBpdCByZXR1cm5zIGEgUHJvbWlzZS5cbiAgICpcbiAgICogQG1ldGhvZCAgZ2V0U291cmNlc1xuICAgKiBAZm9yIHA1LkF1ZGlvSW5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtzdWNjZXNzQ2FsbGJhY2tdIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaGFuZGxlcyB0aGUgc291cmNlcyB3aGVuIHRoZXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUgYmVlbiBlbnVtZXJhdGVkLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVzIHRoZSBkZXZpY2VMaXN0IGFycmF5IGFzIGl0cyBvbmx5IGFyZ3VtZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbZXJyb3JDYWxsYmFja10gVGhpcyBvcHRpb25hbCBjYWxsYmFjayByZWNlaXZlcyB0aGUgZXJyb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIGFzIGl0cyBhcmd1bWVudC5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFJldHVybnMgYSBQcm9taXNlIHRoYXQgY2FuIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIGNhbGxiYWNrcywgc2ltaWxhclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgZW51bWVyYXRlRGV2aWNlcygpIG1ldGhvZFxuICAgKiBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBhdWRpb0luO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKXtcbiAgICogICAgdGV4dCgnZ2V0dGluZyBzb3VyY2VzLi4uJywgMCwgMjApO1xuICAgKiAgICBhdWRpb0luID0gbmV3IHA1LkF1ZGlvSW4oKTtcbiAgICogICAgYXVkaW9Jbi5nZXRTb3VyY2VzKGdvdFNvdXJjZXMpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZ290U291cmNlcyhkZXZpY2VMaXN0KSB7XG4gICAqICAgIGlmIChkZXZpY2VMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICogICAgICAvL3NldCB0aGUgc291cmNlIHRvIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBkZXZpY2VMaXN0IGFycmF5XG4gICAqICAgICAgYXVkaW9Jbi5zZXRTb3VyY2UoMCk7XG4gICAqICAgICAgbGV0IGN1cnJlbnRTb3VyY2UgPSBkZXZpY2VMaXN0W2F1ZGlvSW4uY3VycmVudFNvdXJjZV07XG4gICAqICAgICAgdGV4dCgnc2V0IHNvdXJjZSB0bzogJyArIGN1cnJlbnRTb3VyY2UuZGV2aWNlSWQsIDUsIDIwLCB3aWR0aCk7XG4gICAqICAgIH1cbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5BdWRpb0luLnByb3RvdHlwZS5nZXRTb3VyY2VzID0gZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihmdW5jdGlvbiAoZGV2aWNlcykge1xuICAgICAgICBwNXNvdW5kLmlucHV0U291cmNlcyA9IGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICByZXR1cm4gZGV2aWNlLmtpbmQgPT09ICdhdWRpb2lucHV0JztcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc29sdmUocDVzb3VuZC5pbnB1dFNvdXJjZXMpO1xuXG4gICAgICAgIGlmIChvblN1Y2Nlc3MpIHtcbiAgICAgICAgICBvblN1Y2Nlc3MocDVzb3VuZC5pbnB1dFNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuXG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWVkaWFTdHJlYW1UcmFjay5nZXRTb3VyY2VzKCknKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBpbnB1dCBzb3VyY2UuIEFjY2VwdHMgYSBudW1iZXIgcmVwcmVzZW50aW5nIGFcbiAgICogIHBvc2l0aW9uIGluIHRoZSBhcnJheSByZXR1cm5lZCBieSBnZXRTb3VyY2VzKCkuXG4gICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydFxuICAgKiAgPGEgdGl0bGU9XCJNZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpIC0gV2ViIEFQSXMgfCBNRE5cIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVxuICAgKiAgXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2VudW1lcmF0ZURldmljZXNcIlxuICAgKiAgPm5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpPC9hPi48YnIvPlxuICAgKlxuICAgKiAgQG1ldGhvZCBzZXRTb3VyY2VcbiAgICogIEBmb3IgcDUuQXVkaW9JblxuICAgKiAgQHBhcmFtIHtudW1iZXJ9IG51bSBwb3NpdGlvbiBvZiBpbnB1dCBzb3VyY2UgaW4gdGhlIGFycmF5XG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBhdWRpb0luO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKXtcbiAgICogICAgdGV4dCgnZ2V0dGluZyBzb3VyY2VzLi4uJywgMCwgMjApO1xuICAgKiAgICBhdWRpb0luID0gbmV3IHA1LkF1ZGlvSW4oKTtcbiAgICogICAgYXVkaW9Jbi5nZXRTb3VyY2VzKGdvdFNvdXJjZXMpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZ290U291cmNlcyhkZXZpY2VMaXN0KSB7XG4gICAqICAgIGlmIChkZXZpY2VMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICogICAgICAvL3NldCB0aGUgc291cmNlIHRvIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBkZXZpY2VMaXN0IGFycmF5XG4gICAqICAgICAgYXVkaW9Jbi5zZXRTb3VyY2UoMCk7XG4gICAqICAgICAgbGV0IGN1cnJlbnRTb3VyY2UgPSBkZXZpY2VMaXN0W2F1ZGlvSW4uY3VycmVudFNvdXJjZV07XG4gICAqICAgICAgdGV4dCgnc2V0IHNvdXJjZSB0bzogJyArIGN1cnJlbnRTb3VyY2UuZGV2aWNlSWQsIDUsIDIwLCB3aWR0aCk7XG4gICAqICAgIH1cbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5BdWRpb0luLnByb3RvdHlwZS5zZXRTb3VyY2UgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgaWYgKHA1c291bmQuaW5wdXRTb3VyY2VzLmxlbmd0aCA+IDAgJiYgbnVtIDwgcDVzb3VuZC5pbnB1dFNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2UgPSBudW07XG4gICAgICBjb25zb2xlLmxvZygnc2V0IHNvdXJjZSB0byAnLCBwNXNvdW5kLmlucHV0U291cmNlc1t0aGlzLmN1cnJlbnRTb3VyY2VdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ3VuYWJsZSB0byBzZXQgaW5wdXQgc291cmNlJyk7XG4gICAgfSBcblxuXG4gICAgaWYgKHRoaXMuc3RyZWFtICYmIHRoaXMuc3RyZWFtLmFjdGl2ZSkge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfTsgXG5cblxuICBwNS5BdWRpb0luLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYW1wbGl0dWRlKSB7XG4gICAgICB0aGlzLmFtcGxpdHVkZS5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuYW1wbGl0dWRlO1xuICAgIGRlbGV0ZSB0aGlzLm91dHB1dDtcbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDkpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oaSl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGkuQ3Jvc3NGYWRlPWZ1bmN0aW9uKGUpe3RoaXMuY3JlYXRlSW5zT3V0cygyLDEpLHRoaXMuYT10aGlzLmlucHV0WzBdPW5ldyBpLkdhaW4sdGhpcy5iPXRoaXMuaW5wdXRbMV09bmV3IGkuR2Fpbix0aGlzLmZhZGU9bmV3IGkuU2lnbmFsKHRoaXMuZGVmYXVsdEFyZyhlLC41KSxpLlR5cGUuTm9ybWFsUmFuZ2UpLHRoaXMuX2VxdWFsUG93ZXJBPW5ldyBpLkVxdWFsUG93ZXJHYWluLHRoaXMuX2VxdWFsUG93ZXJCPW5ldyBpLkVxdWFsUG93ZXJHYWluLHRoaXMuX2ludmVydD1uZXcgaS5FeHByKFwiMSAtICQwXCIpLHRoaXMuYS5jb25uZWN0KHRoaXMub3V0cHV0KSx0aGlzLmIuY29ubmVjdCh0aGlzLm91dHB1dCksdGhpcy5mYWRlLmNoYWluKHRoaXMuX2VxdWFsUG93ZXJCLHRoaXMuYi5nYWluKSx0aGlzLmZhZGUuY2hhaW4odGhpcy5faW52ZXJ0LHRoaXMuX2VxdWFsUG93ZXJBLHRoaXMuYS5nYWluKSx0aGlzLl9yZWFkT25seShcImZhZGVcIil9LGkuZXh0ZW5kKGkuQ3Jvc3NGYWRlKSxpLkNyb3NzRmFkZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBpLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fd3JpdGFibGUoXCJmYWRlXCIpLHRoaXMuX2VxdWFsUG93ZXJBLmRpc3Bvc2UoKSx0aGlzLl9lcXVhbFBvd2VyQT1udWxsLHRoaXMuX2VxdWFsUG93ZXJCLmRpc3Bvc2UoKSx0aGlzLl9lcXVhbFBvd2VyQj1udWxsLHRoaXMuZmFkZS5kaXNwb3NlKCksdGhpcy5mYWRlPW51bGwsdGhpcy5faW52ZXJ0LmRpc3Bvc2UoKSx0aGlzLl9pbnZlcnQ9bnVsbCx0aGlzLmEuZGlzcG9zZSgpLHRoaXMuYT1udWxsLHRoaXMuYi5kaXNwb3NlKCksdGhpcy5iPW51bGwsdGhpc30saS5Dcm9zc0ZhZGV9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXyg3KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLF9fd2VicGFja19yZXF1aXJlX18oNTMpLF9fd2VicGFja19yZXF1aXJlX18oMjYpLF9fd2VicGFja19yZXF1aXJlX18oNTQpLF9fd2VicGFja19yZXF1aXJlX18oMjUpLF9fd2VicGFja19yZXF1aXJlX18oNTUpLF9fd2VicGFja19yZXF1aXJlX18oNTYpLF9fd2VicGFja19yZXF1aXJlX18oNTcpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24ocCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLG4scil7dmFyIHQ9bmV3IGU7cmV0dXJuIHIuX2V2YWwoblswXSkuY29ubmVjdCh0LDAsMCksci5fZXZhbChuWzFdKS5jb25uZWN0KHQsMCwxKSx0fWZ1bmN0aW9uIHQoZSxuLHIpe3ZhciB0PW5ldyBlO3JldHVybiByLl9ldmFsKG5bMF0pLmNvbm5lY3QodCwwLDApLHR9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZT9wYXJzZUZsb2F0KGUpOnZvaWQgMH1mdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLmFyZ3M/cGFyc2VGbG9hdChlLmFyZ3MpOnZvaWQgMH1yZXR1cm4gcC5FeHByPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fcmVwbGFjZW1lbnRzKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpLGU9dGhpcy5fcGFyc2VJbnB1dHMobik7dGhpcy5fbm9kZXM9W10sdGhpcy5pbnB1dD1uZXcgQXJyYXkoZSk7Zm9yKHZhciByPTA7cjxlO3IrKyl0aGlzLmlucHV0W3JdPXRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7dmFyIHQsbz10aGlzLl9wYXJzZVRyZWUobik7dHJ5e3Q9dGhpcy5fZXZhbChvKX1jYXRjaChlKXt0aHJvdyB0aGlzLl9kaXNwb3NlTm9kZXMoKSxuZXcgRXJyb3IoXCJUb25lLkV4cHI6IENvdWxkIGV2YWx1YXRlIGV4cHJlc3Npb246IFwiK24pfXRoaXMub3V0cHV0PXR9LHAuZXh0ZW5kKHAuRXhwcixwLlNpZ25hbEJhc2UpLHAuRXhwci5fRXhwcmVzc2lvbnM9e3ZhbHVlOntzaWduYWw6e3JlZ2V4cDovXlxcZCtcXC5cXGQrfF5cXGQrLyxtZXRob2Q6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBwLlNpZ25hbChvKGUpKX19LGlucHV0OntyZWdleHA6L15cXCRcXGQvLG1ldGhvZDpmdW5jdGlvbihlLG4pe3JldHVybiBuLmlucHV0W28oZS5zdWJzdHIoMSkpXX19fSxnbHVlOntcIihcIjp7cmVnZXhwOi9eXFwoL30sXCIpXCI6e3JlZ2V4cDovXlxcKS99LFwiLFwiOntyZWdleHA6L14sL319LGZ1bmM6e2Ficzp7cmVnZXhwOi9eYWJzLyxtZXRob2Q6dC5iaW5kKHRoaXMscC5BYnMpfSxtb2Q6e3JlZ2V4cDovXm1vZC8sbWV0aG9kOmZ1bmN0aW9uKGUsbil7dmFyIHI9aShlWzFdKSx0PW5ldyBwLk1vZHVsbyhyKTtyZXR1cm4gbi5fZXZhbChlWzBdKS5jb25uZWN0KHQpLHR9fSxwb3c6e3JlZ2V4cDovXnBvdy8sbWV0aG9kOmZ1bmN0aW9uKGUsbil7dmFyIHI9aShlWzFdKSx0PW5ldyBwLlBvdyhyKTtyZXR1cm4gbi5fZXZhbChlWzBdKS5jb25uZWN0KHQpLHR9fSxhMmc6e3JlZ2V4cDovXmEyZy8sbWV0aG9kOmZ1bmN0aW9uKGUsbil7dmFyIHI9bmV3IHAuQXVkaW9Ub0dhaW47cmV0dXJuIG4uX2V2YWwoZVswXSkuY29ubmVjdChyKSxyfX19LGJpbmFyeTp7XCIrXCI6e3JlZ2V4cDovXlxcKy8scHJlY2VkZW5jZToxLG1ldGhvZDpyLmJpbmQodGhpcyxwLkFkZCl9LFwiLVwiOntyZWdleHA6L15cXC0vLHByZWNlZGVuY2U6MSxtZXRob2Q6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gMT09PWUubGVuZ3RoP3QocC5OZWdhdGUsZSxuKTpyKHAuU3VidHJhY3QsZSxuKX19LFwiKlwiOntyZWdleHA6L15cXCovLHByZWNlZGVuY2U6MCxtZXRob2Q6ci5iaW5kKHRoaXMscC5NdWx0aXBseSl9fSx1bmFyeTp7XCItXCI6e3JlZ2V4cDovXlxcLS8sbWV0aG9kOnQuYmluZCh0aGlzLHAuTmVnYXRlKX0sXCIhXCI6e3JlZ2V4cDovXlxcIS8sbWV0aG9kOnQuYmluZCh0aGlzLHAuTk9UKX19fSxwLkV4cHIucHJvdG90eXBlLl9wYXJzZUlucHV0cz1mdW5jdGlvbihlKXt2YXIgbj1lLm1hdGNoKC9cXCRcXGQvZykscj0wO2lmKG51bGwhPT1uKWZvcih2YXIgdD0wO3Q8bi5sZW5ndGg7dCsrKXt2YXIgbz1wYXJzZUludChuW3RdLnN1YnN0cigxKSkrMTtyPU1hdGgubWF4KHIsbyl9cmV0dXJuIHJ9LHAuRXhwci5wcm90b3R5cGUuX3JlcGxhY2VtZW50cz1mdW5jdGlvbihlKXtmb3IodmFyIG49ZS5zaGlmdCgpLHI9MDtyPGUubGVuZ3RoO3IrKyluPW4ucmVwbGFjZSgvXFwlL2ksZVtyXSk7cmV0dXJuIG59LHAuRXhwci5wcm90b3R5cGUuX3Rva2VuaXplPWZ1bmN0aW9uKGUpe2Zvcih2YXIgbj0tMSxyPVtdOzA8ZS5sZW5ndGg7KXt2YXIgdD1vKGU9ZS50cmltKCkpO3IucHVzaCh0KSxlPWUuc3Vic3RyKHQudmFsdWUubGVuZ3RoKX1mdW5jdGlvbiBvKGUpe2Zvcih2YXIgbiBpbiBwLkV4cHIuX0V4cHJlc3Npb25zKXt2YXIgcj1wLkV4cHIuX0V4cHJlc3Npb25zW25dO2Zvcih2YXIgdCBpbiByKXt2YXIgbz1yW3RdLGk9by5yZWdleHAsYT1lLm1hdGNoKGkpO2lmKG51bGwhPT1hKXJldHVybnt0eXBlOm4sdmFsdWU6YVswXSxtZXRob2Q6by5tZXRob2R9fX10aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUb25lLkV4cHI6IFVuZXhwZWN0ZWQgdG9rZW4gXCIrZSl9cmV0dXJue25leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gclsrK25dfSxwZWVrOmZ1bmN0aW9uKCl7cmV0dXJuIHJbbisxXX19fSxwLkV4cHIucHJvdG90eXBlLl9wYXJzZVRyZWU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fdG9rZW5pemUoZSksYT10aGlzLmlzVW5kZWYuYmluZCh0aGlzKTtmdW5jdGlvbiByKGUsbil7cmV0dXJuIWEoZSkmJlwiZ2x1ZVwiPT09ZS50eXBlJiZlLnZhbHVlPT09bn1mdW5jdGlvbiBvKGUsbixyKXt2YXIgdD1wLkV4cHIuX0V4cHJlc3Npb25zW25dO2lmKCFhKGUpKWZvcih2YXIgbyBpbiB0KXt2YXIgaT10W29dO2lmKGkucmVnZXhwLnRlc3QoZS52YWx1ZSkpe2lmKGEocikpcmV0dXJuITA7aWYoaS5wcmVjZWRlbmNlPT09cilyZXR1cm4hMH19cmV0dXJuITF9ZnVuY3Rpb24gaShlKXt2YXIgbjthKGUpJiYoZT01KSxuPWU8MD9mdW5jdGlvbiBlKCl7dmFyIG4scjtuPXQucGVlaygpO2lmKG8obixcInVuYXJ5XCIpKXJldHVybiBuPXQubmV4dCgpLHI9ZSgpLHtvcGVyYXRvcjpuLnZhbHVlLG1ldGhvZDpuLm1ldGhvZCxhcmdzOltyXX07cmV0dXJuIHMoKX0oKTppKGUtMSk7Zm9yKHZhciByPXQucGVlaygpO28ocixcImJpbmFyeVwiLGUpOyluPXtvcGVyYXRvcjoocj10Lm5leHQoKSkudmFsdWUsbWV0aG9kOnIubWV0aG9kLGFyZ3M6W24saShlLTEpXX0scj10LnBlZWsoKTtyZXR1cm4gbn1mdW5jdGlvbiBzKCl7dmFyIGUsbjtpZihlPXQucGVlaygpLGEoZSkpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVG9uZS5FeHByOiBVbmV4cGVjdGVkIHRlcm1pbmF0aW9uIG9mIGV4cHJlc3Npb25cIik7aWYoXCJmdW5jXCI9PT1lLnR5cGUpcmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuPVtdO2lmKCFyKHQubmV4dCgpLFwiKFwiKSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuRXhwcjogRXhwZWN0ZWQgKCBpbiBhIGZ1bmN0aW9uIGNhbGwgXCInK2UudmFsdWUrJ1wiJyk7cih0LnBlZWsoKSxcIilcIil8fChuPWZ1bmN0aW9uKCl7dmFyIGUsbj1bXTtmb3IoO2U9aSgpLCFhKGUpJiYobi5wdXNoKGUpLHIodC5wZWVrKCksXCIsXCIpKTspdC5uZXh0KCk7cmV0dXJuIG59KCkpO2lmKHIodC5uZXh0KCksXCIpXCIpKXJldHVybnttZXRob2Q6ZS5tZXRob2QsYXJnczpuLG5hbWU6bmFtZX07dGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLkV4cHI6IEV4cGVjdGVkICkgaW4gYSBmdW5jdGlvbiBjYWxsIFwiJytlLnZhbHVlKydcIicpfShlPXQubmV4dCgpKTtpZihcInZhbHVlXCI9PT1lLnR5cGUpcmV0dXJue21ldGhvZDooZT10Lm5leHQoKSkubWV0aG9kLGFyZ3M6ZS52YWx1ZX07aWYocihlLFwiKFwiKSl7aWYodC5uZXh0KCksbj1pKCksIXIoZT10Lm5leHQoKSxcIilcIikpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiRXhwZWN0ZWQgKVwiKTtyZXR1cm4gbn10aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUb25lLkV4cHI6IFBhcnNlIGVycm9yLCBjYW5ub3QgcHJvY2VzcyB0b2tlbiBcIitlLnZhbHVlKX1yZXR1cm4gaSgpfSxwLkV4cHIucHJvdG90eXBlLl9ldmFsPWZ1bmN0aW9uKGUpe2lmKCF0aGlzLmlzVW5kZWYoZSkpe3ZhciBuPWUubWV0aG9kKGUuYXJncyx0aGlzKTtyZXR1cm4gdGhpcy5fbm9kZXMucHVzaChuKSxufX0scC5FeHByLnByb3RvdHlwZS5fZGlzcG9zZU5vZGVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTx0aGlzLl9ub2Rlcy5sZW5ndGg7ZSsrKXt2YXIgbj10aGlzLl9ub2Rlc1tlXTt0aGlzLmlzRnVuY3Rpb24obi5kaXNwb3NlKT9uLmRpc3Bvc2UoKTp0aGlzLmlzRnVuY3Rpb24obi5kaXNjb25uZWN0KSYmbi5kaXNjb25uZWN0KCksbj1udWxsLHRoaXMuX25vZGVzW2VdPW51bGx9dGhpcy5fbm9kZXM9bnVsbH0scC5FeHByLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX2Rpc3Bvc2VOb2RlcygpfSxwLkV4cHJ9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyNiksX193ZWJwYWNrX3JlcXVpcmVfXygxNiksX193ZWJwYWNrX3JlcXVpcmVfXygyKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO3JldHVybiBlLkdyZWF0ZXJUaGFuPWZ1bmN0aW9uKHQpe3RoaXMuY3JlYXRlSW5zT3V0cygyLDApLHRoaXMuX3BhcmFtPXRoaXMuaW5wdXRbMF09bmV3IGUuU3VidHJhY3QodCksdGhpcy5pbnB1dFsxXT10aGlzLl9wYXJhbS5pbnB1dFsxXSx0aGlzLl9ndHo9dGhpcy5vdXRwdXQ9bmV3IGUuR3JlYXRlclRoYW5aZXJvLHRoaXMuX3BhcmFtLmNvbm5lY3QodGhpcy5fZ3R6KX0sZS5leHRlbmQoZS5HcmVhdGVyVGhhbixlLlNpZ25hbCksZS5HcmVhdGVyVGhhbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fcGFyYW0uZGlzcG9zZSgpLHRoaXMuX3BhcmFtPW51bGwsdGhpcy5fZ3R6LmRpc3Bvc2UoKSx0aGlzLl9ndHo9bnVsbCx0aGlzfSxlLkdyZWF0ZXJUaGFufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oNSksX193ZWJwYWNrX3JlcXVpcmVfXygxOSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihzKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gcy5BYnM9ZnVuY3Rpb24oKXt0aGlzLl9hYnM9dGhpcy5pbnB1dD10aGlzLm91dHB1dD1uZXcgcy5XYXZlU2hhcGVyKGZ1bmN0aW9uKHMpe3JldHVybiAwPT09cz8wOk1hdGguYWJzKHMpfSwxMjcpfSxzLmV4dGVuZChzLkFicyxzLlNpZ25hbEJhc2UpLHMuQWJzLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIHMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9hYnMuZGlzcG9zZSgpLHRoaXMuX2Ficz1udWxsLHRoaXN9LHMuQWJzfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oNSksX193ZWJwYWNrX3JlcXVpcmVfXygzKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKGkpe1widXNlIHN0cmljdFwiO3JldHVybiBpLk1vZHVsbz1mdW5jdGlvbih0KXt0aGlzLmNyZWF0ZUluc091dHMoMSwwKSx0aGlzLl9zaGFwZXI9bmV3IGkuV2F2ZVNoYXBlcihNYXRoLnBvdygyLDE2KSksdGhpcy5fbXVsdGlwbHk9bmV3IGkuTXVsdGlwbHksdGhpcy5fc3VidHJhY3Q9dGhpcy5vdXRwdXQ9bmV3IGkuU3VidHJhY3QsdGhpcy5fbW9kU2lnbmFsPW5ldyBpLlNpZ25hbCh0KSx0aGlzLmlucHV0LmZhbih0aGlzLl9zaGFwZXIsdGhpcy5fc3VidHJhY3QpLHRoaXMuX21vZFNpZ25hbC5jb25uZWN0KHRoaXMuX211bHRpcGx5LDAsMCksdGhpcy5fc2hhcGVyLmNvbm5lY3QodGhpcy5fbXVsdGlwbHksMCwxKSx0aGlzLl9tdWx0aXBseS5jb25uZWN0KHRoaXMuX3N1YnRyYWN0LDAsMSksdGhpcy5fc2V0V2F2ZVNoYXBlcih0KX0saS5leHRlbmQoaS5Nb2R1bG8saS5TaWduYWxCYXNlKSxpLk1vZHVsby5wcm90b3R5cGUuX3NldFdhdmVTaGFwZXI9ZnVuY3Rpb24oaSl7dGhpcy5fc2hhcGVyLnNldE1hcChmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5mbG9vcigodCsxZS00KS9pKX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaS5Nb2R1bG8ucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21vZFNpZ25hbC52YWx1ZX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX21vZFNpZ25hbC52YWx1ZT10LHRoaXMuX3NldFdhdmVTaGFwZXIodCl9fSksaS5Nb2R1bG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gaS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX3NoYXBlci5kaXNwb3NlKCksdGhpcy5fc2hhcGVyPW51bGwsdGhpcy5fbXVsdGlwbHkuZGlzcG9zZSgpLHRoaXMuX211bHRpcGx5PW51bGwsdGhpcy5fc3VidHJhY3QuZGlzcG9zZSgpLHRoaXMuX3N1YnRyYWN0PW51bGwsdGhpcy5fbW9kU2lnbmFsLmRpc3Bvc2UoKSx0aGlzLl9tb2RTaWduYWw9bnVsbCx0aGlzfSxpLk1vZHVsb30pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDUpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIHQuUG93PWZ1bmN0aW9uKGUpe3RoaXMuX2V4cD10aGlzLmRlZmF1bHRBcmcoZSwxKSx0aGlzLl9leHBTY2FsZXI9dGhpcy5pbnB1dD10aGlzLm91dHB1dD1uZXcgdC5XYXZlU2hhcGVyKHRoaXMuX2V4cEZ1bmModGhpcy5fZXhwKSw4MTkyKX0sdC5leHRlbmQodC5Qb3csdC5TaWduYWxCYXNlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5Qb3cucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2V4cH0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2V4cD1lLHRoaXMuX2V4cFNjYWxlci5zZXRNYXAodGhpcy5fZXhwRnVuYyh0aGlzLl9leHApKX19KSx0LlBvdy5wcm90b3R5cGUuX2V4cEZ1bmM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLnBvdyhNYXRoLmFicyhlKSx0KX19LHQuUG93LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIHQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9leHBTY2FsZXIuZGlzcG9zZSgpLHRoaXMuX2V4cFNjYWxlcj1udWxsLHRoaXN9LHQuUG93fSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oNSksX193ZWJwYWNrX3JlcXVpcmVfXygyKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKG4pe1widXNlIHN0cmljdFwiO3JldHVybiBuLkF1ZGlvVG9HYWluPWZ1bmN0aW9uKCl7dGhpcy5fbm9ybT10aGlzLmlucHV0PXRoaXMub3V0cHV0PW5ldyBuLldhdmVTaGFwZXIoZnVuY3Rpb24obil7cmV0dXJuKG4rMSkvMn0pfSxuLmV4dGVuZChuLkF1ZGlvVG9HYWluLG4uU2lnbmFsQmFzZSksbi5BdWRpb1RvR2Fpbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBuLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fbm9ybS5kaXNwb3NlKCksdGhpcy5fbm9ybT1udWxsLHRoaXN9LG4uQXVkaW9Ub0dhaW59KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXyg1KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO3JldHVybiBlLkVxdWFsUG93ZXJHYWluPWZ1bmN0aW9uKCl7dGhpcy5fZXFQb3dlcj10aGlzLmlucHV0PXRoaXMub3V0cHV0PW5ldyBlLldhdmVTaGFwZXIoZnVuY3Rpb24oZSl7cmV0dXJuIE1hdGguYWJzKGUpPC4wMDE/MDp0aGlzLmVxdWFsUG93ZXJTY2FsZShlKX0uYmluZCh0aGlzKSw0MDk2KX0sZS5leHRlbmQoZS5FcXVhbFBvd2VyR2FpbixlLlNpZ25hbEJhc2UpLGUuRXF1YWxQb3dlckdhaW4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX2VxUG93ZXIuZGlzcG9zZSgpLHRoaXMuX2VxUG93ZXI9bnVsbCx0aGlzfSxlLkVxdWFsUG93ZXJHYWlufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIEVmZmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbiAgdmFyIEVRRmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG4gIC8qKlxuICAgKiBwNS5FUSBpcyBhbiBhdWRpbyBlZmZlY3QgdGhhdCBwZXJmb3JtcyB0aGUgZnVuY3Rpb24gb2YgYSBtdWx0aWJhbmRcbiAgICogYXVkaW8gZXF1YWxpemVyLiBFcXVhbGl6YXRpb24gaXMgdXNlZCB0byBhZGp1c3QgdGhlIGJhbGFuY2Ugb2ZcbiAgICogZnJlcXVlbmN5IGNvbXBvZW5lbnRzIG9mIGFuIGF1ZGlvIHNpZ25hbC4gVGhpcyBwcm9jZXNzIGlzIGNvbW1vbmx5IHVzZWRcbiAgICogaW4gc291bmQgcHJvZHVjdGlvbiBhbmQgcmVjb3JkaW5nIHRvIGNoYW5nZSB0aGUgd2F2ZWZvcm0gYmVmb3JlIGl0IHJlYWNoZXNcbiAgICogYSBzb3VuZCBvdXRwdXQgZGV2aWNlLiBFUSBjYW4gYWxzbyBiZSB1c2VkIGFzIGFuIGF1ZGlvIGVmZmVjdCB0byBjcmVhdGVcbiAgICogaW50ZXJlc3RpbmcgZGlzdG9ydGlvbnMgYnkgZmlsdGVyaW5nIG91dCBwYXJ0cyBvZiB0aGUgc3BlY3RydW0uIHA1LkVRIGlzXG4gICAqIGJ1aWx0IHVzaW5nIGEgY2hhaW4gb2YgV2ViIEF1ZGlvIEJpcXVhZCBGaWx0ZXIgTm9kZXMgYW5kIGNhbiBiZVxuICAgKiBpbnN0YW50aWF0ZWQgd2l0aCAzIG9yIDggYmFuZHMuIEJhbmRzIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIGZyb21cbiAgICogdGhlIEVRIGJ5IGRpcmVjdGx5IG1vZGlmeWluZyBwNS5FUS5iYW5kcyAodGhlIGFycmF5IHRoYXQgc3RvcmVzIGZpbHRlcnMpLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGV4dGVuZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdFwiPnA1LkVmZmVjdDwvYT4uXG4gICAqIE1ldGhvZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9hbXBcIj5hbXAoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY2hhaW5cIj5jaGFpbigpPC9hPixcbiAgICogPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9kcnl3ZXRcIj5kcnl3ZXQoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY29ubmVjdFwiPmNvbm5lY3QoKTwvYT4sIGFuZFxuICAgKiA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Rpc2Nvbm5lY3RcIj5kaXNjb25uZWN0KCk8L2E+IGFyZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBjbGFzcyBwNS5FUVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgcDUuRWZmZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbX2Vxc2l6ZV0gQ29uc3RydWN0b3Igd2lsbCBhY2NlcHQgMyBvciA4LCBkZWZhdWx0cyB0byAzXG4gICAqIEByZXR1cm4ge09iamVjdH0gcDUuRVEgb2JqZWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxkaXY+PGNvZGU+XG4gICAqIGxldCBlcSwgc291bmRGaWxlXG4gICAqIGxldCBlcUJhbmRJbmRleCA9IDA7XG4gICAqIGxldCBlcUJhbmROYW1lcyA9IFsnbG93cycsICdtaWRzJywgJ2hpZ2hzJ107XG4gICAqXG4gICAqIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgc291bmRGb3JtYXRzKCdtcDMnLCAnb2dnJyk7XG4gICAqICAgc291bmRGaWxlID0gbG9hZFNvdW5kKCdhc3NldHMvYmVhdCcpO1xuICAgKiB9XG4gICAqXG4gICAqIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgIGNudi5tb3VzZVByZXNzZWQodG9nZ2xlU291bmQpO1xuICAgKlxuICAgKiAgIGVxID0gbmV3IHA1LkVRKGVxQmFuZE5hbWVzLmxlbmd0aCk7XG4gICAqICAgc291bmRGaWxlLmRpc2Nvbm5lY3QoKTtcbiAgICogICBlcS5wcm9jZXNzKHNvdW5kRmlsZSk7XG4gICAqIH1cbiAgICpcbiAgICogZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICBiYWNrZ3JvdW5kKDMwKTtcbiAgICogICBub1N0cm9rZSgpO1xuICAgKiAgIGZpbGwoMjU1KTtcbiAgICogICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICogICB0ZXh0KCdmaWx0ZXJpbmcgJywgNTAsIDI1KTtcbiAgICpcbiAgICogICBmaWxsKDI1NSwgNDAsIDI1NSk7XG4gICAqICAgdGV4dFNpemUoMjYpO1xuICAgKiAgIHRleHQoZXFCYW5kTmFtZXNbZXFCYW5kSW5kZXhdLCA1MCwgNTUpO1xuICAgKlxuICAgKiAgIGZpbGwoMjU1KTtcbiAgICogICB0ZXh0U2l6ZSg5KTtcbiAgICpcbiAgICogICBpZiAoIXNvdW5kRmlsZS5pc1BsYXlpbmcoKSkge1xuICAgKiAgICAgdGV4dCgndGFwIHRvIHBsYXknLCA1MCwgODApO1xuICAgKiAgIH0gZWxzZSB7XG4gICAqICAgICB0ZXh0KCd0YXAgdG8gZmlsdGVyIG5leHQgYmFuZCcsIDUwLCA4MClcbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogZnVuY3Rpb24gdG9nZ2xlU291bmQoKSB7XG4gICAqICAgaWYgKCFzb3VuZEZpbGUuaXNQbGF5aW5nKCkpIHtcbiAgICogICAgIHNvdW5kRmlsZS5wbGF5KCk7XG4gICAqICAgfSBlbHNlIHtcbiAgICogICAgIGVxQmFuZEluZGV4ID0gKGVxQmFuZEluZGV4ICsgMSkgJSBlcS5iYW5kcy5sZW5ndGg7XG4gICAqICAgfVxuICAgKlxuICAgKiAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXEuYmFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICogICAgIGVxLmJhbmRzW2ldLmdhaW4oMCk7XG4gICAqICAgfVxuICAgKiAgIC8vIGZpbHRlciB0aGUgYmFuZCB3ZSB3YW50IHRvIGZpbHRlclxuICAgKiAgIGVxLmJhbmRzW2VxQmFuZEluZGV4XS5nYWluKC00MCk7XG4gICAqIH1cbiAgICogPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkVRID0gZnVuY3Rpb24gKF9lcXNpemUpIHtcbiAgICBFZmZlY3QuY2FsbCh0aGlzKTsgXG5cbiAgICBfZXFzaXplID0gX2Vxc2l6ZSA9PT0gMyB8fCBfZXFzaXplID09PSA4ID8gX2Vxc2l6ZSA6IDM7XG4gICAgdmFyIGZhY3RvcjtcbiAgICBfZXFzaXplID09PSAzID8gZmFjdG9yID0gTWF0aC5wb3coMiwgMykgOiBmYWN0b3IgPSAyO1xuICAgIC8qKlxuICAgICAgKiAgVGhlIHA1LkVRIGlzIGJ1aWx0IHdpdGggYWJzdHJhY3RlZCBwNS5GaWx0ZXIgb2JqZWN0cy5cbiAgICAgICogIFRvIG1vZGlmeSBhbnkgYmFuZHMsIHVzZSBtZXRob2RzIG9mIHRoZSA8YVxuICAgICAgKiAgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5GaWx0ZXJcIiB0aXRsZT1cInA1LkZpbHRlciByZWZlcmVuY2VcIj5cbiAgICAgICogIHA1LkZpbHRlcjwvYT4gQVBJLCBlc3BlY2lhbGx5IGBnYWluYCBhbmQgYGZyZXFgLlxuICAgICAgKiAgQmFuZHMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSwgd2l0aCBpbmRpY2VzIDAgLSAzLCBvciAwIC0gN1xuICAgICAgKiAgQHByb3BlcnR5IHtBcnJheX0gIGJhbmRzXG4gICAgICAqXG4gICAgKi9cblxuICAgIHRoaXMuYmFuZHMgPSBbXTtcbiAgICB2YXIgZnJlcSwgcmVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfZXFzaXplOyBpKyspIHtcbiAgICAgIGlmIChpID09PSBfZXFzaXplIC0gMSkge1xuICAgICAgICBmcmVxID0gMjEwMDA7XG4gICAgICAgIHJlcyA9IC4wMTtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICBmcmVxID0gMTAwO1xuICAgICAgICByZXMgPSAuMTtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgICBmcmVxID0gX2Vxc2l6ZSA9PT0gMyA/IDM2MCAqIGZhY3RvciA6IDM2MDtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyZXEgPSB0aGlzLmJhbmRzW2kgLSAxXS5mcmVxKCkgKiBmYWN0b3I7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmFuZHNbaV0gPSB0aGlzLl9uZXdCYW5kKGZyZXEsIHJlcyk7XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB0aGlzLmJhbmRzW2kgLSAxXS5jb25uZWN0KHRoaXMuYmFuZHNbaV0uYmlxdWFkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLmJhbmRzW2ldLmJpcXVhZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5iYW5kc1tfZXFzaXplIC0gMV0uY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gIH07XG5cbiAgcDUuRVEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFZmZlY3QucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqIFByb2Nlc3MgYW4gaW5wdXQgYnkgY29ubmVjdGluZyBpdCB0byB0aGUgRVFcbiAgICogQG1ldGhvZCAgcHJvY2Vzc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNyYyBBdWRpbyBzb3VyY2VcbiAgICovXG5cbiAgcDUuRVEucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgc3JjLmNvbm5lY3QodGhpcy5pbnB1dCk7XG4gIH07IFxuICAvLyAgICogU2V0IHRoZSBmcmVxdWVuY3kgYW5kIGdhaW4gb2YgZWFjaCBiYW5kIGluIHRoZSBFUS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlXG4gIC8vICAgKiBjYWxsZWQgd2l0aCAzIG9yIDggZnJlcXVlbmN5IGFuZCBnYWluIHBhaXJzLCBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIEVRLlxuICAvLyAgICogZXguIGVxLnNldChmcmVxMCwgZ2FpbjAsIGZyZXExLCBnYWluMSwgZnJlcTIsIGdhaW4yKTtcbiAgLy8gICAqXG4gIC8vICAgKiBAbWV0aG9kICBzZXRcbiAgLy8gICAqIEBmb3IgcDUuRVFcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcTBdIEZyZXF1ZW5jeSB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDBcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZ2FpbjBdIEdhaW4gdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCAwXG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXExXSBGcmVxdWVuY3kgdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCAxXG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2dhaW4xXSBHYWluIHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggMVxuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcmVxMl0gRnJlcXVlbmN5IHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggMlxuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtnYWluMl0gR2FpbiB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDJcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcTNdIEZyZXF1ZW5jeSB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDNcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZ2FpbjNdIEdhaW4gdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCAzXG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXE0XSBGcmVxdWVuY3kgdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCA0XG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2dhaW40XSBHYWluIHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggNFxuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcmVxNV0gRnJlcXVlbmN5IHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggNVxuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtnYWluNV0gR2FpbiB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDVcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcTZdIEZyZXF1ZW5jeSB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDZcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZ2FpbjZdIEdhaW4gdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCA2XG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXE3XSBGcmVxdWVuY3kgdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCA3XG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2dhaW43XSBHYWluIHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggN1xuICAvLyAgICovXG5cblxuICBwNS5FUS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSB0aGlzLmJhbmRzLmxlbmd0aCAqIDIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHRoaXMuYmFuZHNbaSAvIDJdLmZyZXEoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgdGhpcy5iYW5kc1tpIC8gMl0uZ2Fpbihhcmd1bWVudHNbaSArIDFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignQXJndW1lbnQgbWlzbWF0Y2guIC5zZXQoKSBzaG91bGQgYmUgY2FsbGVkIHdpdGggJyArIHRoaXMuYmFuZHMubGVuZ3RoICogMiArICcgYXJndW1lbnRzLiAob25lIGZyZXF1ZW5jeSBhbmQgZ2FpbiB2YWx1ZSBwYWlyIGZvciBlYWNoIGJhbmQgb2YgdGhlIGVxKScpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBiYW5kLiBDcmVhdGVzIGEgcDUuRmlsdGVyIGFuZCBzdHJpcHMgYXdheSBldmVyeXRoaW5nIGJ1dFxuICAgKiB0aGUgcmF3IGJpcXVhZCBmaWx0ZXIuIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gYWJzdHJhY3RlZCBwNS5GaWx0ZXIsXG4gICAqIHdoaWNoIGNhbiBiZSBhZGRlZCB0byBwNS5FUS5iYW5kcywgaW4gb3JkZXIgdG8gY3JlYXRlIG5ldyBFUSBiYW5kcy5cbiAgICogQHByaXZhdGVcbiAgICogQGZvciBwNS5FUVxuICAgKiBAbWV0aG9kICBfbmV3QmFuZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZyZXFcbiAgICogQHBhcmFtICB7TnVtYmVyfSByZXNcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIEFic3RyYWN0ZWQgRmlsdGVyXG4gICAqL1xuXG5cbiAgcDUuRVEucHJvdG90eXBlLl9uZXdCYW5kID0gZnVuY3Rpb24gKGZyZXEsIHJlcykge1xuICAgIHJldHVybiBuZXcgRVFGaWx0ZXIoZnJlcSwgcmVzKTtcbiAgfTtcblxuICBwNS5FUS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcyk7XG5cbiAgICBpZiAodGhpcy5iYW5kcykge1xuICAgICAgd2hpbGUgKHRoaXMuYmFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5iYW5kcy5wb3AoKS5kaXNwb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLmJhbmRzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcDUuRVE7XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIEZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgLyoqXG4gICAqICBFUUZpbHRlciBleHRlbmRzIHA1LkZpbHRlciB3aXRoIGNvbnN0cmFpbnRzXG4gICAqICBuZWNlc3NhcnkgZm9yIHRoZSBwNS5FUVxuICAgKlxuICAgKiAgQHByaXZhdGVcbiAgICovXG5cblxuICB2YXIgRVFGaWx0ZXIgPSBmdW5jdGlvbiBFUUZpbHRlcihmcmVxLCByZXMpIHtcbiAgICBGaWx0ZXIuY2FsbCh0aGlzLCAncGVha2luZycpO1xuICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuc2V0KGZyZXEsIHJlcyk7XG4gICAgdGhpcy5iaXF1YWQuZ2Fpbi52YWx1ZSA9IDA7XG4gICAgZGVsZXRlIHRoaXMuaW5wdXQ7XG4gICAgZGVsZXRlIHRoaXMub3V0cHV0O1xuICAgIGRlbGV0ZSB0aGlzLl9kcnl3ZXQ7XG4gICAgZGVsZXRlIHRoaXMud2V0O1xuICB9O1xuXG4gIEVRRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsdGVyLnByb3RvdHlwZSk7XG5cbiAgRVFGaWx0ZXIucHJvdG90eXBlLmFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLndhcm4oJ2BhbXAoKWAgaXMgbm90IGF2YWlsYWJsZSBmb3IgcDUuRVEgYmFuZHMuIFVzZSBgLmdhaW4oKWAnKTtcbiAgfTtcblxuICBFUUZpbHRlci5wcm90b3R5cGUuZHJ5d2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUud2FybignYGRyeXdldCgpYCBpcyBub3QgYXZhaWxhYmxlIGZvciBwNS5FUSBiYW5kcy4nKTtcbiAgfTtcblxuICBFUUZpbHRlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdmFyIHUgPSB1bml0IHx8IHA1LnNvdW5kT3V0LmlucHV0O1xuXG4gICAgaWYgKHRoaXMuYmlxdWFkKSB7XG4gICAgICB0aGlzLmJpcXVhZC5jb25uZWN0KHUuaW5wdXQgPyB1LmlucHV0IDogdSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodS5pbnB1dCA/IHUuaW5wdXQgOiB1KTtcbiAgICB9XG4gIH07XG5cbiAgRVFGaWx0ZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYmlxdWFkKSB7XG4gICAgICB0aGlzLmJpcXVhZC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIEVRRmlsdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIGRlbGV0ZSB0aGlzLmJpcXVhZDtcbiAgfTtcblxuICByZXR1cm4gRVFGaWx0ZXI7XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBFZmZlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuICAvKipcbiAgICogUGFubmVyM0QgaXMgYmFzZWQgb24gdGhlIDxhIHRpdGxlPVwiV2ViIEF1ZGlvIFBhbm5lciBkb2NzXCIgIGhyZWY9XG4gICAqIFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Bhbm5lck5vZGVcIj5cbiAgICogV2ViIEF1ZGlvIFNwYXRpYWwgUGFubmVyIE5vZGU8L2E+LlxuICAgKiBUaGlzIHBhbm5lciBpcyBhIHNwYXRpYWwgcHJvY2Vzc2luZyBub2RlIHRoYXQgYWxsb3dzIGF1ZGlvIHRvIGJlIHBvc2l0aW9uZWRcbiAgICogYW5kIG9yaWVudGVkIGluIDNEIHNwYWNlLlxuICAgKlxuICAgKiBUaGUgcG9zaXRpb24gaXMgcmVsYXRpdmUgdG8gYW4gPGEgdGl0bGU9XCJXZWIgQXVkaW8gTGlzdGVuZXIgZG9jc1wiIGhyZWY9XG4gICAqIFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTGlzdGVuZXJcIj5cbiAgICogQXVkaW8gQ29udGV4dCBMaXN0ZW5lcjwvYT4sIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAgKiBieSA8Y29kZT5wNS5zb3VuZE91dC5hdWRpb2NvbnRleHQubGlzdGVuZXI8L2NvZGU+XG4gICAqXG4gICAqXG4gICAqIEBjbGFzcyBwNS5QYW5uZXIzRFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cblxuICBwNS5QYW5uZXIzRCA9IGZ1bmN0aW9uICgpIHtcbiAgICBFZmZlY3QuY2FsbCh0aGlzKTtcbiAgICAvKipcbiAgICAgKiAgPGEgdGl0bGU9XCJXZWIgQXVkaW8gUGFubmVyIGRvY3NcIiAgaHJlZj1cbiAgICAgKiAgXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGFubmVyTm9kZVwiPlxuICAgICAqICBXZWIgQXVkaW8gU3BhdGlhbCBQYW5uZXIgTm9kZTwvYT5cbiAgICAgKlxuICAgICAqICBQcm9wZXJ0aWVzIGluY2x1ZGVcbiAgICAgKiAgICAtICA8YSB0aXRsZT1cInczIHNwZWMgZm9yIFBhbm5pbmcgTW9kZWxcIlxuICAgICAqICAgIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI2lkbC1kZWYtUGFubmluZ01vZGVsVHlwZVwiXG4gICAgICogICAgPnBhbm5pbmdNb2RlbDwvYT46IFwiZXF1YWwgcG93ZXJcIiBvciBcIkhSVEZcIlxuICAgICAqICAgIC0gIDxhIHRpdGxlPVwidzMgc3BlYyBmb3IgRGlzdGFuY2UgTW9kZWxcIlxuICAgICAqICAgIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI2lkbC1kZWYtRGlzdGFuY2VNb2RlbFR5cGVcIlxuICAgICAqICAgID5kaXN0YW5jZU1vZGVsPC9hPjogXCJsaW5lYXJcIiwgXCJpbnZlcnNlXCIsIG9yIFwiZXhwb25lbnRpYWxcIlxuICAgICAqXG4gICAgICogIEBwcm9wZXJ0eSB7QXVkaW9Ob2RlfSBwYW5uZXJcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdGhpcy5wYW5uZXIgPSB0aGlzLmFjLmNyZWF0ZVBhbm5lcigpO1xuICAgIHRoaXMucGFubmVyLnBhbm5pbmdNb2RlbCA9ICdIUlRGJztcbiAgICB0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gJ2xpbmVhcic7XG4gICAgdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMucGFubmVyKTtcbiAgfTtcblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVmZmVjdC5wcm90b3R5cGUpO1xuICAvKipcbiAgICogQ29ubmVjdCBhbiBhdWRpbyBzb3JjZVxuICAgKlxuICAgKiBAbWV0aG9kICBwcm9jZXNzXG4gICAqIEBmb3IgcDUuUGFubmVyM0RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzcmMgSW5wdXQgc291cmNlXG4gICAqL1xuXG4gIHA1LlBhbm5lcjNELnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRoZSBYLFksWiBwb3NpdGlvbiBvZiB0aGUgUGFubmVyXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBmb3IgcDUuUGFubmVyM0RcbiAgICogQHBhcmFtICB7TnVtYmVyfSB4VmFsXG4gICAqIEBwYXJhbSAge051bWJlcn0geVZhbFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHpWYWxcbiAgICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgIFVwZGF0ZWQgeCwgeSwgeiB2YWx1ZXMgYXMgYW4gYXJyYXlcbiAgICovXG5cblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHhWYWwsIHlWYWwsIHpWYWwsIHRpbWUpIHtcbiAgICB0aGlzLnBvc2l0aW9uWCh4VmFsLCB0aW1lKTtcbiAgICB0aGlzLnBvc2l0aW9uWSh5VmFsLCB0aW1lKTtcbiAgICB0aGlzLnBvc2l0aW9uWih6VmFsLCB0aW1lKTtcbiAgICByZXR1cm4gW3RoaXMucGFubmVyLnBvc2l0aW9uWC52YWx1ZSwgdGhpcy5wYW5uZXIucG9zaXRpb25ZLnZhbHVlLCB0aGlzLnBhbm5lci5wb3NpdGlvbloudmFsdWVdO1xuICB9O1xuICAvKipcbiAgICogR2V0dGVyIGFuZCBzZXR0ZXIgbWV0aG9kcyBmb3IgcG9zaXRpb24gY29vcmRpbmF0ZXNcbiAgICogQG1ldGhvZCBwb3NpdGlvblhcbiAgICogQGZvciBwNS5QYW5uZXIzRFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgdXBkYXRlZCBjb29yZGluYXRlIHZhbHVlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXR0ZXIgYW5kIHNldHRlciBtZXRob2RzIGZvciBwb3NpdGlvbiBjb29yZGluYXRlc1xuICAgKiBAbWV0aG9kIHBvc2l0aW9uWVxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICB1cGRhdGVkIGNvb3JkaW5hdGUgdmFsdWVcbiAgICovXG5cbiAgLyoqXG4gICAqIEdldHRlciBhbmQgc2V0dGVyIG1ldGhvZHMgZm9yIHBvc2l0aW9uIGNvb3JkaW5hdGVzXG4gICAqIEBtZXRob2QgcG9zaXRpb25aXG4gICAqIEBmb3IgcDUuUGFubmVyM0RcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgIHVwZGF0ZWQgY29vcmRpbmF0ZSB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LlBhbm5lcjNELnByb3RvdHlwZS5wb3NpdGlvblggPSBmdW5jdGlvbiAoeFZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB4VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25YLnZhbHVlID0geFZhbDtcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh4VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoeFZhbCkge1xuICAgICAgeFZhbC5jb25uZWN0KHRoaXMucGFubmVyLnBvc2l0aW9uWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLnBvc2l0aW9uWC52YWx1ZTtcbiAgfTtcblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUucG9zaXRpb25ZID0gZnVuY3Rpb24gKHlWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgeVZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWS52YWx1ZSA9IHlWYWw7XG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvblkuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoeVZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHlWYWwpIHtcbiAgICAgIHlWYWwuY29ubmVjdCh0aGlzLnBhbm5lci5wb3NpdGlvblkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhbm5lci5wb3NpdGlvblkudmFsdWU7XG4gIH07XG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlLnBvc2l0aW9uWiA9IGZ1bmN0aW9uICh6VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHpWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvbloudmFsdWUgPSB6VmFsO1xuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25aLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHpWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh6VmFsKSB7XG4gICAgICB6VmFsLmNvbm5lY3QodGhpcy5wYW5uZXIucG9zaXRpb25aKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYW5uZXIucG9zaXRpb25aLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRoZSBYLFksWiBwb3NpdGlvbiBvZiB0aGUgUGFubmVyXG4gICAqIEBtZXRob2QgIG9yaWVudFxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEBwYXJhbSAge051bWJlcn0geFZhbFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlWYWxcbiAgICogQHBhcmFtICB7TnVtYmVyfSB6VmFsXG4gICAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICBVcGRhdGVkIHgsIHksIHogdmFsdWVzIGFzIGFuIGFycmF5XG4gICAqL1xuXG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlLm9yaWVudCA9IGZ1bmN0aW9uICh4VmFsLCB5VmFsLCB6VmFsLCB0aW1lKSB7XG4gICAgdGhpcy5vcmllbnRYKHhWYWwsIHRpbWUpO1xuICAgIHRoaXMub3JpZW50WSh5VmFsLCB0aW1lKTtcbiAgICB0aGlzLm9yaWVudFooelZhbCwgdGltZSk7XG4gICAgcmV0dXJuIFt0aGlzLnBhbm5lci5vcmllbnRhdGlvblgudmFsdWUsIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWS52YWx1ZSwgdGhpcy5wYW5uZXIub3JpZW50YXRpb25aLnZhbHVlXTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHRlciBhbmQgc2V0dGVyIG1ldGhvZHMgZm9yIG9yaWVudCBjb29yZGluYXRlc1xuICAgKiBAbWV0aG9kIG9yaWVudFhcbiAgICogQGZvciBwNS5QYW5uZXIzRFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgdXBkYXRlZCBjb29yZGluYXRlIHZhbHVlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXR0ZXIgYW5kIHNldHRlciBtZXRob2RzIGZvciBvcmllbnQgY29vcmRpbmF0ZXNcbiAgICogQG1ldGhvZCBvcmllbnRZXG4gICAqIEBmb3IgcDUuUGFubmVyM0RcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgIHVwZGF0ZWQgY29vcmRpbmF0ZSB2YWx1ZVxuICAgKi9cblxuICAvKipcbiAgICogR2V0dGVyIGFuZCBzZXR0ZXIgbWV0aG9kcyBmb3Igb3JpZW50IGNvb3JkaW5hdGVzXG4gICAqIEBtZXRob2Qgb3JpZW50WlxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICB1cGRhdGVkIGNvb3JkaW5hdGUgdmFsdWVcbiAgICovXG5cblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUub3JpZW50WCA9IGZ1bmN0aW9uICh4VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHhWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblgudmFsdWUgPSB4VmFsO1xuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25YLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHhWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh4VmFsKSB7XG4gICAgICB4VmFsLmNvbm5lY3QodGhpcy5wYW5uZXIub3JpZW50YXRpb25YKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYW5uZXIub3JpZW50YXRpb25YLnZhbHVlO1xuICB9O1xuXG4gIHA1LlBhbm5lcjNELnByb3RvdHlwZS5vcmllbnRZID0gZnVuY3Rpb24gKHlWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgeVZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWS52YWx1ZSA9IHlWYWw7XG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblkuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoeVZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHlWYWwpIHtcbiAgICAgIHlWYWwuY29ubmVjdCh0aGlzLnBhbm5lci5vcmllbnRhdGlvblkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhbm5lci5vcmllbnRhdGlvblkudmFsdWU7XG4gIH07XG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlLm9yaWVudFogPSBmdW5jdGlvbiAoelZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB6VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25aLnZhbHVlID0gelZhbDtcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh6VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoelZhbCkge1xuICAgICAgelZhbC5jb25uZWN0KHRoaXMucGFubmVyLm9yaWVudGF0aW9uWik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWi52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldCB0aGUgcm9sbG9mZiBmYWN0b3IgYW5kIG1heCBkaXN0YW5jZVxuICAgKiBAbWV0aG9kICBzZXRGYWxsb2ZmXG4gICAqIEBmb3IgcDUuUGFubmVyM0RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhEaXN0YW5jZV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyb2xsb2ZmRmFjdG9yXVxuICAgKi9cblxuXG4gIHA1LlBhbm5lcjNELnByb3RvdHlwZS5zZXRGYWxsb2ZmID0gZnVuY3Rpb24gKG1heERpc3RhbmNlLCByb2xsb2ZmRmFjdG9yKSB7XG4gICAgdGhpcy5tYXhEaXN0KG1heERpc3RhbmNlKTtcbiAgICB0aGlzLnJvbGxvZmYocm9sbG9mZkZhY3Rvcik7XG4gIH07XG4gIC8qKlxuICAgKiBNYXhpdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgc291cmNlIGFuZCB0aGUgbGlzdGVuZXJcbiAgICogQG1ldGhvZCAgbWF4RGlzdFxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEBwYXJhbSAge051bWJlcn0gbWF4RGlzdGFuY2VcbiAgICogQHJldHVybiB7TnVtYmVyfSB1cGRhdGVkIHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlLm1heERpc3QgPSBmdW5jdGlvbiAobWF4RGlzdGFuY2UpIHtcbiAgICBpZiAodHlwZW9mIG1heERpc3RhbmNlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYW5uZXIubWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYW5uZXIubWF4RGlzdGFuY2U7XG4gIH07XG4gIC8qKlxuICAgKiBIb3cgcXVpY2tseSB0aGUgdm9sdW1lIGlzIHJlZHVjZWQgYXMgdGhlIHNvdXJjZSBtb3ZlcyBhd2F5IGZyb20gdGhlIGxpc3RlbmVyXG4gICAqIEBtZXRob2QgIHJvbGxvZlxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEBwYXJhbSAge051bWJlcn0gcm9sbG9mZkZhY3RvclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHVwZGF0ZWQgdmFsdWVcbiAgICovXG5cblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUucm9sbG9mZiA9IGZ1bmN0aW9uIChyb2xsb2ZmRmFjdG9yKSB7XG4gICAgaWYgKHR5cGVvZiByb2xsb2ZmRmFjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHJvbGxvZmZGYWN0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XG4gIH07XG5cbiAgcDUuUGFubmVyM0QuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcyk7XG5cbiAgICBpZiAodGhpcy5wYW5uZXIpIHtcbiAgICAgIHRoaXMucGFubmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBhbm5lcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHA1LlBhbm5lcjNEO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgRWZmZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTsgXG4gIC8vICAgKiBsaXN0ZW5lciBpcyBhIGNsYXNzIHRoYXQgY2FuIGNvbnN0cnVjdCBib3RoIGEgU3BhdGlhbCBQYW5uZXJcbiAgLy8gICAqIGFuZCBhIFNwYXRpYWwgTGlzdGVuZXIuIFRoZSBwYW5uZXIgaXMgYmFzZWQgb24gdGhlIFxuICAvLyAgICogV2ViIEF1ZGlvIFNwYXRpYWwgUGFubmVyIE5vZGVcbiAgLy8gICAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jdGhlLWxpc3RlbmVybm9kZS1pbnRlcmZhY2VcbiAgLy8gICAqIFRoaXMgcGFubmVyIGlzIGEgc3BhdGlhbCBwcm9jZXNzaW5nIG5vZGUgdGhhdCBhbGxvd3MgYXVkaW8gdG8gYmUgcG9zaXRpb25lZFxuICAvLyAgICogYW5kIG9yaWVudGVkIGluIDNEIHNwYWNlLiBcbiAgLy8gICAqXG4gIC8vICAgKiBUaGUgTGlzdGVuZXIgbW9kaWZpZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIEF1ZGlvIENvbnRleHQgTGlzdGVuZXIuIFxuICAvLyAgICogQm90aCBvYmplY3RzIHR5cGVzIHVzZSB0aGUgc2FtZSBtZXRob2RzLiBUaGUgZGVmYXVsdCBpcyBhIHNwYXRpYWwgcGFubmVyLlxuICAvLyAgICpcbiAgLy8gICAqIDxjb2RlPnA1LlBhbm5lcjNEPC9jb2RlPiAtIENvbnN0cnVjdHMgYSBTcGF0aWFsIFBhbm5lcjxici8+XG4gIC8vICAgKiA8Y29kZT5wNS5MaXN0ZW5lcjNEPC9jb2RlPiAtIENvbnN0cnVjdHMgYSBTcGF0aWFsIExpc3RlbmVyPGJyLz5cbiAgLy8gICAqXG4gIC8vICAgKiBAY2xhc3MgbGlzdGVuZXJcbiAgLy8gICAqIEBjb25zdHJ1Y3RvclxuICAvLyAgICogQHJldHVybiB7T2JqZWN0fSBwNS5MaXN0ZW5lcjNEIE9iamVjdFxuICAvLyAgICpcbiAgLy8gICAqIEBwYXJhbSB7V2ViIEF1ZGlvIE5vZGV9IGxpc3RlbmVyIFdlYiBBdWRpbyBTcGF0aWFsIFBhbm5pbmcgTm9kZVxuICAvLyAgICogQHBhcmFtIHtBdWRpb1BhcmFtfSBsaXN0ZW5lci5wYW5uaW5nTW9kZWwgXCJlcXVhbCBwb3dlclwiIG9yIFwiSFJURlwiXG4gIC8vICAgKiBAcGFyYW0ge0F1ZGlvUGFyYW19IGxpc3RlbmVyLmRpc3RhbmNlTW9kZWwgXCJsaW5lYXJcIiwgXCJpbnZlcnNlXCIsIG9yIFwiZXhwb25lbnRpYWxcIlxuICAvLyAgICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBbU3BlY2lmeSBjb25zdHJ1Y3Rpb24gb2YgYSBzcGF0aWFsIHBhbm5lciBvciBsaXN0ZW5lcl1cbiAgLy8gICAqL1xuXG5cbiAgcDUuTGlzdGVuZXIzRCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGhpcy5hYyA9IHA1c291bmQuYXVkaW9jb250ZXh0O1xuICAgIHRoaXMubGlzdGVuZXIgPSB0aGlzLmFjLmxpc3RlbmVyO1xuICB9OyBcbiAgLy8gICAqIENvbm5lY3QgYW4gYXVkaW8gc29yY2VcbiAgLy8gICAqIEBwYXJhbSAge09iamVjdH0gc3JjIElucHV0IHNvdXJjZVxuICAvLyAgICovXG5cblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICB9OyBcbiAgLy8gICAqIFNldCB0aGUgWCxZLFogcG9zaXRpb24gb2YgdGhlIFBhbm5lclxuICAvLyAgICogQHBhcmFtICB7W051bWJlcl19IHhWYWxcbiAgLy8gICAqIEBwYXJhbSAge1tOdW1iZXJdfSB5VmFsXG4gIC8vICAgKiBAcGFyYW0gIHtbTnVtYmVyXX0gelZhbFxuICAvLyAgICogQHBhcmFtICB7W051bWJlcl19IHRpbWVcbiAgLy8gICAqIEByZXR1cm4ge1tBcnJheV19ICAgICAgW1VwZGF0ZWQgeCwgeSwgeiB2YWx1ZXMgYXMgYW4gYXJyYXldXG4gIC8vICAgKi9cblxuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKHhWYWwsIHlWYWwsIHpWYWwsIHRpbWUpIHtcbiAgICB0aGlzLnBvc2l0aW9uWCh4VmFsLCB0aW1lKTtcbiAgICB0aGlzLnBvc2l0aW9uWSh5VmFsLCB0aW1lKTtcbiAgICB0aGlzLnBvc2l0aW9uWih6VmFsLCB0aW1lKTtcbiAgICByZXR1cm4gW3RoaXMubGlzdGVuZXIucG9zaXRpb25YLnZhbHVlLCB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWS52YWx1ZSwgdGhpcy5saXN0ZW5lci5wb3NpdGlvbloudmFsdWVdO1xuICB9OyBcbiAgLy8gICAqIEdldHRlciBhbmQgc2V0dGVyIG1ldGhvZHMgZm9yIHBvc2l0aW9uIGNvb3JkaW5hdGVzXG4gIC8vICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgW3VwZGF0ZWQgY29vcmRpbmF0ZSB2YWx1ZV1cbiAgLy8gICAqL1xuXG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUucG9zaXRpb25YID0gZnVuY3Rpb24gKHhWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgeFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIucG9zaXRpb25YLnZhbHVlID0geFZhbDtcbiAgICAgIHRoaXMubGlzdGVuZXIucG9zaXRpb25YLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5saXN0ZW5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoeFZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHhWYWwpIHtcbiAgICAgIHhWYWwuY29ubmVjdCh0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIucG9zaXRpb25YLnZhbHVlO1xuICB9O1xuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLnBvc2l0aW9uWSA9IGZ1bmN0aW9uICh5VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHlWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWS52YWx1ZSA9IHlWYWw7XG4gICAgICB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMubGlzdGVuZXIucG9zaXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHlWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh5VmFsKSB7XG4gICAgICB5VmFsLmNvbm5lY3QodGhpcy5saXN0ZW5lci5wb3NpdGlvblkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWS52YWx1ZTtcbiAgfTtcblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS5wb3NpdGlvblogPSBmdW5jdGlvbiAoelZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB6VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5saXN0ZW5lci5wb3NpdGlvbloudmFsdWUgPSB6VmFsO1xuICAgICAgdGhpcy5saXN0ZW5lci5wb3NpdGlvblouY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh6VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoelZhbCkge1xuICAgICAgelZhbC5jb25uZWN0KHRoaXMubGlzdGVuZXIucG9zaXRpb25aKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5wb3NpdGlvbloudmFsdWU7XG4gIH07IFxuICAvLyAgICogT3ZlcnJpZGVzIHRoZSBsaXN0ZW5lciBvcmllbnQoKSBtZXRob2QgYmVjYXVzZSBMaXN0ZW5lciBoYXMgc2xpZ2h0bHlcbiAgLy8gICAqIGRpZmZlcmVudCBwYXJhbXMuIEluIGh1bWFuIHRlcm1zLCBGb3J3YXJkIHZlY3RvcnMgYXJlIHRoZSBkaXJlY3Rpb24gdGhlIFxuICAvLyAgICogbm9zZSBpcyBwb2ludGluZy4gVXAgdmVjdG9ycyBhcmUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdG9wIG9mIHRoZSBoZWFkLlxuICAvLyAgICpcbiAgLy8gICAqIEBtZXRob2Qgb3JpZW50XG4gIC8vICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhWYWxGICBGb3J3YXJkIHZlY3RvciBYIGRpcmVjdGlvblxuICAvLyAgICogQHBhcmFtICB7TnVtYmVyfSB5VmFsRiAgRm9yd2FyZCB2ZWN0b3IgWSBkaXJlY3Rpb25cbiAgLy8gICAqIEBwYXJhbSAge051bWJlcn0gelZhbEYgIEZvcndhcmQgdmVjdG9yIFogZGlyZWN0aW9uXG4gIC8vICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhWYWxVICBVcCB2ZWN0b3IgWCBkaXJlY3Rpb25cbiAgLy8gICAqIEBwYXJhbSAge051bWJlcn0geVZhbFUgIFVwIHZlY3RvciBZIGRpcmVjdGlvblxuICAvLyAgICogQHBhcmFtICB7TnVtYmVyfSB6VmFsVSAgVXAgdmVjdG9yIFogZGlyZWN0aW9uXG4gIC8vICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgIFxuICAvLyAgICogQHJldHVybiB7QXJyYXl9ICAgICAgIEFsbCBvcmllbmF0aW9uIHBhcmFtc1xuICAvLyAgICovXG5cblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS5vcmllbnQgPSBmdW5jdGlvbiAoeFZhbEYsIHlWYWxGLCB6VmFsRiwgeFZhbFUsIHlWYWxVLCB6VmFsVSwgdGltZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRpbWUgPSBhcmd1bWVudHNbM107XG4gICAgICB0aGlzLm9yaWVudEZvcndhcmQoeFZhbEYsIHlWYWxGLCB6VmFsRiwgdGltZSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA2IHx8IGFyZ3VtZW50cyA9PT0gNykge1xuICAgICAgdGhpcy5vcmllbnRGb3J3YXJkKHhWYWxGLCB5VmFsRiwgelZhbEYpO1xuICAgICAgdGhpcy5vcmllbnRVcCh4VmFsVSwgeVZhbFUsIHpWYWxVLCB0aW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3RoaXMubGlzdGVuZXIuZm9yd2FyZFgudmFsdWUsIHRoaXMubGlzdGVuZXIuZm9yd2FyZFkudmFsdWUsIHRoaXMubGlzdGVuZXIuZm9yd2FyZFoudmFsdWUsIHRoaXMubGlzdGVuZXIudXBYLnZhbHVlLCB0aGlzLmxpc3RlbmVyLnVwWS52YWx1ZSwgdGhpcy5saXN0ZW5lci51cFoudmFsdWVdO1xuICB9O1xuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLm9yaWVudEZvcndhcmQgPSBmdW5jdGlvbiAoeFZhbEYsIHlWYWxGLCB6VmFsRiwgdGltZSkge1xuICAgIHRoaXMuZm9yd2FyZFgoeFZhbEYsIHRpbWUpO1xuICAgIHRoaXMuZm9yd2FyZFkoeVZhbEYsIHRpbWUpO1xuICAgIHRoaXMuZm9yd2FyZFooelZhbEYsIHRpbWUpO1xuICAgIHJldHVybiBbdGhpcy5saXN0ZW5lci5mb3J3YXJkWCwgdGhpcy5saXN0ZW5lci5mb3J3YXJkWSwgdGhpcy5saXN0ZW5lci5mb3J3YXJkWl07XG4gIH07XG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUub3JpZW50VXAgPSBmdW5jdGlvbiAoeFZhbFUsIHlWYWxVLCB6VmFsVSwgdGltZSkge1xuICAgIHRoaXMudXBYKHhWYWxVLCB0aW1lKTtcbiAgICB0aGlzLnVwWSh5VmFsVSwgdGltZSk7XG4gICAgdGhpcy51cFooelZhbFUsIHRpbWUpO1xuICAgIHJldHVybiBbdGhpcy5saXN0ZW5lci51cFgsIHRoaXMubGlzdGVuZXIudXBZLCB0aGlzLmxpc3RlbmVyLnVwWl07XG4gIH07IFxuICAvLyAgICogR2V0dGVyIGFuZCBzZXR0ZXIgbWV0aG9kcyBmb3Igb3JpZW50IGNvb3JkaW5hdGVzXG4gIC8vICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgW3VwZGF0ZWQgY29vcmRpbmF0ZSB2YWx1ZV1cbiAgLy8gICAqL1xuXG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUuZm9yd2FyZFggPSBmdW5jdGlvbiAoeFZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB4VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5saXN0ZW5lci5mb3J3YXJkWC52YWx1ZSA9IHhWYWw7XG4gICAgICB0aGlzLmxpc3RlbmVyLmZvcndhcmRYLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5saXN0ZW5lci5mb3J3YXJkWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh4VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoeFZhbCkge1xuICAgICAgeFZhbC5jb25uZWN0KHRoaXMubGlzdGVuZXIuZm9yd2FyZFgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmZvcndhcmRYLnZhbHVlO1xuICB9O1xuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLmZvcndhcmRZID0gZnVuY3Rpb24gKHlWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgeVZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIuZm9yd2FyZFkudmFsdWUgPSB5VmFsO1xuICAgICAgdGhpcy5saXN0ZW5lci5mb3J3YXJkWS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMubGlzdGVuZXIuZm9yd2FyZFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoeVZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHlWYWwpIHtcbiAgICAgIHlWYWwuY29ubmVjdCh0aGlzLmxpc3RlbmVyLmZvcndhcmRZKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5mb3J3YXJkWS52YWx1ZTtcbiAgfTtcblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS5mb3J3YXJkWiA9IGZ1bmN0aW9uICh6VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHpWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyLmZvcndhcmRaLnZhbHVlID0gelZhbDtcbiAgICAgIHRoaXMubGlzdGVuZXIuZm9yd2FyZFouY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmxpc3RlbmVyLmZvcndhcmRaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHpWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh6VmFsKSB7XG4gICAgICB6VmFsLmNvbm5lY3QodGhpcy5saXN0ZW5lci5mb3J3YXJkWik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuZm9yd2FyZFoudmFsdWU7XG4gIH07XG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUudXBYID0gZnVuY3Rpb24gKHhWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgeFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIudXBYLnZhbHVlID0geFZhbDtcbiAgICAgIHRoaXMubGlzdGVuZXIudXBYLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5saXN0ZW5lci51cFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoeFZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHhWYWwpIHtcbiAgICAgIHhWYWwuY29ubmVjdCh0aGlzLmxpc3RlbmVyLnVwWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIudXBYLnZhbHVlO1xuICB9O1xuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLnVwWSA9IGZ1bmN0aW9uICh5VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHlWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyLnVwWS52YWx1ZSA9IHlWYWw7XG4gICAgICB0aGlzLmxpc3RlbmVyLnVwWS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMubGlzdGVuZXIudXBZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHlWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh5VmFsKSB7XG4gICAgICB5VmFsLmNvbm5lY3QodGhpcy5saXN0ZW5lci51cFkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLnVwWS52YWx1ZTtcbiAgfTtcblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS51cFogPSBmdW5jdGlvbiAoelZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB6VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5saXN0ZW5lci51cFoudmFsdWUgPSB6VmFsO1xuICAgICAgdGhpcy5saXN0ZW5lci51cFouY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmxpc3RlbmVyLnVwWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh6VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoelZhbCkge1xuICAgICAgelZhbC5jb25uZWN0KHRoaXMubGlzdGVuZXIudXBaKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci51cFoudmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIHA1Lkxpc3RlbmVyM0Q7XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIEZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG4gIHZhciBFZmZlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuICAvKipcbiAgICogIERlbGF5IGlzIGFuIGVjaG8gZWZmZWN0LiBJdCBwcm9jZXNzZXMgYW4gZXhpc3Rpbmcgc291bmQgc291cmNlLFxuICAgKiAgYW5kIG91dHB1dHMgYSBkZWxheWVkIHZlcnNpb24gb2YgdGhhdCBzb3VuZC4gVGhlIHA1LkRlbGF5IGNhblxuICAgKiAgcHJvZHVjZSBkaWZmZXJlbnQgZWZmZWN0cyBkZXBlbmRpbmcgb24gdGhlIGRlbGF5VGltZSwgZmVlZGJhY2ssXG4gICAqICBmaWx0ZXIsIGFuZCB0eXBlLiBJbiB0aGUgZXhhbXBsZSBiZWxvdywgYSBmZWVkYmFjayBvZiAwLjUgKHRoZVxuICAgKiAgZGVmYXVsdCB2YWx1ZSkgd2lsbCBwcm9kdWNlIGEgbG9vcGluZyBkZWxheSB0aGF0IGRlY3JlYXNlcyBpblxuICAgKiAgdm9sdW1lIGJ5IDUwJSBlYWNoIHJlcGVhdC4gQSBmaWx0ZXIgd2lsbCBjdXQgb3V0IHRoZSBoaWdoXG4gICAqICBmcmVxdWVuY2llcyBzbyB0aGF0IHRoZSBkZWxheSBkb2VzIG5vdCBzb3VuZCBhcyBwaWVyY2luZyBhcyB0aGVcbiAgICogIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICpcbiAgICogIFRoaXMgY2xhc3MgZXh0ZW5kcyA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0XCI+cDUuRWZmZWN0PC9hPi5cbiAgICogIE1ldGhvZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9hbXBcIj5hbXAoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY2hhaW5cIj5jaGFpbigpPC9hPixcbiAgICogIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZHJ5d2V0XCI+ZHJ5d2V0KCk8L2E+LCA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Nvbm5lY3RcIj5jb25uZWN0KCk8L2E+LCBhbmRcbiAgICogIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZGlzY29ubmVjdFwiPmRpc2Nvbm5lY3QoKTwvYT4gYXJlIGF2YWlsYWJsZS5cbiAgICogIEBjbGFzcyBwNS5EZWxheVxuICAgKiAgQGV4dGVuZHMgcDUuRWZmZWN0XG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IG9zYztcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqXG4gICAqICAgIG9zYyA9IG5ldyBwNS5Pc2NpbGxhdG9yKCdzcXVhcmUnKTtcbiAgICogICAgb3NjLmFtcCgwLjUpO1xuICAgKiAgICBkZWxheSA9IG5ldyBwNS5EZWxheSgpO1xuICAgKlxuICAgKiAgICAvLyBkZWxheS5wcm9jZXNzKCkgYWNjZXB0cyA0IHBhcmFtZXRlcnM6XG4gICAqICAgIC8vIHNvdXJjZSwgZGVsYXlUaW1lIChpbiBzZWNvbmRzKSwgZmVlZGJhY2ssIGZpbHRlciBmcmVxdWVuY3lcbiAgICogICAgZGVsYXkucHJvY2Vzcyhvc2MsIDAuMTIsIC43LCAyMzAwKTtcbiAgICpcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChvc2NTdGFydCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBvc2NTdGFydCgpIHtcbiAgICogICAgb3NjLnN0YXJ0KCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICBvc2Muc3RvcCgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkRlbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIEVmZmVjdC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3NwbGl0ID0gdGhpcy5hYy5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoMik7XG4gICAgdGhpcy5fbWVyZ2UgPSB0aGlzLmFjLmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XG4gICAgdGhpcy5fbGVmdEdhaW4gPSB0aGlzLmFjLmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLl9yaWdodEdhaW4gPSB0aGlzLmFjLmNyZWF0ZUdhaW4oKTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHA1LkRlbGF5IGlzIGJ1aWx0IHdpdGggdHdvXG4gICAgICogIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jRGVsYXlOb2RlXCI+XG4gICAgICogIFdlYiBBdWRpbyBEZWxheSBOb2RlczwvYT4sIG9uZSBmb3IgZWFjaCBzdGVyZW8gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqICBAZm9yIHA1LkRlbGF5XG4gICAgICogIEBwcm9wZXJ0eSB7RGVsYXlOb2RlfSBsZWZ0RGVsYXlcbiAgICAgKi9cblxuICAgIHRoaXMubGVmdERlbGF5ID0gdGhpcy5hYy5jcmVhdGVEZWxheSgpO1xuICAgIC8qKlxuICAgICAqICBUaGUgcDUuRGVsYXkgaXMgYnVpbHQgd2l0aCB0d29cbiAgICAgKiAgPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNEZWxheU5vZGVcIj5cbiAgICAgKiAgV2ViIEF1ZGlvIERlbGF5IE5vZGVzPC9hPiwgb25lIGZvciBlYWNoIHN0ZXJlbyBjaGFubmVsLlxuICAgICAqICBAZm9yIHA1LkRlbGF5XG4gICAgICogIEBwcm9wZXJ0eSB7RGVsYXlOb2RlfSByaWdodERlbGF5XG4gICAgICovXG5cbiAgICB0aGlzLnJpZ2h0RGVsYXkgPSB0aGlzLmFjLmNyZWF0ZURlbGF5KCk7XG4gICAgdGhpcy5fbGVmdEZpbHRlciA9IG5ldyBGaWx0ZXIoKTtcbiAgICB0aGlzLl9yaWdodEZpbHRlciA9IG5ldyBGaWx0ZXIoKTtcblxuICAgIHRoaXMuX2xlZnRGaWx0ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy5fcmlnaHRGaWx0ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy5fbGVmdEZpbHRlci5iaXF1YWQuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKDEyMDAsIHRoaXMuYWMuY3VycmVudFRpbWUpO1xuXG4gICAgdGhpcy5fcmlnaHRGaWx0ZXIuYmlxdWFkLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSgxMjAwLCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcblxuICAgIHRoaXMuX2xlZnRGaWx0ZXIuYmlxdWFkLlEuc2V0VmFsdWVBdFRpbWUoMC4zLCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcblxuICAgIHRoaXMuX3JpZ2h0RmlsdGVyLmJpcXVhZC5RLnNldFZhbHVlQXRUaW1lKDAuMywgdGhpcy5hYy5jdXJyZW50VGltZSk7IFxuXG5cbiAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fc3BsaXQpO1xuICAgIHRoaXMubGVmdERlbGF5LmNvbm5lY3QodGhpcy5fbGVmdEdhaW4pO1xuICAgIHRoaXMucmlnaHREZWxheS5jb25uZWN0KHRoaXMuX3JpZ2h0R2Fpbik7XG5cbiAgICB0aGlzLl9sZWZ0R2Fpbi5jb25uZWN0KHRoaXMuX2xlZnRGaWx0ZXIuaW5wdXQpO1xuXG4gICAgdGhpcy5fcmlnaHRHYWluLmNvbm5lY3QodGhpcy5fcmlnaHRGaWx0ZXIuaW5wdXQpO1xuXG4gICAgdGhpcy5fbWVyZ2UuY29ubmVjdCh0aGlzLndldCk7XG5cbiAgICB0aGlzLl9sZWZ0RmlsdGVyLmJpcXVhZC5nYWluLnNldFZhbHVlQXRUaW1lKDEsIHRoaXMuYWMuY3VycmVudFRpbWUpO1xuXG4gICAgdGhpcy5fcmlnaHRGaWx0ZXIuYmlxdWFkLmdhaW4uc2V0VmFsdWVBdFRpbWUoMSwgdGhpcy5hYy5jdXJyZW50VGltZSk7IFxuXG5cbiAgICB0aGlzLnNldFR5cGUoMCk7XG4gICAgdGhpcy5fbWF4RGVsYXkgPSB0aGlzLmxlZnREZWxheS5kZWxheVRpbWUubWF4VmFsdWU7IFxuXG4gICAgdGhpcy5mZWVkYmFjaygwLjUpO1xuICB9O1xuXG4gIHA1LkRlbGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWZmZWN0LnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiAgQWRkIGRlbGF5IHRvIGFuIGF1ZGlvIHNpZ25hbCBhY2NvcmRpbmcgdG8gYSBzZXRcbiAgICogIG9mIGRlbGF5IHBhcmFtZXRlcnMuXG4gICAqXG4gICAqICBAbWV0aG9kICBwcm9jZXNzXG4gICAqICBAZm9yIHA1LkRlbGF5XG4gICAqICBAcGFyYW0gIHtPYmplY3R9IFNpZ25hbCAgQW4gb2JqZWN0IHRoYXQgb3V0cHV0cyBhdWRpb1xuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbZGVsYXlUaW1lXSBUaW1lIChpbiBzZWNvbmRzKSBvZiB0aGUgZGVsYXkvZWNoby5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU29tZSBicm93c2VycyBsaW1pdCBkZWxheVRpbWUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSBzZWNvbmQuXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtmZWVkYmFja10gIHNlbmRzIHRoZSBkZWxheSBiYWNrIHRocm91Z2ggaXRzZWxmXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGEgbG9vcCB0aGF0IGRlY3JlYXNlcyBpbiB2b2x1bWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCB0aW1lLlxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbbG93UGFzc10gICBDdXRvZmYgZnJlcXVlbmN5LiBPbmx5IGZyZXF1ZW5jaWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlbG93IHRoZSBsb3dQYXNzIHdpbGwgYmUgcGFydCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXkuXG4gICAqL1xuXG4gIHA1LkRlbGF5LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgX2RlbGF5VGltZSwgX2ZlZWRiYWNrLCBfZmlsdGVyKSB7XG4gICAgdmFyIGZlZWRiYWNrID0gX2ZlZWRiYWNrIHx8IDA7XG4gICAgdmFyIGRlbGF5VGltZSA9IF9kZWxheVRpbWUgfHwgMDtcblxuICAgIGlmIChmZWVkYmFjayA+PSAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmVlZGJhY2sgdmFsdWUgd2lsbCBmb3JjZSBhIHBvc2l0aXZlIGZlZWRiYWNrIGxvb3AuJyk7XG4gICAgfVxuXG4gICAgaWYgKGRlbGF5VGltZSA+PSB0aGlzLl9tYXhEZWxheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxheSBUaW1lIGV4Y2VlZHMgbWF4aW11bSBkZWxheSB0aW1lIG9mICcgKyB0aGlzLl9tYXhEZWxheSArICcgc2Vjb25kLicpO1xuICAgIH1cblxuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICAgIHRoaXMubGVmdERlbGF5LmRlbGF5VGltZS5zZXRWYWx1ZUF0VGltZShkZWxheVRpbWUsIHRoaXMuYWMuY3VycmVudFRpbWUpO1xuICAgIHRoaXMucmlnaHREZWxheS5kZWxheVRpbWUuc2V0VmFsdWVBdFRpbWUoZGVsYXlUaW1lLCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcbiAgICB0aGlzLl9sZWZ0R2Fpbi5nYWluLnZhbHVlID0gZmVlZGJhY2s7XG4gICAgdGhpcy5fcmlnaHRHYWluLmdhaW4udmFsdWUgPSBmZWVkYmFjaztcblxuICAgIGlmIChfZmlsdGVyKSB7XG4gICAgICB0aGlzLl9sZWZ0RmlsdGVyLmZyZXEoX2ZpbHRlcik7XG5cbiAgICAgIHRoaXMuX3JpZ2h0RmlsdGVyLmZyZXEoX2ZpbHRlcik7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgZGVsYXkgKGVjaG8pIHRpbWUsIGluIHNlY29uZHMuIFVzdWFsbHkgdGhpcyB2YWx1ZSB3aWxsIGJlXG4gICAqICBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAuMCBhbmQgMS4wLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZGVsYXlUaW1lXG4gICAqICBAZm9yIHA1LkRlbGF5XG4gICAqICBAcGFyYW0ge051bWJlcn0gZGVsYXlUaW1lIFRpbWUgKGluIHNlY29uZHMpIG9mIHRoZSBkZWxheVxuICAgKi9cblxuXG4gIHA1LkRlbGF5LnByb3RvdHlwZS5kZWxheVRpbWUgPSBmdW5jdGlvbiAodCkge1xuICAgIGlmICh0eXBlb2YgdCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHQuY29ubmVjdCh0aGlzLmxlZnREZWxheS5kZWxheVRpbWUpO1xuICAgICAgdC5jb25uZWN0KHRoaXMucmlnaHREZWxheS5kZWxheVRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlZnREZWxheS5kZWxheVRpbWUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUpO1xuICAgICAgdGhpcy5yaWdodERlbGF5LmRlbGF5VGltZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSk7XG4gICAgICB0aGlzLmxlZnREZWxheS5kZWxheVRpbWUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodCwgdGhpcy5hYy5jdXJyZW50VGltZSk7XG4gICAgICB0aGlzLnJpZ2h0RGVsYXkuZGVsYXlUaW1lLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHQsIHRoaXMuYWMuY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBGZWVkYmFjayBvY2N1cnMgd2hlbiBEZWxheSBzZW5kcyBpdHMgc2lnbmFsIGJhY2sgdGhyb3VnaCBpdHMgaW5wdXRcbiAgICogIGluIGEgbG9vcC4gVGhlIGZlZWRiYWNrIGFtb3VudCBkZXRlcm1pbmVzIGhvdyBtdWNoIHNpZ25hbCB0byBzZW5kIGVhY2hcbiAgICogIHRpbWUgdGhyb3VnaCB0aGUgbG9vcC4gQSBmZWVkYmFjayBncmVhdGVyIHRoYW4gMS4wIGlzIG5vdCBkZXNpcmFibGUgYmVjYXVzZVxuICAgKiAgaXQgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbCBvdXRwdXQgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsXG4gICAqICBjcmVhdGluZyBhbiBpbmZpbml0ZSBmZWVkYmFjayBsb29wLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjVcbiAgICpcbiAgICogIEBtZXRob2QgIGZlZWRiYWNrXG4gICAqICBAZm9yIHA1LkRlbGF5XG4gICAqICBAcGFyYW0ge051bWJlcnxPYmplY3R9IGZlZWRiYWNrIDAuMCB0byAxLjAsIG9yIGFuIG9iamVjdCBzdWNoIGFzIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9zY2lsbGF0b3IgdGhhdCBjYW4gYmUgdXNlZCB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGF0ZSB0aGlzIHBhcmFtXG4gICAqICBAcmV0dXJucyB7TnVtYmVyfSBGZWVkYmFjayB2YWx1ZVxuICAgKlxuICAgKi9cblxuXG4gIHA1LkRlbGF5LnByb3RvdHlwZS5mZWVkYmFjayA9IGZ1bmN0aW9uIChmKSB7XG4gICAgaWYgKGYgJiYgdHlwZW9mIGYgIT09ICdudW1iZXInKSB7XG4gICAgICBmLmNvbm5lY3QodGhpcy5fbGVmdEdhaW4uZ2Fpbik7XG4gICAgICBmLmNvbm5lY3QodGhpcy5fcmlnaHRHYWluLmdhaW4pO1xuICAgIH0gZWxzZSBpZiAoZiA+PSAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmVlZGJhY2sgdmFsdWUgd2lsbCBmb3JjZSBhIHBvc2l0aXZlIGZlZWRiYWNrIGxvb3AuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX2xlZnRHYWluLmdhaW4udmFsdWUgPSBmO1xuICAgICAgdGhpcy5fcmlnaHRHYWluLmdhaW4udmFsdWUgPSBmO1xuICAgIH0gXG5cblxuICAgIHJldHVybiB0aGlzLl9sZWZ0R2Fpbi5nYWluLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogIFNldCBhIGxvd3Bhc3MgZmlsdGVyIGZyZXF1ZW5jeSBmb3IgdGhlIGRlbGF5LiBBIGxvd3Bhc3MgZmlsdGVyXG4gICAqICB3aWxsIGN1dCBvZmYgYW55IGZyZXF1ZW5jaWVzIGhpZ2hlciB0aGFuIHRoZSBmaWx0ZXIgZnJlcXVlbmN5LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZmlsdGVyXG4gICAqICBAZm9yIHA1LkRlbGF5XG4gICAqICBAcGFyYW0ge051bWJlcnxPYmplY3R9IGN1dG9mZkZyZXEgIEEgbG93cGFzcyBmaWx0ZXIgd2lsbCBjdXQgb2ZmIGFueVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jaWVzIGhpZ2hlciB0aGFuIHRoZSBmaWx0ZXIgZnJlcXVlbmN5LlxuICAgKiAgQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSByZXMgIFJlc29uYW5jZSBvZiB0aGUgZmlsdGVyIGZyZXF1ZW5jeVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1dG9mZiwgb3IgYW4gb2JqZWN0IChpLmUuIGEgcDUuT3NjaWxsYXRvcilcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IGNhbiBiZSB1c2VkIHRvIG1vZHVsYXRlIHRoaXMgcGFyYW1ldGVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhpZ2ggbnVtYmVycyAoaS5lLiAxNSkgd2lsbCBwcm9kdWNlIGEgcmVzb25hbmNlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvdyBudW1iZXJzIChpLmUuIC4yKSB3aWxsIHByb2R1Y2UgYSBzbG9wZS5cbiAgICovXG5cblxuICBwNS5EZWxheS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZyZXEsIHEpIHtcbiAgICB0aGlzLl9sZWZ0RmlsdGVyLnNldChmcmVxLCBxKTtcblxuICAgIHRoaXMuX3JpZ2h0RmlsdGVyLnNldChmcmVxLCBxKTtcbiAgfTtcbiAgLyoqXG4gICAqICBDaG9vc2UgYSBwcmVzZXQgdHlwZSBvZiBkZWxheS4gJ3BpbmdQb25nJyBib3VuY2VzIHRoZSBzaWduYWxcbiAgICogIGZyb20gdGhlIGxlZnQgdG8gdGhlIHJpZ2h0IGNoYW5uZWwgdG8gcHJvZHVjZSBhIHN0ZXJlbyBlZmZlY3QuXG4gICAqICBBbnkgb3RoZXIgcGFyYW1ldGVyIHdpbGwgcmV2ZXJ0IHRvIHRoZSBkZWZhdWx0IGRlbGF5IHNldHRpbmcuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRUeXBlXG4gICAqICBAZm9yIHA1LkRlbGF5XG4gICAqICBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHR5cGUgJ3BpbmdQb25nJyAoMSkgb3IgJ2RlZmF1bHQnICgwKVxuICAgKi9cblxuXG4gIHA1LkRlbGF5LnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgdCA9ICdwaW5nUG9uZyc7XG4gICAgfVxuXG4gICAgdGhpcy5fc3BsaXQuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy5fbGVmdEZpbHRlci5kaXNjb25uZWN0KCk7XG5cbiAgICB0aGlzLl9yaWdodEZpbHRlci5kaXNjb25uZWN0KCk7XG5cbiAgICB0aGlzLl9zcGxpdC5jb25uZWN0KHRoaXMubGVmdERlbGF5LCAwKTtcblxuICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5yaWdodERlbGF5LCAxKTtcblxuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSAncGluZ1BvbmcnOlxuICAgICAgICB0aGlzLl9yaWdodEZpbHRlci5zZXRUeXBlKHRoaXMuX2xlZnRGaWx0ZXIuYmlxdWFkLnR5cGUpO1xuXG4gICAgICAgIHRoaXMuX2xlZnRGaWx0ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5fbWVyZ2UsIDAsIDApO1xuXG4gICAgICAgIHRoaXMuX3JpZ2h0RmlsdGVyLm91dHB1dC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAxKTtcblxuICAgICAgICB0aGlzLl9sZWZ0RmlsdGVyLm91dHB1dC5jb25uZWN0KHRoaXMucmlnaHREZWxheSk7XG5cbiAgICAgICAgdGhpcy5fcmlnaHRGaWx0ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5sZWZ0RGVsYXkpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9sZWZ0RmlsdGVyLm91dHB1dC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAwKTtcblxuICAgICAgICB0aGlzLl9yaWdodEZpbHRlci5vdXRwdXQuY29ubmVjdCh0aGlzLl9tZXJnZSwgMCwgMSk7XG5cbiAgICAgICAgdGhpcy5fbGVmdEZpbHRlci5vdXRwdXQuY29ubmVjdCh0aGlzLmxlZnREZWxheSk7XG5cbiAgICAgICAgdGhpcy5fcmlnaHRGaWx0ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5yaWdodERlbGF5KTtcblxuICAgIH1cbiAgfTsgXG5cbiAgLyoqXG4gICAqICBTZXQgdGhlIG91dHB1dCBsZXZlbCBvZiB0aGUgZGVsYXkgZWZmZWN0LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgYW1wXG4gICAqICBAZm9yIHA1LkRlbGF5XG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IHZvbHVtZSBhbXBsaXR1ZGUgYmV0d2VlbiAwIGFuZCAxLjBcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbcmFtcFRpbWVdIGNyZWF0ZSBhIGZhZGUgdGhhdCBsYXN0cyByYW1wVGltZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gc2NoZWR1bGUgdGhpcyBldmVudCB0byBoYXBwZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cbiAgLyoqXG4gICAqICBTZW5kIG91dHB1dCB0byBhIHA1LnNvdW5kIG9yIHdlYiBhdWRpbyBvYmplY3RcbiAgICpcbiAgICogIEBtZXRob2QgIGNvbm5lY3RcbiAgICogIEBmb3IgcDUuRGVsYXlcbiAgICogIEBwYXJhbSAge09iamVjdH0gdW5pdFxuICAgKi9cblxuICAvKipcbiAgICogIERpc2Nvbm5lY3QgYWxsIG91dHB1dC5cbiAgICpcbiAgICogIEBtZXRob2QgZGlzY29ubmVjdFxuICAgKiAgQGZvciBwNS5EZWxheVxuICAgKi9cblxuXG4gIHA1LkRlbGF5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIEVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMuX3NwbGl0LmRpc2Nvbm5lY3QoKTtcblxuICAgIHRoaXMuX2xlZnRGaWx0ZXIuZGlzcG9zZSgpO1xuXG4gICAgdGhpcy5fcmlnaHRGaWx0ZXIuZGlzcG9zZSgpO1xuXG4gICAgdGhpcy5fbWVyZ2UuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy5fbGVmdEdhaW4uZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy5fcmlnaHRHYWluLmRpc2Nvbm5lY3QoKTtcblxuICAgIHRoaXMubGVmdERlbGF5LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnJpZ2h0RGVsYXkuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuX3NwbGl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xlZnRGaWx0ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmlnaHRGaWx0ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWVyZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGVmdEdhaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmlnaHRHYWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdERlbGF5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHREZWxheSA9IHVuZGVmaW5lZDtcbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgQ3VzdG9tRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuICB2YXIgRWZmZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbiAgLyoqXG4gICAqICBSZXZlcmIgYWRkcyBkZXB0aCB0byBhIHNvdW5kIHRocm91Z2ggYSBsYXJnZSBudW1iZXIgb2YgZGVjYXlpbmdcbiAgICogIGVjaG9lcy4gSXQgY3JlYXRlcyB0aGUgcGVyY2VwdGlvbiB0aGF0IHNvdW5kIGlzIG9jY3VycmluZyBpbiBhXG4gICAqICBwaHlzaWNhbCBzcGFjZS4gVGhlIHA1LlJldmVyYiBoYXMgcGFyYW10ZXJzIGZvciBUaW1lIChob3cgbG9uZyBkb2VzIHRoZVxuICAgKiAgcmV2ZXJiIGxhc3QpIGFuZCBkZWNheVJhdGUgKGhvdyBtdWNoIHRoZSBzb3VuZCBkZWNheXMgd2l0aCBlYWNoIGVjaG8pXG4gICAqICB0aGF0IGNhbiBiZSBzZXQgd2l0aCB0aGUgLnNldCgpIG9yIC5wcm9jZXNzKCkgbWV0aG9kcy4gVGhlIHA1LkNvbnZvbHZlclxuICAgKiAgZXh0ZW5kcyBwNS5SZXZlcmIgYWxsb3dpbmcgeW91IHRvIHJlY3JlYXRlIHRoZSBzb3VuZCBvZiBhY3R1YWwgcGh5c2ljYWxcbiAgICogIHNwYWNlcyB0aHJvdWdoIGNvbnZvbHV0aW9uLlxuICAgKlxuICAgKiAgVGhpcyBjbGFzcyBleHRlbmRzIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3RcIj5wNS5FZmZlY3Q8L2E+LlxuICAgKiAgTWV0aG9kcyA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2FtcFwiPmFtcCgpPC9hPiwgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9jaGFpblwiPmNoYWluKCk8L2E+LFxuICAgKiAgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9kcnl3ZXRcIj5kcnl3ZXQoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY29ubmVjdFwiPmNvbm5lY3QoKTwvYT4sIGFuZFxuICAgKiAgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9kaXNjb25uZWN0XCI+ZGlzY29ubmVjdCgpPC9hPiBhcmUgYXZhaWxhYmxlLlxuICAgKlxuICAgKiAgQGNsYXNzIHA1LlJldmVyYlxuICAgKiAgQGV4dGVuZHMgcDUuRWZmZWN0XG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IHNvdW5kRmlsZSwgcmV2ZXJiO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgc291bmRGaWxlID0gbG9hZFNvdW5kKCdhc3NldHMvRGFtc2NyYXlfRGFuY2luZ1RpZ2VyLm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTb3VuZCk7XG4gICAqXG4gICAqICAgIHJldmVyYiA9IG5ldyBwNS5SZXZlcmIoKTtcbiAgICogICAgc291bmRGaWxlLmRpc2Nvbm5lY3QoKTsgLy8gc28gd2UnbGwgb25seSBoZWFyIHJldmVyYi4uLlxuICAgKlxuICAgKiAgICAvLyBjb25uZWN0IHNvdW5kRmlsZSB0byByZXZlcmIsIHByb2Nlc3Mgdy9cbiAgICogICAgLy8gMyBzZWNvbmQgcmV2ZXJiVGltZSwgZGVjYXlSYXRlIG9mIDIlXG4gICAqICAgIHJldmVyYi5wcm9jZXNzKHNvdW5kRmlsZSwgMywgMik7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBsZXQgZHJ5V2V0ID0gY29uc3RyYWluKG1hcChtb3VzZVgsIDAsIHdpZHRoLCAwLCAxKSwgMCwgMSk7XG4gICAqICAgIC8vIDEgPSBhbGwgcmV2ZXJiLCAwID0gbm8gcmV2ZXJiXG4gICAqICAgIHJldmVyYi5kcnl3ZXQoZHJ5V2V0KTtcbiAgICpcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDEwLCAyMCk7XG4gICAqICAgIHRleHQoJ2RyeS93ZXQ6ICcgKyByb3VuZChkcnlXZXQgKiAxMDApICsgJyUnLCAxMCwgaGVpZ2h0IC0gMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheVNvdW5kKCkge1xuICAgKiAgICBzb3VuZEZpbGUucGxheSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlJldmVyYiA9IGZ1bmN0aW9uICgpIHtcbiAgICBFZmZlY3QuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2luaXRDb252b2x2ZXJOb2RlKCk7IFxuXG5cbiAgICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSAwLjU7IFxuXG4gICAgdGhpcy5fc2Vjb25kcyA9IDM7XG4gICAgdGhpcy5fZGVjYXkgPSAyO1xuICAgIHRoaXMuX3JldmVyc2UgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1aWxkSW1wdWxzZSgpO1xuICB9O1xuXG4gIHA1LlJldmVyYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVmZmVjdC5wcm90b3R5cGUpO1xuXG4gIHA1LlJldmVyYi5wcm90b3R5cGUuX2luaXRDb252b2x2ZXJOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udm9sdmVyTm9kZSA9IHRoaXMuYWMuY3JlYXRlQ29udm9sdmVyKCk7XG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuY29udm9sdmVyTm9kZSk7XG4gICAgdGhpcy5jb252b2x2ZXJOb2RlLmNvbm5lY3QodGhpcy53ZXQpO1xuICB9O1xuXG4gIHA1LlJldmVyYi5wcm90b3R5cGUuX3RlYXJkb3duQ29udm9sdmVyTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jb252b2x2ZXJOb2RlKSB7XG4gICAgICB0aGlzLmNvbnZvbHZlck5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMuY29udm9sdmVyTm9kZTtcbiAgICB9XG4gIH07XG5cbiAgcDUuUmV2ZXJiLnByb3RvdHlwZS5fc2V0QnVmZmVyID0gZnVuY3Rpb24gKGF1ZGlvQnVmZmVyKSB7XG4gICAgdGhpcy5fdGVhcmRvd25Db252b2x2ZXJOb2RlKCk7XG5cbiAgICB0aGlzLl9pbml0Q29udm9sdmVyTm9kZSgpO1xuXG4gICAgdGhpcy5jb252b2x2ZXJOb2RlLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xuICB9O1xuICAvKipcbiAgICogIENvbm5lY3QgYSBzb3VyY2UgdG8gdGhlIHJldmVyYiwgYW5kIGFzc2lnbiByZXZlcmIgcGFyYW1ldGVycy5cbiAgICpcbiAgICogIEBtZXRob2QgIHByb2Nlc3NcbiAgICogIEBmb3IgcDUuUmV2ZXJiXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHNyYyAgICAgcDUuc291bmQgLyBXZWIgQXVkaW8gb2JqZWN0IHdpdGggYSBzb3VuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW3NlY29uZHNdIER1cmF0aW9uIG9mIHRoZSByZXZlcmIsIGluIHNlY29uZHMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgTWluOiAwLCBNYXg6IDEwLiBEZWZhdWx0cyB0byAzLlxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbZGVjYXlSYXRlXSBQZXJjZW50YWdlIG9mIGRlY2F5IHdpdGggZWFjaCBlY2hvLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNaW46IDAsIE1heDogMTAwLiBEZWZhdWx0cyB0byAyLlxuICAgKiAgQHBhcmFtICB7Qm9vbGVhbn0gW3JldmVyc2VdIFBsYXkgdGhlIHJldmVyYiBiYWNrd2FyZHMgb3IgZm9yd2FyZHMuXG4gICAqL1xuXG5cbiAgcDUuUmV2ZXJiLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgc2Vjb25kcywgZGVjYXlSYXRlLCByZXZlcnNlKSB7XG4gICAgc3JjLmNvbm5lY3QodGhpcy5pbnB1dCk7XG4gICAgdmFyIHJlYnVpbGQgPSBmYWxzZTtcblxuICAgIGlmIChzZWNvbmRzKSB7XG4gICAgICB0aGlzLl9zZWNvbmRzID0gc2Vjb25kcztcbiAgICAgIHJlYnVpbGQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkZWNheVJhdGUpIHtcbiAgICAgIHRoaXMuX2RlY2F5ID0gZGVjYXlSYXRlO1xuICAgIH1cblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICB9XG5cbiAgICBpZiAocmVidWlsZCkge1xuICAgICAgdGhpcy5fYnVpbGRJbXB1bHNlKCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgcmV2ZXJiIHNldHRpbmdzLiBTaW1pbGFyIHRvIC5wcm9jZXNzKCksIGJ1dCB3aXRob3V0XG4gICAqICBhc3NpZ25pbmcgYSBuZXcgaW5wdXQuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRcbiAgICogIEBmb3IgcDUuUmV2ZXJiXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzZWNvbmRzXSBEdXJhdGlvbiBvZiB0aGUgcmV2ZXJiLCBpbiBzZWNvbmRzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE1pbjogMCwgTWF4OiAxMC4gRGVmYXVsdHMgdG8gMy5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW2RlY2F5UmF0ZV0gUGVyY2VudGFnZSBvZiBkZWNheSB3aXRoIGVhY2ggZWNoby5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgTWluOiAwLCBNYXg6IDEwMC4gRGVmYXVsdHMgdG8gMi5cbiAgICogIEBwYXJhbSAge0Jvb2xlYW59IFtyZXZlcnNlXSBQbGF5IHRoZSByZXZlcmIgYmFja3dhcmRzIG9yIGZvcndhcmRzLlxuICAgKi9cblxuXG4gIHA1LlJldmVyYi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHNlY29uZHMsIGRlY2F5UmF0ZSwgcmV2ZXJzZSkge1xuICAgIHZhciByZWJ1aWxkID0gZmFsc2U7XG5cbiAgICBpZiAoc2Vjb25kcykge1xuICAgICAgdGhpcy5fc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgICByZWJ1aWxkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZGVjYXlSYXRlKSB7XG4gICAgICB0aGlzLl9kZWNheSA9IGRlY2F5UmF0ZTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgfVxuXG4gICAgaWYgKHJlYnVpbGQpIHtcbiAgICAgIHRoaXMuX2J1aWxkSW1wdWxzZSgpO1xuICAgIH1cbiAgfTsgXG5cbiAgLyoqXG4gICAqICBTZXQgdGhlIG91dHB1dCBsZXZlbCBvZiB0aGUgcmV2ZXJiIGVmZmVjdC5cbiAgICpcbiAgICogIEBtZXRob2QgIGFtcFxuICAgKiAgQGZvciBwNS5SZXZlcmJcbiAgICogIEBwYXJhbSAge051bWJlcn0gdm9sdW1lIGFtcGxpdHVkZSBiZXR3ZWVuIDAgYW5kIDEuMFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbcmFtcFRpbWVdIGNyZWF0ZSBhIGZhZGUgdGhhdCBsYXN0cyByYW1wVGltZVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG4gIC8qKlxuICAgKiAgU2VuZCBvdXRwdXQgdG8gYSBwNS5zb3VuZCBvciB3ZWIgYXVkaW8gb2JqZWN0XG4gICAqXG4gICAqICBAbWV0aG9kICBjb25uZWN0XG4gICAqICBAZm9yIHA1LlJldmVyYlxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSB1bml0XG4gICAqL1xuXG4gIC8qKlxuICAgKiAgRGlzY29ubmVjdCBhbGwgb3V0cHV0LlxuICAgKlxuICAgKiAgQG1ldGhvZCBkaXNjb25uZWN0XG4gICAqICBAZm9yIHA1LlJldmVyYlxuICAgKi9cblxuICAvKipcbiAgICogIEluc3BpcmVkIGJ5IFNpbXBsZSBSZXZlcmIgYnkgSm9yZGFuIFNhbnRlbGxcbiAgICogIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWItYXVkaW8tY29tcG9uZW50cy9zaW1wbGUtcmV2ZXJiL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAqXG4gICAqICBVdGlsaXR5IGZ1bmN0aW9uIGZvciBidWlsZGluZyBhbiBpbXB1bHNlIHJlc3BvbnNlXG4gICAqICBiYXNlZCBvbiB0aGUgbW9kdWxlIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqICBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHA1LlJldmVyYi5wcm90b3R5cGUuX2J1aWxkSW1wdWxzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmF0ZSA9IHRoaXMuYWMuc2FtcGxlUmF0ZTtcbiAgICB2YXIgbGVuZ3RoID0gcmF0ZSAqIHRoaXMuX3NlY29uZHM7XG4gICAgdmFyIGRlY2F5ID0gdGhpcy5fZGVjYXk7XG4gICAgdmFyIGltcHVsc2UgPSB0aGlzLmFjLmNyZWF0ZUJ1ZmZlcigyLCBsZW5ndGgsIHJhdGUpO1xuICAgIHZhciBpbXB1bHNlTCA9IGltcHVsc2UuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgdmFyIGltcHVsc2VSID0gaW1wdWxzZS5nZXRDaGFubmVsRGF0YSgxKTtcbiAgICB2YXIgbiwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbiA9IHRoaXMuX3JldmVyc2UgPyBsZW5ndGggLSBpIDogaTtcbiAgICAgIGltcHVsc2VMW2ldID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBNYXRoLnBvdygxIC0gbiAvIGxlbmd0aCwgZGVjYXkpO1xuICAgICAgaW1wdWxzZVJbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIE1hdGgucG93KDEgLSBuIC8gbGVuZ3RoLCBkZWNheSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0QnVmZmVyKGltcHVsc2UpO1xuICB9O1xuXG4gIHA1LlJldmVyYi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLl90ZWFyZG93bkNvbnZvbHZlck5vZGUoKTtcbiAgfTsgXG5cbiAgLyoqXG4gICAqICA8cD5wNS5Db252b2x2ZXIgZXh0ZW5kcyBwNS5SZXZlcmIuIEl0IGNhbiBlbXVsYXRlIHRoZSBzb3VuZCBvZiByZWFsXG4gICAqICBwaHlzaWNhbCBzcGFjZXMgdGhyb3VnaCBhIHByb2Nlc3MgY2FsbGVkIDxhIGhyZWY9XCJcbiAgICogIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnZvbHV0aW9uX3JldmVyYiNSZWFsX3NwYWNlX3NpbXVsYXRpb25cIj5cbiAgICogIGNvbnZvbHV0aW9uPC9hPi48L3A+XG4gICAqXG4gICAqICA8cD5Db252b2x1dGlvbiBtdWx0aXBsaWVzIGFueSBhdWRpbyBpbnB1dCBieSBhbiBcImltcHVsc2UgcmVzcG9uc2VcIlxuICAgKiAgdG8gc2ltdWxhdGUgdGhlIGRpc3BlcnNpb24gb2Ygc291bmQgb3ZlciB0aW1lLiBUaGUgaW1wdWxzZSByZXNwb25zZSBpc1xuICAgKiAgZ2VuZXJhdGVkIGZyb20gYW4gYXVkaW8gZmlsZSB0aGF0IHlvdSBwcm92aWRlLiBPbmUgd2F5IHRvXG4gICAqICBnZW5lcmF0ZSBhbiBpbXB1bHNlIHJlc3BvbnNlIGlzIHRvIHBvcCBhIGJhbGxvb24gaW4gYSByZXZlcmJlcmFudCBzcGFjZVxuICAgKiAgYW5kIHJlY29yZCB0aGUgZWNoby4gQ29udm9sdXRpb24gY2FuIGFsc28gYmUgdXNlZCB0byBleHBlcmltZW50IHdpdGhcbiAgICogIHNvdW5kLjwvcD5cbiAgICpcbiAgICogIDxwPlVzZSB0aGUgbWV0aG9kIDxjb2RlPmNyZWF0ZUNvbnZvbHV0aW9uKHBhdGgpPC9jb2RlPiB0byBpbnN0YW50aWF0ZSBhXG4gICAqICBwNS5Db252b2x2ZXIgd2l0aCBhIHBhdGggdG8geW91ciBpbXB1bHNlIHJlc3BvbnNlIGF1ZGlvIGZpbGUuPC9wPlxuICAgKlxuICAgKiAgQGNsYXNzIHA1LkNvbnZvbHZlclxuICAgKiAgQGV4dGVuZHMgcDUuRWZmZWN0XG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBwYXJhbSAge1N0cmluZ30gICBwYXRoICAgICBwYXRoIHRvIGEgc291bmQgZmlsZVxuICAgKiAgQHBhcmFtICB7RnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGxvYWRpbmcgc3VjY2VlZHNcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBbZXJyb3JDYWxsYmFja10gZnVuY3Rpb24gdG8gY2FsbCBpZiBsb2FkaW5nIGZhaWxzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBhbiBlcnJvciBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBYTUxIdHRwUmVxdWVzdCBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm91dCB3aGF0IHdlbnQgd3JvbmcuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBjVmVyYiwgc291bmQ7XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICAvLyBXZSBoYXZlIGJvdGggTVAzIGFuZCBPR0cgdmVyc2lvbnMgb2YgYWxsIHNvdW5kIGFzc2V0c1xuICAgKiAgICBzb3VuZEZvcm1hdHMoJ29nZycsICdtcDMnKTtcbiAgICpcbiAgICogICAgLy8gVHJ5IHJlcGxhY2luZyAnYngtc3ByaW5nJyB3aXRoIG90aGVyIHNvdW5kZmlsZXMgbGlrZVxuICAgKiAgICAvLyAnY29uY3JldGUtdHVubmVsJyAnc21hbGwtcGxhdGUnICdkcnVtJyAnYmVhdGJveCdcbiAgICogICAgY1ZlcmIgPSBjcmVhdGVDb252b2x2ZXIoJ2Fzc2V0cy9ieC1zcHJpbmcubXAzJyk7XG4gICAqXG4gICAqICAgIC8vIFRyeSByZXBsYWNpbmcgJ0RhbXNjcmF5X0RhbmNpbmdUaWdlcicgd2l0aFxuICAgKiAgICAvLyAnYmVhdCcsICdkb29yYmVsbCcsIGx1Y2t5X2RyYWdvbnNfLV9wb3dlcl9tZWxvZHknXG4gICAqICAgIHNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvRGFtc2NyYXlfRGFuY2luZ1RpZ2VyLm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTb3VuZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKlxuICAgKiAgICAvLyBkaXNjb25uZWN0IGZyb20gbWFzdGVyIG91dHB1dC4uLlxuICAgKiAgICBzb3VuZC5kaXNjb25uZWN0KCk7XG4gICAqXG4gICAqICAgIC8vIC4uLmFuZCBwcm9jZXNzIHdpdGggY1ZlcmJcbiAgICogICAgLy8gc28gdGhhdCB3ZSBvbmx5IGhlYXIgdGhlIGNvbnZvbHV0aW9uXG4gICAqICAgIGNWZXJiLnByb2Nlc3Moc291bmQpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheVNvdW5kKCkge1xuICAgKiAgICBzb3VuZC5wbGF5KCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuQ29udm9sdmVyID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgcDUuUmV2ZXJiLmNhbGwodGhpcyk7XG4gICAgLyoqXG4gICAgICogIEludGVybmFsbHksIHRoZSBwNS5Db252b2x2ZXIgdXNlcyB0aGUgYVxuICAgICAqICA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI0NvbnZvbHZlck5vZGVcIj5cbiAgICAgKiAgV2ViIEF1ZGlvIENvbnZvbHZlciBOb2RlPC9hPi5cbiAgICAgKlxuICAgICAqICBAcHJvcGVydHkge0NvbnZvbHZlck5vZGV9IGNvbnZvbHZlck5vZGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2luaXRDb252b2x2ZXJOb2RlKCk7IFxuXG5cbiAgICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSAwLjU7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdGhpcy5pbXB1bHNlcyA9IFtdO1xuXG4gICAgICB0aGlzLl9sb2FkQnVmZmVyKHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2Vjb25kcyA9IDM7XG4gICAgICB0aGlzLl9kZWNheSA9IDI7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX2J1aWxkSW1wdWxzZSgpO1xuICAgIH1cbiAgfTtcblxuICBwNS5Db252b2x2ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5SZXZlcmIucHJvdG90eXBlKTtcbiAgcDUucHJvdG90eXBlLnJlZ2lzdGVyUHJlbG9hZE1ldGhvZCgnY3JlYXRlQ29udm9sdmVyJywgcDUucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqICBDcmVhdGUgYSBwNS5Db252b2x2ZXIuIEFjY2VwdHMgYSBwYXRoIHRvIGEgc291bmRmaWxlXG4gICAqICB0aGF0IHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSBhbiBpbXB1bHNlIHJlc3BvbnNlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgY3JlYXRlQ29udm9sdmVyXG4gICAqICBAZm9yIHA1XG4gICAqICBAcGFyYW0gIHtTdHJpbmd9ICAgcGF0aCAgICAgcGF0aCB0byBhIHNvdW5kIGZpbGVcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGNhbGwgaWYgbG9hZGluZyBpcyBzdWNjZXNzZnVsLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBpbiBhcyB0aGUgYXJndW1lbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBbZXJyb3JDYWxsYmFja10gZnVuY3Rpb24gdG8gY2FsbCBpZiBsb2FkaW5nIGlzIG5vdCBzdWNjZXNzZnVsLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBjdXN0b20gZXJyb3Igd2lsbCBiZSBwYXNzZWQgaW4gYXMgdGhlIGFyZ3VtZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqICBAcmV0dXJuIHtwNS5Db252b2x2ZXJ9XG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBjVmVyYiwgc291bmQ7XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICAvLyBXZSBoYXZlIGJvdGggTVAzIGFuZCBPR0cgdmVyc2lvbnMgb2YgYWxsIHNvdW5kIGFzc2V0c1xuICAgKiAgICBzb3VuZEZvcm1hdHMoJ29nZycsICdtcDMnKTtcbiAgICpcbiAgICogICAgLy8gVHJ5IHJlcGxhY2luZyAnYngtc3ByaW5nJyB3aXRoIG90aGVyIHNvdW5kZmlsZXMgbGlrZVxuICAgKiAgICAvLyAnY29uY3JldGUtdHVubmVsJyAnc21hbGwtcGxhdGUnICdkcnVtJyAnYmVhdGJveCdcbiAgICogICAgY1ZlcmIgPSBjcmVhdGVDb252b2x2ZXIoJ2Fzc2V0cy9ieC1zcHJpbmcubXAzJyk7XG4gICAqXG4gICAqICAgIC8vIFRyeSByZXBsYWNpbmcgJ0RhbXNjcmF5X0RhbmNpbmdUaWdlcicgd2l0aFxuICAgKiAgICAvLyAnYmVhdCcsICdkb29yYmVsbCcsIGx1Y2t5X2RyYWdvbnNfLV9wb3dlcl9tZWxvZHknXG4gICAqICAgIHNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvRGFtc2NyYXlfRGFuY2luZ1RpZ2VyLm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTb3VuZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKlxuICAgKiAgICAvLyBkaXNjb25uZWN0IGZyb20gbWFzdGVyIG91dHB1dC4uLlxuICAgKiAgICBzb3VuZC5kaXNjb25uZWN0KCk7XG4gICAqXG4gICAqICAgIC8vIC4uLmFuZCBwcm9jZXNzIHdpdGggY1ZlcmJcbiAgICogICAgLy8gc28gdGhhdCB3ZSBvbmx5IGhlYXIgdGhlIGNvbnZvbHV0aW9uXG4gICAqICAgIGNWZXJiLnByb2Nlc3Moc291bmQpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheVNvdW5kKCkge1xuICAgKiAgICBzb3VuZC5wbGF5KCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG4gIHA1LnByb3RvdHlwZS5jcmVhdGVDb252b2x2ZXIgPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICBpZiAod2luZG93LmxvY2F0aW9uLm9yaWdpbi5pbmRleE9mKCdmaWxlOi8vJykgPiAtMSAmJiB3aW5kb3cuY29yZG92YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFsZXJ0KCdUaGlzIHNrZXRjaCBtYXkgcmVxdWlyZSBhIHNlcnZlciB0byBsb2FkIGV4dGVybmFsIGZpbGVzLiBQbGVhc2Ugc2VlIGh0dHA6Ly9iaXQubHkvMXFjSW53UycpO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY1JldmVyYiA9IG5ldyBwNS5Db252b2x2ZXIocGF0aCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayhidWZmZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGYuX2RlY3JlbWVudFByZWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2VsZi5fZGVjcmVtZW50UHJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgIGNSZXZlcmIuaW1wdWxzZXMgPSBbXTtcbiAgICByZXR1cm4gY1JldmVyYjtcbiAgfTtcbiAgLyoqXG4gICAqICBQcml2YXRlIG1ldGhvZCB0byBsb2FkIGEgYnVmZmVyIGFzIGFuIEltcHVsc2UgUmVzcG9uc2UsXG4gICAqICBhc3NpZ24gaXQgdG8gdGhlIGNvbnZvbHZlck5vZGUsIGFuZCBhZGQgdG8gdGhlIEFycmF5IG9mIC5pbXB1bHNlcy5cbiAgICpcbiAgICogIEBwYXJhbSAgIHtTdHJpbmd9ICAgcGF0aFxuICAgKiAgQHBhcmFtICAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiAgQHBhcmFtICAge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrXG4gICAqICBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHA1LkNvbnZvbHZlci5wcm90b3R5cGUuX2xvYWRCdWZmZXIgPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgcGF0aCA9IHA1LnByb3RvdHlwZS5fY2hlY2tGaWxlRm9ybWF0cyhwYXRoKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXJyb3JUcmFjZSA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHZhciBhYyA9IHA1LnByb3RvdHlwZS5nZXRBdWRpb0NvbnRleHQoKTtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBhYy5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgZnVuY3Rpb24gKGJ1ZmYpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyID0ge307XG4gICAgICAgICAgdmFyIGNodW5rcyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgICBidWZmZXIubmFtZSA9IGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYnVmZmVyLmF1ZGlvQnVmZmVyID0gYnVmZjtcbiAgICAgICAgICBzZWxmLmltcHVsc2VzLnB1c2goYnVmZmVyKTtcblxuICAgICAgICAgIHNlbGYuX3NldEJ1ZmZlcihidWZmZXIuYXVkaW9CdWZmZXIpO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEN1c3RvbUVycm9yKCdkZWNvZGVBdWRpb0RhdGEnLCBlcnJvclRyYWNlLCBzZWxmLnVybCk7XG4gICAgICAgICAgdmFyIG1zZyA9ICdBdWRpb0NvbnRleHQgZXJyb3IgYXQgZGVjb2RlQXVkaW9EYXRhIGZvciAnICsgc2VsZi51cmw7XG5cbiAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgZXJyLm1zZyA9IG1zZztcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cgKyAnXFxuIFRoZSBlcnJvciBzdGFjayB0cmFjZSBpbmNsdWRlczogXFxuJyArIGVyci5zdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gXG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEN1c3RvbUVycm9yKCdsb2FkQ29udm9sdmVyJywgZXJyb3JUcmFjZSwgc2VsZi51cmwpO1xuICAgICAgICAgIHZhciBtc2cgPSAnVW5hYmxlIHRvIGxvYWQgJyArIHNlbGYudXJsICsgJy4gVGhlIHJlcXVlc3Qgc3RhdHVzIHdhczogJyArIHJlcXVlc3Quc3RhdHVzICsgJyAoJyArIHJlcXVlc3Quc3RhdHVzVGV4dCArICcpJztcblxuICAgICAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cgKyAnXFxuIFRoZSBlcnJvciBzdGFjayB0cmFjZSBpbmNsdWRlczogXFxuJyArIGVyci5zdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTsgXG5cblxuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQ3VzdG9tRXJyb3IoJ2xvYWRDb252b2x2ZXInLCBlcnJvclRyYWNlLCBzZWxmLnVybCk7XG4gICAgICB2YXIgbXNnID0gJ1RoZXJlIHdhcyBubyByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgYXQgJyArIHNlbGYudXJsICsgJy4gQ2hlY2sgdGhlIHVybCBhbmQgaW50ZXJuZXQgY29ubmVjdGl2aXR5Lic7XG5cbiAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gbXNnO1xuICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyArICdcXG4gVGhlIGVycm9yIHN0YWNrIHRyYWNlIGluY2x1ZGVzOiBcXG4nICsgZXJyLnN0YWNrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKCk7XG4gIH07XG5cbiAgcDUuQ29udm9sdmVyLnByb3RvdHlwZS5zZXQgPSBudWxsO1xuICAvKipcbiAgICogIENvbm5lY3QgYSBzb3VyY2UgdG8gdGhlIGNvbnZvbHZlci5cbiAgICpcbiAgICogIEBtZXRob2QgIHByb2Nlc3NcbiAgICogIEBmb3IgcDUuQ29udm9sdmVyXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHNyYyAgICAgcDUuc291bmQgLyBXZWIgQXVkaW8gb2JqZWN0IHdpdGggYSBzb3VuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGNWZXJiLCBzb3VuZDtcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIC8vIFdlIGhhdmUgYm90aCBNUDMgYW5kIE9HRyB2ZXJzaW9ucyBvZiBhbGwgc291bmQgYXNzZXRzXG4gICAqICAgIHNvdW5kRm9ybWF0cygnb2dnJywgJ21wMycpO1xuICAgKlxuICAgKiAgICAvLyBUcnkgcmVwbGFjaW5nICdieC1zcHJpbmcnIHdpdGggb3RoZXIgc291bmRmaWxlcyBsaWtlXG4gICAqICAgIC8vICdjb25jcmV0ZS10dW5uZWwnICdzbWFsbC1wbGF0ZScgJ2RydW0nICdiZWF0Ym94J1xuICAgKiAgICBjVmVyYiA9IGNyZWF0ZUNvbnZvbHZlcignYXNzZXRzL2J4LXNwcmluZy5tcDMnKTtcbiAgICpcbiAgICogICAgLy8gVHJ5IHJlcGxhY2luZyAnRGFtc2NyYXlfRGFuY2luZ1RpZ2VyJyB3aXRoXG4gICAqICAgIC8vICdiZWF0JywgJ2Rvb3JiZWxsJywgbHVja3lfZHJhZ29uc18tX3Bvd2VyX21lbG9keSdcbiAgICogICAgc291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9EYW1zY3JheV9EYW5jaW5nVGlnZXIubXAzJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheVNvdW5kKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqXG4gICAqICAgIC8vIGRpc2Nvbm5lY3QgZnJvbSBtYXN0ZXIgb3V0cHV0Li4uXG4gICAqICAgIHNvdW5kLmRpc2Nvbm5lY3QoKTtcbiAgICpcbiAgICogICAgLy8gLi4uYW5kIHByb2Nlc3Mgd2l0aCBjVmVyYlxuICAgKiAgICAvLyBzbyB0aGF0IHdlIG9ubHkgaGVhciB0aGUgY29udm9sdXRpb25cbiAgICogICAgY1ZlcmIucHJvY2Vzcyhzb3VuZCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5U291bmQoKSB7XG4gICAqICAgIHNvdW5kLnBsYXkoKTtcbiAgICogIH1cbiAgICpcbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cbiAgcDUuQ29udm9sdmVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICB9O1xuICAvKipcbiAgICogIElmIHlvdSBsb2FkIG11bHRpcGxlIGltcHVsc2UgZmlsZXMgdXNpbmcgdGhlIC5hZGRJbXB1bHNlIG1ldGhvZCxcbiAgICogIHRoZXkgd2lsbCBiZSBzdG9yZWQgYXMgT2JqZWN0cyBpbiB0aGlzIEFycmF5LiBUb2dnbGUgYmV0d2VlbiB0aGVtXG4gICAqICB3aXRoIHRoZSA8Y29kZT50b2dnbGVJbXB1bHNlKGlkKTwvY29kZT4gbWV0aG9kLlxuICAgKlxuICAgKiAgQHByb3BlcnR5IHtBcnJheX0gaW1wdWxzZXNcbiAgICogIEBmb3IgcDUuQ29udm9sdmVyXG4gICAqL1xuXG5cbiAgcDUuQ29udm9sdmVyLnByb3RvdHlwZS5pbXB1bHNlcyA9IFtdO1xuICAvKipcbiAgICogIExvYWQgYW5kIGFzc2lnbiBhIG5ldyBJbXB1bHNlIFJlc3BvbnNlIHRvIHRoZSBwNS5Db252b2x2ZXIuXG4gICAqICBUaGUgaW1wdWxzZSBpcyBhZGRlZCB0byB0aGUgPGNvZGU+LmltcHVsc2VzPC9jb2RlPiBhcnJheS4gUHJldmlvdXNcbiAgICogIGltcHVsc2VzIGNhbiBiZSBhY2Nlc3NlZCB3aXRoIHRoZSA8Y29kZT4udG9nZ2xlSW1wdWxzZShpZCk8L2NvZGU+XG4gICAqICBtZXRob2QuXG4gICAqXG4gICAqICBAbWV0aG9kICBhZGRJbXB1bHNlXG4gICAqICBAZm9yIHA1LkNvbnZvbHZlclxuICAgKiAgQHBhcmFtICB7U3RyaW5nfSAgIHBhdGggICAgIHBhdGggdG8gYSBzb3VuZCBmaWxlXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICAgKiAgQHBhcmFtICB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICAgKi9cblxuICBwNS5Db252b2x2ZXIucHJvdG90eXBlLmFkZEltcHVsc2UgPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICBpZiAod2luZG93LmxvY2F0aW9uLm9yaWdpbi5pbmRleE9mKCdmaWxlOi8vJykgPiAtMSAmJiB3aW5kb3cuY29yZG92YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFsZXJ0KCdUaGlzIHNrZXRjaCBtYXkgcmVxdWlyZSBhIHNlcnZlciB0byBsb2FkIGV4dGVybmFsIGZpbGVzLiBQbGVhc2Ugc2VlIGh0dHA6Ly9iaXQubHkvMXFjSW53UycpO1xuICAgIH1cblxuICAgIHRoaXMuX2xvYWRCdWZmZXIocGF0aCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICB9O1xuICAvKipcbiAgICogIFNpbWlsYXIgdG8gLmFkZEltcHVsc2UsIGV4Y2VwdCB0aGF0IHRoZSA8Y29kZT4uaW1wdWxzZXM8L2NvZGU+XG4gICAqICBBcnJheSBpcyByZXNldCB0byBzYXZlIG1lbW9yeS4gQSBuZXcgPGNvZGU+LmltcHVsc2VzPC9jb2RlPlxuICAgKiAgYXJyYXkgaXMgY3JlYXRlZCB3aXRoIHRoaXMgaW1wdWxzZSBhcyB0aGUgb25seSBpdGVtLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcmVzZXRJbXB1bHNlXG4gICAqICBAZm9yIHA1LkNvbnZvbHZlclxuICAgKiAgQHBhcmFtICB7U3RyaW5nfSAgIHBhdGggICAgIHBhdGggdG8gYSBzb3VuZCBmaWxlXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICAgKiAgQHBhcmFtICB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICAgKi9cblxuXG4gIHA1LkNvbnZvbHZlci5wcm90b3R5cGUucmVzZXRJbXB1bHNlID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4uaW5kZXhPZignZmlsZTovLycpID4gLTEgJiYgd2luZG93LmNvcmRvdmEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhbGVydCgnVGhpcyBza2V0Y2ggbWF5IHJlcXVpcmUgYSBzZXJ2ZXIgdG8gbG9hZCBleHRlcm5hbCBmaWxlcy4gUGxlYXNlIHNlZSBodHRwOi8vYml0Lmx5LzFxY0lud1MnKTtcbiAgICB9XG5cbiAgICB0aGlzLmltcHVsc2VzID0gW107XG5cbiAgICB0aGlzLl9sb2FkQnVmZmVyKHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqICBJZiB5b3UgaGF2ZSB1c2VkIDxjb2RlPi5hZGRJbXB1bHNlKCk8L2NvZGU+IHRvIGFkZCBtdWx0aXBsZSBpbXB1bHNlc1xuICAgKiAgdG8gYSBwNS5Db252b2x2ZXIsIHRoZW4geW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gdG9nZ2xlIGJldHdlZW5cbiAgICogIHRoZSBpdGVtcyBpbiB0aGUgPGNvZGU+LmltcHVsc2VzPC9jb2RlPiBBcnJheS4gQWNjZXB0cyBhIHBhcmFtZXRlclxuICAgKiAgdG8gaWRlbnRpZnkgd2hpY2ggaW1wdWxzZSB5b3Ugd2lzaCB0byB1c2UsIGlkZW50aWZpZWQgZWl0aGVyIGJ5IGl0c1xuICAgKiAgb3JpZ2luYWwgZmlsZW5hbWUgKFN0cmluZykgb3IgYnkgaXRzIHBvc2l0aW9uIGluIHRoZSA8Y29kZT4uaW1wdWxzZXNcbiAgICogIDwvY29kZT4gQXJyYXkgKE51bWJlcikuPGJyLz5cbiAgICogIFlvdSBjYW4gYWNjZXNzIHRoZSBvYmplY3RzIGluIHRoZSAuaW1wdWxzZXMgQXJyYXkgZGlyZWN0bHkuIEVhY2hcbiAgICogIE9iamVjdCBoYXMgdHdvIGF0dHJpYnV0ZXM6IGFuIDxjb2RlPi5hdWRpb0J1ZmZlcjwvY29kZT4gKHR5cGU6XG4gICAqICBXZWIgQXVkaW8gPGEgaHJlZj1cIlxuICAgKiAgaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtYXVkaW9idWZmZXItaW50ZXJmYWNlXCI+XG4gICAqICBBdWRpb0J1ZmZlcik8L2E+IGFuZCBhIDxjb2RlPi5uYW1lPC9jb2RlPiwgYSBTdHJpbmcgdGhhdCBjb3JyZXNwb25kc1xuICAgKiAgd2l0aCB0aGUgb3JpZ2luYWwgZmlsZW5hbWUuXG4gICAqXG4gICAqICBAbWV0aG9kIHRvZ2dsZUltcHVsc2VcbiAgICogIEBmb3IgcDUuQ29udm9sdmVyXG4gICAqICBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkIElkZW50aWZ5IHRoZSBpbXB1bHNlIGJ5IGl0cyBvcmlnaW5hbCBmaWxlbmFtZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nKSwgb3IgYnkgaXRzIHBvc2l0aW9uIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT4uaW1wdWxzZXM8L2NvZGU+IEFycmF5IChOdW1iZXIpLlxuICAgKi9cblxuXG4gIHA1LkNvbnZvbHZlci5wcm90b3R5cGUudG9nZ2xlSW1wdWxzZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgPT09ICdudW1iZXInICYmIGlkIDwgdGhpcy5pbXB1bHNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3NldEJ1ZmZlcih0aGlzLmltcHVsc2VzW2lkXS5hdWRpb0J1ZmZlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbXB1bHNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5pbXB1bHNlc1tpXS5uYW1lID09PSBpZCkge1xuICAgICAgICAgIHRoaXMuX3NldEJ1ZmZlcih0aGlzLmltcHVsc2VzW2ldLmF1ZGlvQnVmZmVyKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHA1LkNvbnZvbHZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwNS5SZXZlcmIucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcyk7IFxuXG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLmltcHVsc2VzKSB7XG4gICAgICBpZiAodGhpcy5pbXB1bHNlc1tpXSkge1xuICAgICAgICB0aGlzLmltcHVsc2VzW2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpOyBcblxuXG4gIHZhciBDbG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG4gIHA1Lk1ldHJvID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xvY2sgPSBuZXcgQ2xvY2soe1xuICAgICAgJ2NhbGxiYWNrJzogdGhpcy5vbnRpY2suYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMuc3luY2VkUGFydHMgPSBbXTtcbiAgICB0aGlzLmJwbSA9IDEyMDsgXG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICB0aGlzLnByZXZUaWNrID0gMDtcbiAgICB0aGlzLnRhdHVtVGltZSA9IDA7XG5cbiAgICB0aGlzLnRpY2tDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICB9O1xuXG4gIHA1Lk1ldHJvLnByb3RvdHlwZS5vbnRpY2sgPSBmdW5jdGlvbiAodGlja1RpbWUpIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSB0aWNrVGltZSAtIHRoaXMucHJldlRpY2s7XG4gICAgdmFyIHNlY29uZHNGcm9tTm93ID0gdGlja1RpbWUgLSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcblxuICAgIGlmIChlbGFwc2VkVGltZSAtIHRoaXMudGF0dW1UaW1lIDw9IC0wLjAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJldlRpY2sgPSB0aWNrVGltZTsgXG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuc3luY2VkUGFydHMuZm9yRWFjaChmdW5jdGlvbiAodGhpc1BhcnQpIHtcbiAgICAgICAgaWYgKCF0aGlzUGFydC5pc1BsYXlpbmcpIHJldHVybjtcbiAgICAgICAgdGhpc1BhcnQuaW5jcmVtZW50U3RlcChzZWNvbmRzRnJvbU5vdyk7IFxuXG4gICAgICAgIHRoaXNQYXJ0LnBocmFzZXMuZm9yRWFjaChmdW5jdGlvbiAodGhpc1BocmFzZSkge1xuICAgICAgICAgIHZhciBwaHJhc2VBcnJheSA9IHRoaXNQaHJhc2Uuc2VxdWVuY2U7XG4gICAgICAgICAgdmFyIGJOdW0gPSBzZWxmLm1ldHJvVGlja3MgJSBwaHJhc2VBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAocGhyYXNlQXJyYXlbYk51bV0gIT09IDAgJiYgKHNlbGYubWV0cm9UaWNrcyA8IHBocmFzZUFycmF5Lmxlbmd0aCB8fCAhdGhpc1BocmFzZS5sb29waW5nKSkge1xuICAgICAgICAgICAgdGhpc1BocmFzZS5jYWxsYmFjayhzZWNvbmRzRnJvbU5vdywgcGhyYXNlQXJyYXlbYk51bV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWV0cm9UaWNrcyArPSAxO1xuICAgICAgdGhpcy50aWNrQ2FsbGJhY2soc2Vjb25kc0Zyb21Ob3cpO1xuICAgIH1cbiAgfTtcblxuICBwNS5NZXRyby5wcm90b3R5cGUuc2V0QlBNID0gZnVuY3Rpb24gKGJwbSwgcmFtcFRpbWUpIHtcbiAgICB2YXIgYmVhdFRpbWUgPSA2MCAvIChicG0gKiB0aGlzLnRhdHVtcyk7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHRoaXMudGF0dW1UaW1lID0gYmVhdFRpbWU7XG4gICAgdmFyIHJhbXBUaW1lID0gcmFtcFRpbWUgfHwgMDtcbiAgICB0aGlzLmNsb2NrLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSh0aGlzLmNsb2NrLmZyZXF1ZW5jeS52YWx1ZSwgbm93KTtcbiAgICB0aGlzLmNsb2NrLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShicG0sIG5vdyArIHJhbXBUaW1lKTtcbiAgICB0aGlzLmJwbSA9IGJwbTtcbiAgfTtcblxuICBwNS5NZXRyby5wcm90b3R5cGUuZ2V0QlBNID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsb2NrLmdldFJhdGUoKSAvIHRoaXMudGF0dW1zICogNjA7XG4gIH07XG5cbiAgcDUuTWV0cm8ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubWV0cm9UaWNrcyA9IDA7IFxuICB9OyBcblxuXG4gIHA1Lk1ldHJvLnByb3RvdHlwZS5yZXNldFN5bmMgPSBmdW5jdGlvbiAocGFydCkge1xuICAgIHRoaXMuc3luY2VkUGFydHMgPSBbcGFydF07XG4gIH07IFxuXG5cbiAgcDUuTWV0cm8ucHJvdG90eXBlLnB1c2hTeW5jID0gZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB0aGlzLnN5bmNlZFBhcnRzLnB1c2gocGFydCk7XG4gIH07XG5cbiAgcDUuTWV0cm8ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWVGcm9tTm93KSB7XG4gICAgdmFyIHQgPSB0aW1lRnJvbU5vdyB8fCAwO1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB0aGlzLmNsb2NrLnN0YXJ0KG5vdyArIHQpO1xuICAgIHRoaXMuc2V0QlBNKHRoaXMuYnBtKTtcbiAgfTtcblxuICBwNS5NZXRyby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lRnJvbU5vdykge1xuICAgIHZhciB0ID0gdGltZUZyb21Ob3cgfHwgMDtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdGhpcy5jbG9jay5zdG9wKG5vdyArIHQpO1xuICB9O1xuXG4gIHA1Lk1ldHJvLnByb3RvdHlwZS5iZWF0TGVuZ3RoID0gZnVuY3Rpb24gKHRhdHVtcykge1xuICAgIHRoaXMudGF0dW1zID0gMSAvIHRhdHVtcyAvIDQ7IFxuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDgpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIHQuVGltZWxpbmVTdGF0ZT1mdW5jdGlvbihlKXt0LlRpbWVsaW5lLmNhbGwodGhpcyksdGhpcy5faW5pdGlhbD1lfSx0LmV4dGVuZCh0LlRpbWVsaW5lU3RhdGUsdC5UaW1lbGluZSksdC5UaW1lbGluZVN0YXRlLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldChlKTtyZXR1cm4gbnVsbCE9PXQ/dC5zdGF0ZTp0aGlzLl9pbml0aWFsfSx0LlRpbWVsaW5lU3RhdGUucHJvdG90eXBlLnNldFN0YXRlQXRUaW1lPWZ1bmN0aW9uKGUsdCl7dGhpcy5hZGQoe3N0YXRlOmUsdGltZTp0fSl9LHQuVGltZWxpbmVTdGF0ZX0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgQlBNID0gMTIwO1xuICAvKipcbiAgICogIFNldCB0aGUgZ2xvYmFsIHRlbXBvLCBpbiBiZWF0cyBwZXIgbWludXRlLCBmb3IgYWxsXG4gICAqICBwNS5QYXJ0cy4gVGhpcyBtZXRob2Qgd2lsbCBpbXBhY3QgYWxsIGFjdGl2ZSBwNS5QYXJ0cy5cbiAgICpcbiAgICogIEBtZXRob2Qgc2V0QlBNXG4gICAqICBAZm9yIHA1XG4gICAqICBAcGFyYW0ge051bWJlcn0gQlBNICAgICAgQmVhdHMgUGVyIE1pbnV0ZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IHJhbXBUaW1lIFNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cbiAgcDUucHJvdG90eXBlLnNldEJQTSA9IGZ1bmN0aW9uIChicG0sIHJhbXBUaW1lKSB7XG4gICAgQlBNID0gYnBtO1xuXG4gICAgZm9yICh2YXIgaSBpbiBwNXNvdW5kLnBhcnRzKSB7XG4gICAgICBpZiAocDVzb3VuZC5wYXJ0c1tpXSkge1xuICAgICAgICBwNXNvdW5kLnBhcnRzW2ldLnNldEJQTShicG0sIHJhbXBUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgPHA+QSBwaHJhc2UgaXMgYSBwYXR0ZXJuIG9mIG11c2ljYWwgZXZlbnRzIG92ZXIgdGltZSwgaS5lLlxuICAgKiAgYSBzZXJpZXMgb2Ygbm90ZXMgYW5kIHJlc3RzLjwvcD5cbiAgICpcbiAgICogIDxwPlBocmFzZXMgbXVzdCBiZSBhZGRlZCB0byBhIHA1LlBhcnQgZm9yIHBsYXliYWNrLCBhbmRcbiAgICogIGVhY2ggcGFydCBjYW4gcGxheSBtdWx0aXBsZSBwaHJhc2VzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAqICBGb3IgZXhhbXBsZSwgb25lIFBocmFzZSBtaWdodCBiZSBhIGtpY2sgZHJ1bSwgYW5vdGhlclxuICAgKiAgY291bGQgYmUgYSBzbmFyZSwgYW5kIGFub3RoZXIgY291bGQgYmUgdGhlIGJhc3NsaW5lLjwvcD5cbiAgICpcbiAgICogIDxwPlRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSBuYW1lIHNvIHRoYXQgdGhlIHBocmFzZSBjYW4gYmVcbiAgICogIG1vZGlmaWVkIG9yIGRlbGV0ZWQgbGF0ZXIuIFRoZSBjYWxsYmFjayBpcyBhIGEgZnVuY3Rpb24gdGhhdFxuICAgKiAgdGhpcyBwaHJhc2Ugd2lsbCBjYWxsIGF0IGV2ZXJ5IHN0ZXDigJRmb3IgZXhhbXBsZSBpdCBtaWdodCBiZVxuICAgKiAgY2FsbGVkIDxjb2RlPnBsYXlOb3RlKHZhbHVlKXt9PC9jb2RlPi4gVGhlIGFycmF5IGRldGVybWluZXNcbiAgICogIHdoaWNoIHZhbHVlIGlzIHBhc3NlZCBpbnRvIHRoZSBjYWxsYmFjayBhdCBlYWNoIHN0ZXAgb2YgdGhlXG4gICAqICBwaHJhc2UuIEl0IGNhbiBiZSBudW1iZXJzLCBhbiBvYmplY3Qgd2l0aCBtdWx0aXBsZSBudW1iZXJzLFxuICAgKiAgb3IgYSB6ZXJvICgwKSBpbmRpY2F0ZXMgYSByZXN0IHNvIHRoZSBjYWxsYmFjayB3b24ndCBiZSBjYWxsZWQpLjwvcD5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5QaHJhc2VcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHBhcmFtIHtTdHJpbmd9ICAgbmFtZSAgICAgTmFtZSBzbyB0aGF0IHlvdSBjYW4gYWNjZXNzIHRoZSBQaHJhc2UuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgdGhpcyBwaHJhc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgY2FsbC4gVHlwaWNhbGx5IGl0IHdpbGwgcGxheSBhIHNvdW5kLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGFjY2VwdCB0d28gcGFyYW1ldGVyczogYSB0aW1lIGF0IHdoaWNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBwbGF5IHRoZSBzb3VuZCAoaW4gc2Vjb25kcyBmcm9tIG5vdyksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgYSB2YWx1ZSBmcm9tIHRoZSBzZXF1ZW5jZSBhcnJheS4gVGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lIHNob3VsZCBiZSBwYXNzZWQgaW50byB0aGUgcGxheSgpIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCgpIG1ldGhvZCB0byBlbnN1cmUgcHJlY2lzaW9uLlxuICAgKiAgQHBhcmFtIHtBcnJheX0gICBzZXF1ZW5jZSAgICBBcnJheSBvZiB2YWx1ZXMgdG8gcGFzcyBpbnRvIHRoZSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdCBlYWNoIHN0ZXAgb2YgdGhlIHBocmFzZS5cbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IG15U291bmQsIG15UGhyYXNlLCBteVBhcnQ7XG4gICAqICBsZXQgcGF0dGVybiA9IFsxLDAsMCwyLDAsMiwwLDBdO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgbXlTb3VuZCA9IGxvYWRTb3VuZCgnYXNzZXRzL2JlYXRib3gubXAzJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheU15UGFydCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqICAgIHRleHRBbGlnbihDRU5URVIsIENFTlRFUik7XG4gICAqXG4gICAqICAgIG15UGhyYXNlID0gbmV3IHA1LlBocmFzZSgnYmJveCcsIG9uRWFjaFN0ZXAsIHBhdHRlcm4pO1xuICAgKiAgICBteVBhcnQgPSBuZXcgcDUuUGFydCgpO1xuICAgKiAgICBteVBhcnQuYWRkUGhyYXNlKG15UGhyYXNlKTtcbiAgICogICAgbXlQYXJ0LnNldEJQTSg2MCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBvbkVhY2hTdGVwKHRpbWUsIHBsYXliYWNrUmF0ZSkge1xuICAgKiAgICBteVNvdW5kLnJhdGUocGxheWJhY2tSYXRlKTtcbiAgICogICAgbXlTb3VuZC5wbGF5KHRpbWUpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheU15UGFydCgpIHtcbiAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICogICAgbXlQYXJ0LnN0YXJ0KCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuUGhyYXNlID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBzZXF1ZW5jZSkge1xuICAgIHRoaXMucGhyYXNlU3RlcCA9IDA7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgdmFsdWVzIHRvIHBhc3MgaW50byB0aGUgY2FsbGJhY2tcbiAgICAgKiBhdCBlYWNoIHN0ZXAgb2YgdGhlIHBocmFzZS4gRGVwZW5kaW5nIG9uIHRoZSBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uJ3MgcmVxdWlyZW1lbnRzLCB0aGVzZSB2YWx1ZXMgbWF5IGJlIG51bWJlcnMsXG4gICAgICogc3RyaW5ncywgb3IgYW4gb2JqZWN0IHdpdGggbXVsdGlwbGUgcGFyYW1ldGVycy5cbiAgICAgKiBaZXJvICgwKSBpbmRpY2F0ZXMgYSByZXN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gc2VxdWVuY2VcbiAgICAgKi9cblxuICAgIHRoaXMuc2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgfTtcbiAgLyoqXG4gICAqICA8cD5BIHA1LlBhcnQgcGxheXMgYmFjayBvbmUgb3IgbW9yZSBwNS5QaHJhc2VzLiBJbnN0YW50aWF0ZSBhIHBhcnRcbiAgICogIHdpdGggc3RlcHMgYW5kIHRhdHVtcy4gQnkgZGVmYXVsdCwgZWFjaCBzdGVwIHJlcHJlc2VudHMgYSAxLzE2dGggbm90ZS48L3A+XG4gICAqXG4gICAqICA8cD5TZWUgcDUuUGhyYXNlIGZvciBtb3JlIGFib3V0IG11c2ljYWwgdGltaW5nLjwvcD5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5QYXJ0XG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbc3RlcHNdICAgU3RlcHMgaW4gdGhlIHBhcnRcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGF0dW1zXSBEaXZpc2lvbnMgb2YgYSBiZWF0LCBlLmcuIHVzZSAxLzQsIG9yIDAuMjUgZm9yIGEgcXVhdGVyIG5vdGUgKGRlZmF1bHQgaXMgMS8xNiwgYSBzaXh0ZWVudGggbm90ZSlcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGJveCwgZHJ1bSwgbXlQYXJ0O1xuICAgKiAgbGV0IGJveFBhdCA9IFsxLDAsMCwyLDAsMiwwLDBdO1xuICAgKiAgbGV0IGRydW1QYXQgPSBbMCwxLDEsMCwyLDAsMSwwXTtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIGJveCA9IGxvYWRTb3VuZCgnYXNzZXRzL2JlYXRib3gubXAzJyk7XG4gICAqICAgIGRydW0gPSBsb2FkU291bmQoJ2Fzc2V0cy9kcnVtLm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlNeVBhcnQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHRBbGlnbihDRU5URVIsIENFTlRFUik7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5Jywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKlxuICAgKiAgICBsZXQgYm94UGhyYXNlID0gbmV3IHA1LlBocmFzZSgnYm94JywgcGxheUJveCwgYm94UGF0KTtcbiAgICogICAgbGV0IGRydW1QaHJhc2UgPSBuZXcgcDUuUGhyYXNlKCdkcnVtJywgcGxheURydW0sIGRydW1QYXQpO1xuICAgKiAgICBteVBhcnQgPSBuZXcgcDUuUGFydCgpO1xuICAgKiAgICBteVBhcnQuYWRkUGhyYXNlKGJveFBocmFzZSk7XG4gICAqICAgIG15UGFydC5hZGRQaHJhc2UoZHJ1bVBocmFzZSk7XG4gICAqICAgIG15UGFydC5zZXRCUE0oNjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheUJveCh0aW1lLCBwbGF5YmFja1JhdGUpIHtcbiAgICogICAgYm94LnJhdGUocGxheWJhY2tSYXRlKTtcbiAgICogICAgYm94LnBsYXkodGltZSk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5RHJ1bSh0aW1lLCBwbGF5YmFja1JhdGUpIHtcbiAgICogICAgZHJ1bS5yYXRlKHBsYXliYWNrUmF0ZSk7XG4gICAqICAgIGRydW0ucGxheSh0aW1lKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlNeVBhcnQoKSB7XG4gICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAqXG4gICAqICAgIG15UGFydC5zdGFydCgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlBhcnQgPSBmdW5jdGlvbiAoc3RlcHMsIGJMZW5ndGgpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHN0ZXBzIHx8IDA7IFxuXG4gICAgdGhpcy5wYXJ0U3RlcCA9IDA7XG4gICAgdGhpcy5waHJhc2VzID0gW107XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm5vTG9vcCgpO1xuICAgIHRoaXMudGF0dW1zID0gYkxlbmd0aCB8fCAwLjA2MjU7IFxuXG4gICAgdGhpcy5tZXRybyA9IG5ldyBwNS5NZXRybygpO1xuXG4gICAgdGhpcy5tZXRyby5faW5pdCgpO1xuXG4gICAgdGhpcy5tZXRyby5iZWF0TGVuZ3RoKHRoaXMudGF0dW1zKTtcbiAgICB0aGlzLm1ldHJvLnNldEJQTShCUE0pO1xuICAgIHA1c291bmQucGFydHMucHVzaCh0aGlzKTtcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIHRlbXBvIG9mIHRoaXMgcGFydCwgaW4gQmVhdHMgUGVyIE1pbnV0ZS5cbiAgICpcbiAgICogIEBtZXRob2QgIHNldEJQTVxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqICBAcGFyYW0ge051bWJlcn0gQlBNICAgICAgQmVhdHMgUGVyIE1pbnV0ZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtyYW1wVGltZV0gU2Vjb25kcyBmcm9tIG5vd1xuICAgKi9cblxuXG4gIHA1LlBhcnQucHJvdG90eXBlLnNldEJQTSA9IGZ1bmN0aW9uICh0ZW1wbywgcmFtcFRpbWUpIHtcbiAgICB0aGlzLm1ldHJvLnNldEJQTSh0ZW1wbywgcmFtcFRpbWUpO1xuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgdGhlIHRlbXBvLCBpbiBCZWF0cyBQZXIgTWludXRlLCBvZiB0aGlzIHBhcnQuXG4gICAqXG4gICAqICBAbWV0aG9kIGdldEJQTVxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqICBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuXG5cbiAgcDUuUGFydC5wcm90b3R5cGUuZ2V0QlBNID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1ldHJvLmdldEJQTSgpO1xuICB9O1xuICAvKipcbiAgICogIFN0YXJ0IHBsYXliYWNrIG9mIHRoaXMgcGFydC4gSXQgd2lsbCBwbGF5XG4gICAqICB0aHJvdWdoIGFsbCBvZiBpdHMgcGhyYXNlcyBhdCBhIHNwZWVkXG4gICAqICBkZXRlcm1pbmVkIGJ5IHNldEJQTS5cbiAgICpcbiAgICogIEBtZXRob2QgIHN0YXJ0XG4gICAqICBAZm9yIHA1LlBhcnRcbiAgICogIEBwYXJhbSAge051bWJlcn0gW3RpbWVdIHNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzUGxheWluZykge1xuICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5tZXRyby5yZXNldFN5bmModGhpcyk7XG4gICAgICB2YXIgdCA9IHRpbWUgfHwgMDtcbiAgICAgIHRoaXMubWV0cm8uc3RhcnQodCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIExvb3AgcGxheWJhY2sgb2YgdGhpcyBwYXJ0LiBJdCB3aWxsIGJlZ2luXG4gICAqICBsb29waW5nIHRocm91Z2ggYWxsIG9mIGl0cyBwaHJhc2VzIGF0IGEgc3BlZWRcbiAgICogIGRldGVybWluZWQgYnkgc2V0QlBNLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbG9vcFxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt0aW1lXSBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgcDUuUGFydC5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgdGhpcy5sb29waW5nID0gdHJ1ZTsgXG5cbiAgICB0aGlzLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhcnRTdGVwID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG4gICAgdGhpcy5zdGFydCh0KTtcbiAgfTtcbiAgLyoqXG4gICAqICBUZWxsIHRoZSBwYXJ0IHRvIHN0b3AgbG9vcGluZy5cbiAgICpcbiAgICogIEBtZXRob2QgIG5vTG9vcFxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqL1xuXG5cbiAgcDUuUGFydC5wcm90b3R5cGUubm9Mb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9vcGluZyA9IGZhbHNlOyBcblxuICAgIHRoaXMub25lbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiAgU3RvcCB0aGUgcGFydCBhbmQgY3VlIGl0IHRvIHN0ZXAgMC4gUGxheWJhY2sgd2lsbCByZXN1bWUgZnJvbSB0aGUgYmVnaW5pbmcgb2YgdGhlIFBhcnQgd2hlbiBpdCBpcyBwbGF5ZWQgYWdhaW4uXG4gICAqXG4gICAqICBAbWV0aG9kICBzdG9wXG4gICAqICBAZm9yIHA1LlBhcnRcbiAgICogIEBwYXJhbSAge051bWJlcn0gW3RpbWVdIHNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB0aGlzLnBhcnRTdGVwID0gMDtcbiAgICB0aGlzLnBhdXNlKHRpbWUpO1xuICB9O1xuICAvKipcbiAgICogIFBhdXNlIHRoZSBwYXJ0LiBQbGF5YmFjayB3aWxsIHJlc3VtZVxuICAgKiAgZnJvbSB0aGUgY3VycmVudCBzdGVwLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcGF1c2VcbiAgICogIEBmb3IgcDUuUGFydFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSB0aW1lIHNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcbiAgICB0aGlzLm1ldHJvLnN0b3AodCk7XG4gIH07XG4gIC8qKlxuICAgKiAgQWRkIGEgcDUuUGhyYXNlIHRvIHRoaXMgUGFydC5cbiAgICpcbiAgICogIEBtZXRob2QgIGFkZFBocmFzZVxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqICBAcGFyYW0ge3A1LlBocmFzZX0gICBwaHJhc2UgICByZWZlcmVuY2UgdG8gYSBwNS5QaHJhc2VcbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5hZGRQaHJhc2UgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGFycmF5KSB7XG4gICAgdmFyIHA7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcCA9IG5ldyBwNS5QaHJhc2UobmFtZSwgY2FsbGJhY2ssIGFycmF5KTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIHA1LlBocmFzZSkge1xuICAgICAgcCA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ2ludmFsaWQgaW5wdXQuIGFkZFBocmFzZSBhY2NlcHRzIG5hbWUsIGNhbGxiYWNrLCBhcnJheSBvciBhIHA1LlBocmFzZSc7XG4gICAgfVxuXG4gICAgdGhpcy5waHJhc2VzLnB1c2gocCk7IFxuXG4gICAgaWYgKHAuc2VxdWVuY2UubGVuZ3RoID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gcC5zZXF1ZW5jZS5sZW5ndGg7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFJlbW92ZSBhIHBocmFzZSBmcm9tIHRoaXMgcGFydCwgYmFzZWQgb24gdGhlIG5hbWUgaXQgd2FzXG4gICAqICBnaXZlbiB3aGVuIGl0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcmVtb3ZlUGhyYXNlXG4gICAqICBAZm9yIHA1LlBhcnRcbiAgICogIEBwYXJhbSAge1N0cmluZ30gcGhyYXNlTmFtZVxuICAgKi9cblxuXG4gIHA1LlBhcnQucHJvdG90eXBlLnJlbW92ZVBocmFzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLnBocmFzZXMpIHtcbiAgICAgIGlmICh0aGlzLnBocmFzZXNbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICB0aGlzLnBocmFzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBHZXQgYSBwaHJhc2UgZnJvbSB0aGlzIHBhcnQsIGJhc2VkIG9uIHRoZSBuYW1lIGl0IHdhc1xuICAgKiAgZ2l2ZW4gd2hlbiBpdCB3YXMgY3JlYXRlZC4gTm93IHlvdSBjYW4gbW9kaWZ5IGl0cyBhcnJheS5cbiAgICpcbiAgICogIEBtZXRob2QgIGdldFBocmFzZVxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqICBAcGFyYW0gIHtTdHJpbmd9IHBocmFzZU5hbWVcbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5nZXRQaHJhc2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5waHJhc2VzKSB7XG4gICAgICBpZiAodGhpcy5waHJhc2VzW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGhyYXNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgRmluZCBhbGwgc2VxdWVuY2VzIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLCBhbmQgcmVwbGFjZSB0aGVpciBwYXR0ZXJucyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJyYXkuXG4gICAqXG4gICAqICBAbWV0aG9kICByZXBsYWNlU2VxdWVuY2VcbiAgICogIEBmb3IgcDUuUGFydFxuICAgKiAgQHBhcmFtICB7U3RyaW5nfSBwaHJhc2VOYW1lXG4gICAqICBAcGFyYW0gIHtBcnJheX0gc2VxdWVuY2UgIEFycmF5IG9mIHZhbHVlcyB0byBwYXNzIGludG8gdGhlIGNhbGxiYWNrXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0IGVhY2ggc3RlcCBvZiB0aGUgcGhyYXNlLlxuICAgKi9cblxuXG4gIHA1LlBhcnQucHJvdG90eXBlLnJlcGxhY2VTZXF1ZW5jZSA9IGZ1bmN0aW9uIChuYW1lLCBhcnJheSkge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5waHJhc2VzKSB7XG4gICAgICBpZiAodGhpcy5waHJhc2VzW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgdGhpcy5waHJhc2VzW2ldLnNlcXVlbmNlID0gYXJyYXk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHA1LlBhcnQucHJvdG90eXBlLmluY3JlbWVudFN0ZXAgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIGlmICh0aGlzLnBhcnRTdGVwIDwgdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRpbWUpO1xuICAgICAgdGhpcy5wYXJ0U3RlcCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMubG9vcGluZyAmJiB0aGlzLnBhcnRTdGVwID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy5vbmVuZGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhdCBldmVyeSBzdGVwLiBUaGlzIHdpbGwgY2xlYXIgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgQG1ldGhvZCBvblN0ZXBcbiAgICogIEBmb3IgcDUuUGFydFxuICAgKiAgQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBuYW1lIG9mIHRoZSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlvdSB3YW50IHRvIGZpcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiBldmVyeSBiZWF0L3RhdHVtLlxuICAgKi9cblxuXG4gIHA1LlBhcnQucHJvdG90eXBlLm9uU3RlcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfTsgXG5cbiAgLyoqXG4gICAqICBBIFNjb3JlIGNvbnNpc3RzIG9mIGEgc2VyaWVzIG9mIFBhcnRzLiBUaGUgcGFydHMgd2lsbFxuICAgKiAgYmUgcGxheWVkIGJhY2sgaW4gb3JkZXIuIEZvciBleGFtcGxlLCB5b3UgY291bGQgaGF2ZSBhblxuICAgKiAgQSBwYXJ0LCBhIEIgcGFydCwgYW5kIGEgQyBwYXJ0LCBhbmQgcGxheSB0aGVtIGJhY2sgaW4gdGhpcyBvcmRlclxuICAgKiAgPGNvZGU+bmV3IHA1LlNjb3JlKGEsIGEsIGIsIGEsIGMpPC9jb2RlPlxuICAgKlxuICAgKiAgQGNsYXNzIHA1LlNjb3JlXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBwYXJhbSB7cDUuUGFydH0gWy4uLnBhcnRzXSBPbmUgb3IgbXVsdGlwbGUgcGFydHMsIHRvIGJlIHBsYXllZCBpbiBzZXF1ZW5jZS5cbiAgICovXG5cblxuICBwNS5TY29yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcnRzID0gW107XG4gICAgdGhpcy5jdXJyZW50UGFydCA9IDA7XG4gICAgdmFyIHRoaXNTY29yZSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpIGluIGFyZ3VtZW50cykge1xuICAgICAgaWYgKGFyZ3VtZW50c1tpXSAmJiB0aGlzLnBhcnRzW2ldKSB7XG4gICAgICAgIHRoaXMucGFydHNbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMucGFydHNbaV0ubmV4dFBhcnQgPSB0aGlzLnBhcnRzW2kgKyAxXTtcblxuICAgICAgICB0aGlzLnBhcnRzW2ldLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpc1Njb3JlLnJlc2V0UGFydChpKTtcbiAgICAgICAgICBwbGF5TmV4dFBhcnQodGhpc1Njb3JlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxvb3BpbmcgPSBmYWxzZTtcbiAgfTtcblxuICBwNS5TY29yZS5wcm90b3R5cGUub25lbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sb29waW5nKSB7XG4gICAgICB0aGlzLnBhcnRzWzBdLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGggLSAxXS5vbmVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZXNldFBhcnRzKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFBhcnQgPSAwO1xuICB9O1xuICAvKipcbiAgICogIFN0YXJ0IHBsYXliYWNrIG9mIHRoZSBzY29yZS5cbiAgICpcbiAgICogIEBtZXRob2QgIHN0YXJ0XG4gICAqICBAZm9yIHA1LlNjb3JlXG4gICAqL1xuXG5cbiAgcDUuU2NvcmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGFydHNbdGhpcy5jdXJyZW50UGFydF0uc3RhcnQoKTtcbiAgICB0aGlzLnNjb3JlU3RlcCA9IDA7XG4gIH07XG4gIC8qKlxuICAgKiAgU3RvcCBwbGF5YmFjayBvZiB0aGUgc2NvcmUuXG4gICAqXG4gICAqICBAbWV0aG9kICBzdG9wXG4gICAqICBAZm9yIHA1LlNjb3JlXG4gICAqL1xuXG5cbiAgcDUuU2NvcmUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXJ0c1t0aGlzLmN1cnJlbnRQYXJ0XS5zdG9wKCk7XG4gICAgdGhpcy5jdXJyZW50UGFydCA9IDA7XG4gICAgdGhpcy5zY29yZVN0ZXAgPSAwO1xuICB9O1xuICAvKipcbiAgICogIFBhdXNlIHBsYXliYWNrIG9mIHRoZSBzY29yZS5cbiAgICpcbiAgICogIEBtZXRob2QgIHBhdXNlXG4gICAqICBAZm9yIHA1LlNjb3JlXG4gICAqL1xuXG5cbiAgcDUuU2NvcmUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGFydHNbdGhpcy5jdXJyZW50UGFydF0uc3RvcCgpO1xuICB9O1xuICAvKipcbiAgICogIExvb3AgcGxheWJhY2sgb2YgdGhlIHNjb3JlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbG9vcFxuICAgKiAgQGZvciBwNS5TY29yZVxuICAgKi9cblxuXG4gIHA1LlNjb3JlLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9vcGluZyA9IHRydWU7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9O1xuICAvKipcbiAgICogIFN0b3AgbG9vcGluZyBwbGF5YmFjayBvZiB0aGUgc2NvcmUuIElmIGl0XG4gICAqICBpcyBjdXJyZW50bHkgcGxheWluZywgdGhpcyB3aWxsIGdvIGludG8gZWZmZWN0XG4gICAqICBhZnRlciB0aGUgY3VycmVudCByb3VuZCBvZiBwbGF5YmFjayBjb21wbGV0ZXMuXG4gICAqXG4gICAqICBAbWV0aG9kICBub0xvb3BcbiAgICogIEBmb3IgcDUuU2NvcmVcbiAgICovXG5cblxuICBwNS5TY29yZS5wcm90b3R5cGUubm9Mb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9vcGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIHA1LlNjb3JlLnByb3RvdHlwZS5yZXNldFBhcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgIHNlbGYucmVzZXRQYXJ0c1twYXJ0XTtcbiAgICB9KTtcbiAgfTtcblxuICBwNS5TY29yZS5wcm90b3R5cGUucmVzZXRQYXJ0ID0gZnVuY3Rpb24gKGkpIHtcbiAgICB0aGlzLnBhcnRzW2ldLnN0b3AoKTtcbiAgICB0aGlzLnBhcnRzW2ldLnBhcnRTdGVwID0gMDtcblxuICAgIGZvciAodmFyIHAgaW4gdGhpcy5wYXJ0c1tpXS5waHJhc2VzKSB7XG4gICAgICBpZiAodGhpcy5wYXJ0c1tpXSkge1xuICAgICAgICB0aGlzLnBhcnRzW2ldLnBocmFzZXNbcF0ucGhyYXNlU3RlcCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgdGVtcG8gZm9yIGFsbCBwYXJ0cyBpbiB0aGUgc2NvcmVcbiAgICpcbiAgICogIEBtZXRob2Qgc2V0QlBNXG4gICAqICBAZm9yIHA1LlNjb3JlXG4gICAqICBAcGFyYW0ge051bWJlcn0gQlBNICAgICAgQmVhdHMgUGVyIE1pbnV0ZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IHJhbXBUaW1lIFNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBwNS5TY29yZS5wcm90b3R5cGUuc2V0QlBNID0gZnVuY3Rpb24gKGJwbSwgcmFtcFRpbWUpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucGFydHMpIHtcbiAgICAgIGlmICh0aGlzLnBhcnRzW2ldKSB7XG4gICAgICAgIHRoaXMucGFydHNbaV0uc2V0QlBNKGJwbSwgcmFtcFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwbGF5TmV4dFBhcnQoYVNjb3JlKSB7XG4gICAgYVNjb3JlLmN1cnJlbnRQYXJ0Kys7XG5cbiAgICBpZiAoYVNjb3JlLmN1cnJlbnRQYXJ0ID49IGFTY29yZS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgIGFTY29yZS5zY29yZVN0ZXAgPSAwO1xuICAgICAgYVNjb3JlLm9uZW5kZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVNjb3JlLnNjb3JlU3RlcCA9IDA7XG4gICAgICBhU2NvcmUucGFydHNbYVNjb3JlLmN1cnJlbnRQYXJ0IC0gMV0uc3RvcCgpO1xuICAgICAgYVNjb3JlLnBhcnRzW2FTY29yZS5jdXJyZW50UGFydF0uc3RhcnQoKTtcbiAgICB9XG4gIH1cbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIENsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG4gIC8qKlxuICAgKiBTb3VuZExvb3BcbiAgICpcbiAgICogQGNsYXNzIHA1LlNvdW5kTG9vcFxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvbiBvZiB0aGVsb29wXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2ludGVydmFsXSBhbW91bnQgb2YgdGltZSAoaWYgYSBudW1iZXIpIG9yIGJlYXRzIChpZiBhIHN0cmluZywgZm9sbG93aW5nIDxhIGhyZWYgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RpbWVcIj5Ub25lLlRpbWU8L2E+IGNvbnZlbnRpb24pIGZvciBlYWNoIGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC4gRGVmYXVsdHMgdG8gMSBzZWNvbmQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgc3ludGgsIHNvdW5kTG9vcDtcbiAgICogIGxldCBub3RlUGF0dGVybiA9IFs2MCwgNjIsIDY0LCA2NywgNjksIDcyXTtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgY29sb3JNb2RlKEhTQik7XG4gICAqICAgIGJhY2tncm91bmQoMCwgMCwgODYpO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gc3RhcnQvc3RvcCcsIDEwLCAyMCk7XG4gICAqXG4gICAqICAgIC8vdGhlIGxvb3BlcidzIGNhbGxiYWNrIGlzIHBhc3NlZCB0aGUgdGltZUZyb21Ob3dcbiAgICogICAgLy90aGlzIHZhbHVlIHNob3VsZCBiZSB1c2VkIGFzIGEgcmVmZXJlbmNlIHBvaW50IGZyb21cbiAgICogICAgLy93aGljaCB0byBzY2hlZHVsZSBzb3VuZHNcbiAgICogICAgbGV0IGludGVydmFsSW5TZWNvbmRzID0gMC4yO1xuICAgKiAgICBzb3VuZExvb3AgPSBuZXcgcDUuU291bmRMb29wKG9uU291bmRMb29wLCBpbnRlcnZhbEluU2Vjb25kcyk7XG4gICAqXG4gICAqICAgIHN5bnRoID0gbmV3IHA1Lk1vbm9TeW50aCgpO1xuICAgKiB9XG4gICAqXG4gICAqIGZ1bmN0aW9uIGNhbnZhc1ByZXNzZWQoKSB7XG4gICAqICAgLy8gZW5zdXJlIGF1ZGlvIGlzIGVuYWJsZWRcbiAgICogICB1c2VyU3RhcnRBdWRpbygpO1xuICAgKlxuICAgKiAgIGlmIChzb3VuZExvb3AuaXNQbGF5aW5nKSB7XG4gICAqICAgICBzb3VuZExvb3Auc3RvcCgpO1xuICAgKiAgIH0gZWxzZSB7XG4gICAqICAgICAvLyBzdGFydCB0aGUgbG9vcFxuICAgKiAgICAgc291bmRMb29wLnN0YXJ0KCk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIGZ1bmN0aW9uIG9uU291bmRMb29wKHRpbWVGcm9tTm93KSB7XG4gICAqICAgbGV0IG5vdGVJbmRleCA9IChzb3VuZExvb3AuaXRlcmF0aW9ucyAtIDEpICUgbm90ZVBhdHRlcm4ubGVuZ3RoO1xuICAgKiAgIGxldCBub3RlID0gbWlkaVRvRnJlcShub3RlUGF0dGVybltub3RlSW5kZXhdKTtcbiAgICogICBzeW50aC5wbGF5KG5vdGUsIDAuNSwgdGltZUZyb21Ob3cpO1xuICAgKiAgIGJhY2tncm91bmQobm90ZUluZGV4ICogMzYwIC8gbm90ZVBhdHRlcm4ubGVuZ3RoLCA1MCwgMTAwKTtcbiAgICogfVxuICAgKiA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuU291bmRMb29wID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpbnRlcnZhbCkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiBtdXNpY2FsVGltZU1vZGUgdXNlcyA8YSBocmVmID0gXCJodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9UaW1lXCI+VG9uZS5UaW1lPC9hPiBjb252ZW50aW9uXG4gICAgICogdHJ1ZSBpZiBzdHJpbmcsIGZhbHNlIGlmIG51bWJlclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbXVzaWNhbFRpbWVNb2RlXG4gICAgICovXG5cbiAgICB0aGlzLm11c2ljYWxUaW1lTW9kZSA9IHR5cGVvZiB0aGlzLl9pbnRlcnZhbCA9PT0gJ251bWJlcicgPyBmYWxzZSA6IHRydWU7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCAxO1xuICAgIC8qKlxuICAgICAqIG11c2ljYWxUaW1lTW9kZSB2YXJpYWJsZXNcbiAgICAgKiBtb2RpZnkgdGhlc2Ugb25seSB3aGVuIHRoZSBpbnRlcnZhbCBpcyBzcGVjaWZpZWQgaW4gbXVzaWNhbFRpbWUgZm9ybWF0IGFzIGEgc3RyaW5nXG4gICAgICovXG5cbiAgICB0aGlzLl90aW1lU2lnbmF0dXJlID0gNDtcbiAgICB0aGlzLl9icG0gPSA2MDtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCBhIGxpbWl0IHRvIHRoZSBudW1iZXIgb2YgbG9vcHMgdG8gcGxheS4gZGVmYXVsdHMgdG8gSW5maW5pdHlcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbWF4SXRlcmF0aW9uc1xuICAgICAqL1xuXG4gICAgdGhpcy5tYXhJdGVyYXRpb25zID0gSW5maW5pdHk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuY2xvY2sgPSBuZXcgQ2xvY2soe1xuICAgICAgJ2NhbGxiYWNrJzogZnVuY3Rpb24gY2FsbGJhY2sodGltZSkge1xuICAgICAgICB2YXIgdGltZUZyb21Ob3cgPSB0aW1lIC0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEbyBub3QgaW5pdGlhdGUgdGhlIGNhbGxiYWNrIGlmIHRpbWVGcm9tTm93IGlzIDwgMFxuICAgICAgICAgKiBUaGlzIHVzdXN1YWxseSBvY2N1cnMgZm9yIGEgZmV3IG1pbGxpc2Vjb25kcyB3aGVuIHRoZSBwYWdlXG4gICAgICAgICAqIGlzIG5vdCBmdWxseSBsb2FkZWRcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB1bnRpbCBtYXhJdGVyYXRpb25zIGlzIHJlYWNoZWRcbiAgICAgICAgICovXG5cbiAgICAgICAgaWYgKHRpbWVGcm9tTm93ID4gMCAmJiBzZWxmLml0ZXJhdGlvbnMgPD0gc2VsZi5tYXhJdGVyYXRpb25zKSB7XG4gICAgICAgICAgc2VsZi5jYWxsYmFjayh0aW1lRnJvbU5vdyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnZnJlcXVlbmN5JzogdGhpcy5fY2FsY0ZyZXEoKVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogU3RhcnQgdGhlIGxvb3BcbiAgICogQG1ldGhvZCAgc3RhcnRcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIGEgc3RhcnRpbmcgdGltZVxuICAgKi9cblxuXG4gIHA1LlNvdW5kTG9vcC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZUZyb21Ob3cpIHtcbiAgICB2YXIgdCA9IHRpbWVGcm9tTm93IHx8IDA7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuXG4gICAgaWYgKCF0aGlzLmlzUGxheWluZykge1xuICAgICAgdGhpcy5jbG9jay5zdGFydChub3cgKyB0KTtcbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTdG9wIHRoZSBsb29wXG4gICAqIEBtZXRob2QgIHN0b3BcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIGEgc3RvcHBpbmcgdGltZVxuICAgKi9cblxuXG4gIHA1LlNvdW5kTG9vcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lRnJvbU5vdykge1xuICAgIHZhciB0ID0gdGltZUZyb21Ob3cgfHwgMDtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG5cbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMuY2xvY2suc3RvcChub3cgKyB0KTtcbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUGF1c2UgdGhlIGxvb3BcbiAgICogQG1ldGhvZCBwYXVzZVxuICAgKiBAZm9yIHA1LlNvdW5kTG9vcFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gc2NoZWR1bGUgYSBwYXVzaW5nIHRpbWVcbiAgICovXG5cblxuICBwNS5Tb3VuZExvb3AucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHRpbWVGcm9tTm93KSB7XG4gICAgdmFyIHQgPSB0aW1lRnJvbU5vdyB8fCAwO1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcblxuICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgdGhpcy5jbG9jay5wYXVzZShub3cgKyB0KTtcbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogU3luY2hyb25pemUgbG9vcHMuIFVzZSB0aGlzIG1ldGhvZCB0byBzdGFydCB0d28gbW9yZSBtb3JlIGxvb3BzIGluIHN5bmNocm9uaXphdGlvblxuICAgKiBvciB0byBzdGFydCBhIGxvb3AgaW4gc3luY2hyb25pemF0aW9uIHdpdGggYSBsb29wIHRoYXQgaXMgYWxyZWFkeSBwbGF5aW5nXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgc2NoZWR1bGUgdGhlIGltcGxpY2l0IGxvb3AgaW4gc3luYyB3aXRoIHRoZSBleHBsaWNpdCBtYXN0ZXIgbG9vcFxuICAgKiBpLmUuIGxvb3BUb1N0YXJ0LnN5bmNlZFN0YXJ0KGxvb3BUb1N5bmNXaXRoKVxuICAgKlxuICAgKiBAbWV0aG9kICBzeW5jZWRTdGFydFxuICAgKiBAZm9yIHA1LlNvdW5kTG9vcFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG90aGVyTG9vcCAgIGEgcDUuU291bmRMb29wIHRvIHN5bmMgd2l0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gU3RhcnQgdGhlIGxvb3BzIGluIHN5bmMgYWZ0ZXIgdGltZUZyb21Ob3cgc2Vjb25kc1xuICAgKi9cblxuXG4gIHA1LlNvdW5kTG9vcC5wcm90b3R5cGUuc3luY2VkU3RhcnQgPSBmdW5jdGlvbiAob3RoZXJMb29wLCB0aW1lRnJvbU5vdykge1xuICAgIHZhciB0ID0gdGltZUZyb21Ob3cgfHwgMDtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG5cbiAgICBpZiAoIW90aGVyTG9vcC5pc1BsYXlpbmcpIHtcbiAgICAgIG90aGVyTG9vcC5jbG9jay5zdGFydChub3cgKyB0KTtcbiAgICAgIG90aGVyTG9vcC5pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5jbG9jay5zdGFydChub3cgKyB0KTtcbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG90aGVyTG9vcC5pc1BsYXlpbmcpIHtcbiAgICAgIHZhciB0aW1lID0gb3RoZXJMb29wLmNsb2NrLl9uZXh0VGljayAtIHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5jbG9jay5zdGFydChub3cgKyB0aW1lKTtcbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBVcGRhdGVzIGZyZXF1ZW5jeSB2YWx1ZSwgcmVmbGVjdGVkIGluIG5leHQgY2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICogQG1ldGhvZCAgX3VwZGF0ZVxuICAgKi9cblxuXG4gIHA1LlNvdW5kTG9vcC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsb2NrLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuX2NhbGNGcmVxKCk7XG4gIH07XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgY2xvY2sncyBjYWxsYmFjayBiYXNlZCBvbiBicG0sIGludGVydmFsLCBhbmQgdGltZXNpZ25hdHVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZm9yIHA1LlNvdW5kTG9vcFxuICAgKiBAbWV0aG9kICBfY2FsY0ZyZXFcbiAgICogQHJldHVybiB7TnVtYmVyfSBuZXcgY2xvY2sgZnJlcXVlbmN5IHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuU291bmRMb29wLnByb3RvdHlwZS5fY2FsY0ZyZXEgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcnZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubXVzaWNhbFRpbWVNb2RlID0gZmFsc2U7XG4gICAgICByZXR1cm4gMSAvIHRoaXMuX2ludGVydmFsO1xuICAgIH0gXG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuX2ludGVydmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm11c2ljYWxUaW1lTW9kZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9icG0gLyA2MCAvIHRoaXMuX2NvbnZlcnROb3RhdGlvbih0aGlzLl9pbnRlcnZhbCkgKiAodGhpcy5fdGltZVNpZ25hdHVyZSAvIDQpO1xuICAgICAgfVxuICB9O1xuICAvKipcbiAgICogQ29udmVydCBub3RhdGlvbiBmcm9tIG11c2ljYWwgdGltZSBmb3JtYXQgdG8gc2Vjb25kc1xuICAgKiBVc2VzIDxhIGhyZWYgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RpbWVcIj5Ub25lLlRpbWU8L2E+IGNvbnZlbnRpb25cbiAgICogQHByaXZhdGVcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICogQG1ldGhvZCBfY29udmVydE5vdGF0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdmFsdWUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgY29udmVydGVkIHZhbHVlIGluIHNlY29uZHNcbiAgICovXG5cblxuICBwNS5Tb3VuZExvb3AucHJvdG90eXBlLl9jb252ZXJ0Tm90YXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHZhbHVlLnNsaWNlKC0xKTtcbiAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZS5zbGljZSgwLCAtMSkpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lYXN1cmUodmFsdWUpO1xuXG4gICAgICBjYXNlICduJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vdGUodmFsdWUpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oJ1NwZWNpZmllZCBpbnRlcnZhbCBpcyBub3QgZm9ybWF0dGVkIGNvcnJlY3RseS4gU2VlIFRvbmUuanMgJyArICd0aW1pbmcgcmVmZXJlbmNlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RpbWUnKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBIZWxwZXIgY29udmVyc2lvbiBtZXRob2RzIG9mIG1lYXN1cmUgYW5kIG5vdGVcbiAgICogQHByaXZhdGVcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICogQG1ldGhvZCAgX21lYXN1cmVcbiAgICovXG5cblxuICBwNS5Tb3VuZExvb3AucHJvdG90eXBlLl9tZWFzdXJlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICogdGhpcy5fdGltZVNpZ25hdHVyZTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgIF9ub3RlXG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqL1xuXG5cbiAgcDUuU291bmRMb29wLnByb3RvdHlwZS5fbm90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl90aW1lU2lnbmF0dXJlIC8gdmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBHZXR0ZXJzIGFuZCBTZXR0ZXJzLCBzZXR0aW5nIGFueSBwYXJhbXRlciB3aWxsIHJlc3VsdCBpbiBhIGNoYW5nZSBpbiB0aGUgY2xvY2snc1xuICAgKiBmcmVxdWVuY3ksIHRoYXQgd2lsbCBiZSByZWZsZWN0ZWQgYWZ0ZXIgdGhlIG5leHQgY2FsbGJhY2tcbiAgICogYmVhdHMgcGVyIG1pbnV0ZSAoZGVmYXVsdHMgdG8gNjApXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBicG1cbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICovXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocDUuU291bmRMb29wLnByb3RvdHlwZSwgJ2JwbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9icG07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChicG0pIHtcbiAgICAgIGlmICghdGhpcy5tdXNpY2FsVGltZU1vZGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDaGFuZ2luZyB0aGUgQlBNIGluIFwic2Vjb25kc1wiIG1vZGUgaGFzIG5vIGVmZmVjdC4gJyArICdCUE0gaXMgb25seSByZWxldmFudCBpbiBtdXNpY2FsVGltZU1vZGUgJyArICd3aGVuIHRoZSBpbnRlcnZhbCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgJyArICcoXCIyblwiLCBcIjRuXCIsIFwiMW1cIi4uLmV0YyknKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYnBtID0gYnBtO1xuXG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogbnVtYmVyIG9mIHF1YXJ0ZXIgbm90ZXMgaW4gYSBtZWFzdXJlIChkZWZhdWx0cyB0byA0KVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gdGltZVNpZ25hdHVyZVxuICAgKiBAZm9yIHA1LlNvdW5kTG9vcFxuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocDUuU291bmRMb29wLnByb3RvdHlwZSwgJ3RpbWVTaWduYXR1cmUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZVNpZ25hdHVyZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHRpbWVTaWcpIHtcbiAgICAgIGlmICghdGhpcy5tdXNpY2FsVGltZU1vZGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDaGFuZ2luZyB0aGUgdGltZVNpZ25hdHVyZSBpbiBcInNlY29uZHNcIiBtb2RlIGhhcyBubyBlZmZlY3QuICcgKyAnQlBNIGlzIG9ubHkgcmVsZXZhbnQgaW4gbXVzaWNhbFRpbWVNb2RlICcgKyAnd2hlbiB0aGUgaW50ZXJ2YWwgaXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICcgKyAnKFwiMm5cIiwgXCI0blwiLCBcIjFtXCIuLi5ldGMpJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RpbWVTaWduYXR1cmUgPSB0aW1lU2lnO1xuXG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogbGVuZ3RoIG9mIHRoZSBsb29wcyBpbnRlcnZhbFxuICAgKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IGludGVydmFsXG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwNS5Tb3VuZExvb3AucHJvdG90eXBlLCAnaW50ZXJ2YWwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbnRlcnZhbCkge1xuICAgICAgdGhpcy5tdXNpY2FsVGltZU1vZGUgPSB0eXBlb2YgaW50ZXJ2YWwgPT09ICdOdW1iZXInID8gZmFsc2UgOiB0cnVlO1xuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcblxuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIGhvdyBtYW55IHRpbWVzIHRoZSBjYWxsYmFjayBoYXMgYmVlbiBjYWxsZWQgc28gZmFyXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpdGVyYXRpb25zXG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqIEByZWFkb25seVxuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocDUuU291bmRMb29wLnByb3RvdHlwZSwgJ2l0ZXJhdGlvbnMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9jay50aWNrcztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcDUuU291bmRMb29wO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIEVmZmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbiAgdmFyIEN1c3RvbUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIC8qKlxuICAgKiBDb21wcmVzc29yIGlzIGFuIGF1ZGlvIGVmZmVjdCBjbGFzcyB0aGF0IHBlcmZvcm1zIGR5bmFtaWNzIGNvbXByZXNzaW9uXG4gICAqIG9uIGFuIGF1ZGlvIGlucHV0IHNvdXJjZS4gVGhpcyBpcyBhIHZlcnkgY29tbW9ubHkgdXNlZCB0ZWNobmlxdWUgaW4gbXVzaWNcbiAgICogYW5kIHNvdW5kIHByb2R1Y3Rpb24uIENvbXByZXNzaW9uIGNyZWF0ZXMgYW4gb3ZlcmFsbCBsb3VkZXIsIHJpY2hlcixcbiAgICogYW5kIGZ1bGxlciBzb3VuZCBieSBsb3dlcmluZyB0aGUgdm9sdW1lIG9mIGxvdWRzIGFuZCByYWlzaW5nIHRoYXQgb2Ygc29mdHMuXG4gICAqIENvbXByZXNzaW9uIGNhbiBiZSB1c2VkIHRvIGF2b2lkIGNsaXBwaW5nIChzb3VuZCBkaXN0b3J0aW9uIGR1ZSB0b1xuICAgKiBwZWFrcyBpbiB2b2x1bWUpIGFuZCBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIG1hbnkgc291bmRzIGFyZSBwbGF5ZWRcbiAgICogYXQgb25jZS4gQ29tcHJlc3Npb24gY2FuIGJlIHVzZWQgb24gaW5kaXZ1ZGFsIHNvdW5kIHNvdXJjZXMgaW4gYWRkaXRpb25cbiAgICogdG8gdGhlIG1hc3RlciBvdXRwdXQuXG4gICAqXG4gICAqIFRoaXMgY2xhc3MgZXh0ZW5kcyA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0XCI+cDUuRWZmZWN0PC9hPi5cbiAgICogTWV0aG9kcyA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2FtcFwiPmFtcCgpPC9hPiwgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9jaGFpblwiPmNoYWluKCk8L2E+LFxuICAgKiA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2RyeXdldFwiPmRyeXdldCgpPC9hPiwgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9jb25uZWN0XCI+Y29ubmVjdCgpPC9hPiwgYW5kXG4gICAqIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZGlzY29ubmVjdFwiPmRpc2Nvbm5lY3QoKTwvYT4gYXJlIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQGNsYXNzIHA1LkNvbXByZXNzb3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHA1LkVmZmVjdFxuICAgKlxuICAgKlxuICAgKi9cblxuXG4gIHA1LkNvbXByZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LmNhbGwodGhpcyk7XG4gICAgLyoqXG4gICAgICogVGhlIHA1LkNvbXByZXNzb3IgaXMgYnVpbHQgd2l0aCBhIDxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI3RoZS1keW5hbWljc2NvbXByZXNzb3Jub2RlLWludGVyZmFjZVwiXG4gICAgKiAgIHRhcmdldD1cIl9ibGFua1wiIHRpdGxlPVwiVzMgc3BlYyBmb3IgRHluYW1pY3MgQ29tcHJlc3NvciBOb2RlXCI+V2ViIEF1ZGlvIER5bmFtaWNzIENvbXByZXNzb3IgTm9kZVxuICAgICogICA8L2E+XG4gICAgICogQHByb3BlcnR5IHtBdWRpb05vZGV9IGNvbXByZXNzb3JcbiAgICAgKi9cblxuICAgIHRoaXMuY29tcHJlc3NvciA9IHRoaXMuYWMuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuY29tcHJlc3Nvcik7XG4gICAgdGhpcy5jb21wcmVzc29yLmNvbm5lY3QodGhpcy53ZXQpO1xuICB9O1xuXG4gIHA1LkNvbXByZXNzb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFZmZlY3QucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqIFBlcmZvcm1zIHRoZSBzYW1lIGZ1bmN0aW9uIGFzIC5jb25uZWN0LCBidXQgYWxzbyBhY2NlcHRzXG4gICAqIG9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gc2V0IGNvbXByZXNzb3IncyBhdWRpb1BhcmFtc1xuICAgKiBAbWV0aG9kIHByb2Nlc3NcbiAgICogQGZvciBwNS5Db21wcmVzc29yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgICAgICAgICBTb3VuZCBzb3VyY2UgdG8gYmUgY29ubmVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYXR0YWNrXSAgICAgVGhlIGFtb3VudCBvZiB0aW1lIChpbiBzZWNvbmRzKSB0byByZWR1Y2UgdGhlIGdhaW4gYnkgMTBkQixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IC4wMDMsIHJhbmdlIDAgLSAxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBba25lZV0gICAgICAgQSBkZWNpYmVsIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcmFuZ2UgYWJvdmUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCB3aGVyZSB0aGUgY3VydmUgc21vb3RobHkgdHJhbnNpdGlvbnMgdG8gdGhlIFwicmF0aW9cIiBwb3J0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ID0gMzAsIHJhbmdlIDAgLSA0MFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3JhdGlvXSAgICAgIFRoZSBhbW91bnQgb2YgZEIgY2hhbmdlIGluIGlucHV0IGZvciBhIDEgZEIgY2hhbmdlIGluIG91dHB1dFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ID0gMTIsIHJhbmdlIDEgLSAyMFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RocmVzaG9sZF0gIFRoZSBkZWNpYmVsIHZhbHVlIGFib3ZlIHdoaWNoIHRoZSBjb21wcmVzc2lvbiB3aWxsIHN0YXJ0IHRha2luZyBlZmZlY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IC0yNCwgcmFuZ2UgLTEwMCAtIDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZWxlYXNlXSAgICBUaGUgYW1vdW50IG9mIHRpbWUgKGluIHNlY29uZHMpIHRvIGluY3JlYXNlIHRoZSBnYWluIGJ5IDEwZEJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IC4yNSwgcmFuZ2UgMCAtIDFcbiAgICovXG5cbiAgcDUuQ29tcHJlc3Nvci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIGF0dGFjaywga25lZSwgcmF0aW8sIHRocmVzaG9sZCwgcmVsZWFzZSkge1xuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICAgIHRoaXMuc2V0KGF0dGFjaywga25lZSwgcmF0aW8sIHRocmVzaG9sZCwgcmVsZWFzZSk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdGhlIHBhcmFtdGVycyBvZiBhIGNvbXByZXNzb3IuXG4gICAqIEBtZXRob2QgIHNldFxuICAgKiBAZm9yIHA1LkNvbXByZXNzb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGFjayAgICAgVGhlIGFtb3VudCBvZiB0aW1lIChpbiBzZWNvbmRzKSB0byByZWR1Y2UgdGhlIGdhaW4gYnkgMTBkQixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IC4wMDMsIHJhbmdlIDAgLSAxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBrbmVlICAgICAgIEEgZGVjaWJlbCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHJhbmdlIGFib3ZlIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgd2hlcmUgdGhlIGN1cnZlIHNtb290aGx5IHRyYW5zaXRpb25zIHRvIHRoZSBcInJhdGlvXCIgcG9ydGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IDMwLCByYW5nZSAwIC0gNDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvICAgICAgVGhlIGFtb3VudCBvZiBkQiBjaGFuZ2UgaW4gaW5wdXQgZm9yIGEgMSBkQiBjaGFuZ2UgaW4gb3V0cHV0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAxMiwgcmFuZ2UgMSAtIDIwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgIFRoZSBkZWNpYmVsIHZhbHVlIGFib3ZlIHdoaWNoIHRoZSBjb21wcmVzc2lvbiB3aWxsIHN0YXJ0IHRha2luZyBlZmZlY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IC0yNCwgcmFuZ2UgLTEwMCAtIDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlbGVhc2UgICAgVGhlIGFtb3VudCBvZiB0aW1lIChpbiBzZWNvbmRzKSB0byBpbmNyZWFzZSB0aGUgZ2FpbiBieSAxMGRCXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAuMjUsIHJhbmdlIDAgLSAxXG4gICAqL1xuXG5cbiAgcDUuQ29tcHJlc3Nvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGF0dGFjaywga25lZSwgcmF0aW8sIHRocmVzaG9sZCwgcmVsZWFzZSkge1xuICAgIGlmICh0eXBlb2YgYXR0YWNrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5hdHRhY2soYXR0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGtuZWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmtuZWUoa25lZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByYXRpbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmF0aW8ocmF0aW8pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy50aHJlc2hvbGQodGhyZXNob2xkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlbGVhc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlbGVhc2UocmVsZWFzZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogR2V0IGN1cnJlbnQgYXR0YWNrIG9yIHNldCB2YWx1ZSB3LyB0aW1lIHJhbXBcbiAgICpcbiAgICpcbiAgICogQG1ldGhvZCBhdHRhY2tcbiAgICogQGZvciBwNS5Db21wcmVzc29yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYXR0YWNrXSBBdHRhY2sgaXMgdGhlIGFtb3VudCBvZiB0aW1lIChpbiBzZWNvbmRzKSB0byByZWR1Y2UgdGhlIGdhaW4gYnkgMTBkQixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAuMDAzLCByYW5nZSAwIC0gMVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVdICBBc3NpZ24gdGltZSB2YWx1ZSB0byBzY2hlZHVsZSB0aGUgY2hhbmdlIGluIHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuQ29tcHJlc3Nvci5wcm90b3R5cGUuYXR0YWNrID0gZnVuY3Rpb24gKGF0dGFjaywgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiBhdHRhY2sgPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5hdHRhY2sudmFsdWUgPSBhdHRhY2s7XG4gICAgICB0aGlzLmNvbXByZXNzb3IuYXR0YWNrLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5jb21wcmVzc29yLmF0dGFjay5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShhdHRhY2ssIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXR0YWNrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYXR0YWNrLmNvbm5lY3QodGhpcy5jb21wcmVzc29yLmF0dGFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcHJlc3Nvci5hdHRhY2sudmFsdWU7XG4gIH07XG4gIC8qKlxuICAgICogR2V0IGN1cnJlbnQga25lZSBvciBzZXQgdmFsdWUgdy8gdGltZSByYW1wXG4gICAgKlxuICAgICogQG1ldGhvZCBrbmVlXG4gICAgKiBAZm9yIHA1LkNvbXByZXNzb3JcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBba25lZV0gQSBkZWNpYmVsIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcmFuZ2UgYWJvdmUgdGhlXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCB3aGVyZSB0aGUgY3VydmUgc21vb3RobHkgdHJhbnNpdGlvbnMgdG8gdGhlIFwicmF0aW9cIiBwb3J0aW9uLlxuICAgICogICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ID0gMzAsIHJhbmdlIDAgLSA0MFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lXSAgQXNzaWduIHRpbWUgdmFsdWUgdG8gc2NoZWR1bGUgdGhlIGNoYW5nZSBpbiB2YWx1ZVxuICAgICovXG5cblxuICBwNS5Db21wcmVzc29yLnByb3RvdHlwZS5rbmVlID0gZnVuY3Rpb24gKGtuZWUsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2Yga25lZSA9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jb21wcmVzc29yLmtuZWUudmFsdWUgPSBrbmVlO1xuICAgICAgdGhpcy5jb21wcmVzc29yLmtuZWUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmNvbXByZXNzb3Iua25lZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShrbmVlLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtuZWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBrbmVlLmNvbm5lY3QodGhpcy5jb21wcmVzc29yLmtuZWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXByZXNzb3Iua25lZS52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHJhdGlvIG9yIHNldCB2YWx1ZSB3LyB0aW1lIHJhbXBcbiAgICogQG1ldGhvZCByYXRpb1xuICAgKiBAZm9yIHA1LkNvbXByZXNzb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gICAgICBUaGUgYW1vdW50IG9mIGRCIGNoYW5nZSBpbiBpbnB1dCBmb3IgYSAxIGRCIGNoYW5nZSBpbiBvdXRwdXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IDEyLCByYW5nZSAxIC0gMjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lXSAgQXNzaWduIHRpbWUgdmFsdWUgdG8gc2NoZWR1bGUgdGhlIGNoYW5nZSBpbiB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LkNvbXByZXNzb3IucHJvdG90eXBlLnJhdGlvID0gZnVuY3Rpb24gKHJhdGlvLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHJhdGlvID09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNvbXByZXNzb3IucmF0aW8udmFsdWUgPSByYXRpbztcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5yYXRpby5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5yYXRpby5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShyYXRpbywgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByYXRpbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJhdGlvLmNvbm5lY3QodGhpcy5jb21wcmVzc29yLnJhdGlvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb21wcmVzc29yLnJhdGlvLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGhyZXNob2xkIG9yIHNldCB2YWx1ZSB3LyB0aW1lIHJhbXBcbiAgICogQG1ldGhvZCB0aHJlc2hvbGRcbiAgICogQGZvciBwNS5Db21wcmVzc29yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgIFRoZSBkZWNpYmVsIHZhbHVlIGFib3ZlIHdoaWNoIHRoZSBjb21wcmVzc2lvbiB3aWxsIHN0YXJ0IHRha2luZyBlZmZlY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IC0yNCwgcmFuZ2UgLTEwMCAtIDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lXSAgQXNzaWduIHRpbWUgdmFsdWUgdG8gc2NoZWR1bGUgdGhlIGNoYW5nZSBpbiB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LkNvbXByZXNzb3IucHJvdG90eXBlLnRocmVzaG9sZCA9IGZ1bmN0aW9uICh0aHJlc2hvbGQsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgdGhyZXNob2xkID09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNvbXByZXNzb3IudGhyZXNob2xkLnZhbHVlID0gdGhyZXNob2xkO1xuICAgICAgdGhpcy5jb21wcmVzc29yLnRocmVzaG9sZC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci50aHJlc2hvbGQubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhyZXNob2xkLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocmVzaG9sZC5jb25uZWN0KHRoaXMuY29tcHJlc3Nvci50aHJlc2hvbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXByZXNzb3IudGhyZXNob2xkLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogR2V0IGN1cnJlbnQgcmVsZWFzZSBvciBzZXQgdmFsdWUgdy8gdGltZSByYW1wXG4gICAqIEBtZXRob2QgcmVsZWFzZVxuICAgKiBAZm9yIHA1LkNvbXByZXNzb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlbGVhc2UgICAgVGhlIGFtb3VudCBvZiB0aW1lIChpbiBzZWNvbmRzKSB0byBpbmNyZWFzZSB0aGUgZ2FpbiBieSAxMGRCXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAuMjUsIHJhbmdlIDAgLSAxXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gIEFzc2lnbiB0aW1lIHZhbHVlIHRvIHNjaGVkdWxlIHRoZSBjaGFuZ2UgaW4gdmFsdWVcbiAgICovXG5cblxuICBwNS5Db21wcmVzc29yLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKHJlbGVhc2UsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgcmVsZWFzZSA9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jb21wcmVzc29yLnJlbGVhc2UudmFsdWUgPSByZWxlYXNlO1xuICAgICAgdGhpcy5jb21wcmVzc29yLnJlbGVhc2UuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmNvbXByZXNzb3IucmVsZWFzZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShyZWxlYXNlLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG51bWJlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlbGVhc2UuY29ubmVjdCh0aGlzLmNvbXByZXNzb3IucmVsZWFzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcHJlc3Nvci5yZWxlYXNlLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHJlZHVjdGlvbiB2YWx1ZVxuICAgKlxuICAgKiBAbWV0aG9kIHJlZHVjdGlvblxuICAgKiBAZm9yIHA1LkNvbXByZXNzb3JcbiAgICogQHJldHVybiB7TnVtYmVyfSBWYWx1ZSBvZiB0aGUgYW1vdW50IG9mIGdhaW4gcmVkdWN0aW9uIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgc2lnbmFsXG4gICAqL1xuXG5cbiAgcDUuQ29tcHJlc3Nvci5wcm90b3R5cGUucmVkdWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXByZXNzb3IucmVkdWN0aW9uLnZhbHVlO1xuICB9O1xuXG4gIHA1LkNvbXByZXNzb3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY29tcHJlc3Nvcikge1xuICAgICAgdGhpcy5jb21wcmVzc29yLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbXByZXNzb3I7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBwNS5Db21wcmVzc29yO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgICAgY29udmVydFRvV2F2ID0gX3JlcXVpcmUuY29udmVydFRvV2F2LFxuICAgICAgc2FmZUJ1ZmZlclNpemUgPSBfcmVxdWlyZS5zYWZlQnVmZmVyU2l6ZTtcblxuICB2YXIgcHJvY2Vzc29yTmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuICB2YXIgYWMgPSBwNXNvdW5kLmF1ZGlvY29udGV4dDtcbiAgLyoqXG4gICAqICA8cD5SZWNvcmQgc291bmRzIGZvciBwbGF5YmFjayBhbmQvb3IgdG8gc2F2ZSBhcyBhIC53YXYgZmlsZS5cbiAgICogIFRoZSBwNS5Tb3VuZFJlY29yZGVyIHJlY29yZHMgYWxsIHNvdW5kIG91dHB1dCBmcm9tIHlvdXIgc2tldGNoLFxuICAgKiAgb3IgY2FuIGJlIGFzc2lnbmVkIGEgc3BlY2lmaWMgc291cmNlIHdpdGggc2V0SW5wdXQoKS48L3A+XG4gICAqICA8cD5UaGUgcmVjb3JkKCkgbWV0aG9kIGFjY2VwdHMgYSBwNS5Tb3VuZEZpbGUgYXMgYSBwYXJhbWV0ZXIuXG4gICAqICBXaGVuIHBsYXliYWNrIGlzIHN0b3BwZWQgKGVpdGhlciBhZnRlciB0aGUgZ2l2ZW4gYW1vdW50IG9mIHRpbWUsXG4gICAqICBvciB3aXRoIHRoZSBzdG9wKCkgbWV0aG9kKSwgdGhlIHA1LlNvdW5kUmVjb3JkZXIgd2lsbCBzZW5kIGl0c1xuICAgKiAgcmVjb3JkaW5nIHRvIHRoYXQgcDUuU291bmRGaWxlIGZvciBwbGF5YmFjay48L3A+XG4gICAqXG4gICAqICBAY2xhc3MgcDUuU291bmRSZWNvcmRlclxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBtaWMsIHJlY29yZGVyLCBzb3VuZEZpbGU7XG4gICAqICBsZXQgc3RhdGUgPSAwO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHRBbGlnbihDRU5URVIsIENFTlRFUik7XG4gICAqXG4gICAqICAgIC8vIGNyZWF0ZSBhbiBhdWRpbyBpblxuICAgKiAgICBtaWMgPSBuZXcgcDUuQXVkaW9JbigpO1xuICAgKlxuICAgKiAgICAvLyBwcm9tcHRzIHVzZXIgdG8gZW5hYmxlIHRoZWlyIGJyb3dzZXIgbWljXG4gICAqICAgIG1pYy5zdGFydCgpO1xuICAgKlxuICAgKiAgICAvLyBjcmVhdGUgYSBzb3VuZCByZWNvcmRlclxuICAgKiAgICByZWNvcmRlciA9IG5ldyBwNS5Tb3VuZFJlY29yZGVyKCk7XG4gICAqXG4gICAqICAgIC8vIGNvbm5lY3QgdGhlIG1pYyB0byB0aGUgcmVjb3JkZXJcbiAgICogICAgcmVjb3JkZXIuc2V0SW5wdXQobWljKTtcbiAgICpcbiAgICogICAgLy8gdGhpcyBzb3VuZCBmaWxlIHdpbGwgYmUgdXNlZCB0b1xuICAgKiAgICAvLyBwbGF5YmFjayAmIHNhdmUgdGhlIHJlY29yZGluZ1xuICAgKiAgICBzb3VuZEZpbGUgPSBuZXcgcDUuU291bmRGaWxlKCk7XG4gICAqXG4gICAqICAgIHRleHQoJ3RhcCB0byByZWNvcmQnLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBjYW52YXNQcmVzc2VkKCkge1xuICAgKiAgICAvLyBlbnN1cmUgYXVkaW8gaXMgZW5hYmxlZFxuICAgKiAgICB1c2VyU3RhcnRBdWRpbygpO1xuICAgKlxuICAgKiAgICAvLyBtYWtlIHN1cmUgdXNlciBlbmFibGVkIHRoZSBtaWNcbiAgICogICAgaWYgKHN0YXRlID09PSAwICYmIG1pYy5lbmFibGVkKSB7XG4gICAqXG4gICAqICAgICAgLy8gcmVjb3JkIHRvIG91ciBwNS5Tb3VuZEZpbGVcbiAgICogICAgICByZWNvcmRlci5yZWNvcmQoc291bmRGaWxlKTtcbiAgICpcbiAgICogICAgICBiYWNrZ3JvdW5kKDI1NSwwLDApO1xuICAgKiAgICAgIHRleHQoJ1JlY29yZGluZyEnLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqICAgICAgc3RhdGUrKztcbiAgICogICAgfVxuICAgKiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgKiAgICAgIGJhY2tncm91bmQoMCwyNTUsMCk7XG4gICAqXG4gICAqICAgICAgLy8gc3RvcCByZWNvcmRlciBhbmRcbiAgICogICAgICAvLyBzZW5kIHJlc3VsdCB0byBzb3VuZEZpbGVcbiAgICogICAgICByZWNvcmRlci5zdG9wKCk7XG4gICAqXG4gICAqICAgICAgdGV4dCgnRG9uZSEgVGFwIHRvIHBsYXkgYW5kIGRvd25sb2FkJywgd2lkdGgvMiwgaGVpZ2h0LzIsIHdpZHRoIC0gMjApO1xuICAgKiAgICAgIHN0YXRlKys7XG4gICAqICAgIH1cbiAgICpcbiAgICogICAgZWxzZSBpZiAoc3RhdGUgPT09IDIpIHtcbiAgICogICAgICBzb3VuZEZpbGUucGxheSgpOyAvLyBwbGF5IHRoZSByZXN1bHQhXG4gICAqICAgICAgc2F2ZShzb3VuZEZpbGUsICdteVNvdW5kLndhdicpO1xuICAgKiAgICAgIHN0YXRlKys7XG4gICAqICAgIH1cbiAgICogIH1cbiAgICogIDwvZGl2PjwvY29kZT5cbiAgICovXG5cbiAgcDUuU291bmRSZWNvcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlucHV0ID0gYWMuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMub3V0cHV0ID0gYWMuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuX2lucHV0Q2hhbm5lbHMgPSAyO1xuICAgIHRoaXMuX291dHB1dENoYW5uZWxzID0gMjsgXG5cbiAgICB2YXIgd29ya2xldEJ1ZmZlclNpemUgPSBzYWZlQnVmZmVyU2l6ZSgxMDI0KTtcbiAgICB0aGlzLl93b3JrbGV0Tm9kZSA9IG5ldyBBdWRpb1dvcmtsZXROb2RlKGFjLCBwcm9jZXNzb3JOYW1lcy5yZWNvcmRlclByb2Nlc3Nvciwge1xuICAgICAgb3V0cHV0Q2hhbm5lbENvdW50OiBbdGhpcy5fb3V0cHV0Q2hhbm5lbHNdLFxuICAgICAgcHJvY2Vzc29yT3B0aW9uczoge1xuICAgICAgICBudW1JbnB1dENoYW5uZWxzOiB0aGlzLl9pbnB1dENoYW5uZWxzLFxuICAgICAgICBidWZmZXJTaXplOiB3b3JrbGV0QnVmZmVyU2l6ZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fd29ya2xldE5vZGUucG9ydC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhLm5hbWUgPT09ICdidWZmZXJzJykge1xuICAgICAgICB2YXIgYnVmZmVycyA9IFtuZXcgRmxvYXQzMkFycmF5KGV2ZW50LmRhdGEubGVmdEJ1ZmZlciksIG5ldyBGbG9hdDMyQXJyYXkoZXZlbnQuZGF0YS5yaWdodEJ1ZmZlcildO1xuXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKGJ1ZmZlcnMpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcbiAgICAvKipcbiAgICAgKiAgY2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSByZWNvcmRpbmcgaXMgb3ZlclxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqICBAdHlwZSBGdW5jdGlvbihGbG9hdDMyQXJyYXkpXG4gICAgICovXG5cblxuICAgIHRoaXMuX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307IFxuXG5cbiAgICB0aGlzLl93b3JrbGV0Tm9kZS5jb25uZWN0KHA1LnNvdW5kT3V0Ll9zaWxlbnROb2RlKTtcblxuICAgIHRoaXMuc2V0SW5wdXQoKTsgXG5cbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqICBDb25uZWN0IGEgc3BlY2lmaWMgZGV2aWNlIHRvIHRoZSBwNS5Tb3VuZFJlY29yZGVyLlxuICAgKiAgSWYgbm8gcGFyYW1ldGVyIGlzIGdpdmVuLCBwNS5Tb3VuZFJlY29yZXIgd2lsbCByZWNvcmRcbiAgICogIGFsbCBhdWRpYmxlIHA1LnNvdW5kIGZyb20geW91ciBza2V0Y2guXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRJbnB1dFxuICAgKiAgQGZvciBwNS5Tb3VuZFJlY29yZGVyXG4gICAqICBAcGFyYW0ge09iamVjdH0gW3VuaXRdIHA1LnNvdW5kIG9iamVjdCBvciBhIHdlYiBhdWRpbyB1bml0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgb3V0cHV0cyBzb3VuZFxuICAgKi9cblxuXG4gIHA1LlNvdW5kUmVjb3JkZXIucHJvdG90eXBlLnNldElucHV0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmlucHV0ID0gbnVsbDtcbiAgICB0aGlzLmlucHV0ID0gYWMuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl93b3JrbGV0Tm9kZSk7XG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMub3V0cHV0KTtcblxuICAgIGlmICh1bml0KSB7XG4gICAgICB1bml0LmNvbm5lY3QodGhpcy5pbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHA1LnNvdW5kT3V0Lm91dHB1dC5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTdGFydCByZWNvcmRpbmcuIFRvIGFjY2VzcyB0aGUgcmVjb3JkaW5nLCBwcm92aWRlXG4gICAqICBhIHA1LlNvdW5kRmlsZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLiBUaGUgcDUuU291bmRSZWNvcmRlclxuICAgKiAgd2lsbCBzZW5kIGl0cyByZWNvcmRpbmcgdG8gdGhhdCBwNS5Tb3VuZEZpbGUgZm9yIHBsYXliYWNrIG9uY2VcbiAgICogIHJlY29yZGluZyBpcyBjb21wbGV0ZS4gT3B0aW9uYWwgcGFyYW1ldGVycyBpbmNsdWRlIGR1cmF0aW9uXG4gICAqICAoaW4gc2Vjb25kcykgb2YgdGhlIHJlY29yZGluZywgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdFxuICAgKiAgd2lsbCBiZSBjYWxsZWQgb25jZSB0aGUgY29tcGxldGUgcmVjb3JkaW5nIGhhcyBiZWVuXG4gICAqICB0cmFuc2ZlcmVkIHRvIHRoZSBwNS5Tb3VuZEZpbGUuXG4gICAqXG4gICAqICBAbWV0aG9kICByZWNvcmRcbiAgICogIEBmb3IgcDUuU291bmRSZWNvcmRlclxuICAgKiAgQHBhcmFtICB7cDUuU291bmRGaWxlfSAgIHNvdW5kRmlsZSAgICBwNS5Tb3VuZEZpbGVcbiAgICogIEBwYXJhbSAge051bWJlcn0gICBbZHVyYXRpb25dIFRpbWUgKGluIHNlY29uZHMpXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkIG9uY2UgdGhlIHJlY29yZGluZyBjb21wbGV0ZXNcbiAgICovXG5cblxuICBwNS5Tb3VuZFJlY29yZGVyLnByb3RvdHlwZS5yZWNvcmQgPSBmdW5jdGlvbiAoc0ZpbGUsIGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3dvcmtsZXROb2RlLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgbmFtZTogJ3N0YXJ0JyxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHNGaWxlICYmIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9jYWxsYmFjayA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgc0ZpbGUuc2V0QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc0ZpbGUpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBzRmlsZS5zZXRCdWZmZXIoYnVmZmVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFN0b3AgdGhlIHJlY29yZGluZy4gT25jZSB0aGUgcmVjb3JkaW5nIGlzIHN0b3BwZWQsXG4gICAqICB0aGUgcmVzdWx0cyB3aWxsIGJlIHNlbnQgdG8gdGhlIHA1LlNvdW5kRmlsZSB0aGF0XG4gICAqICB3YXMgZ2l2ZW4gb24gLnJlY29yZCgpLCBhbmQgaWYgYSBjYWxsYmFjayBmdW5jdGlvblxuICAgKiAgd2FzIHByb3ZpZGVkIG9uIHJlY29yZCwgdGhhdCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZC5cbiAgICpcbiAgICogIEBtZXRob2QgIHN0b3BcbiAgICogIEBmb3IgcDUuU291bmRSZWNvcmRlclxuICAgKi9cblxuXG4gIHA1LlNvdW5kUmVjb3JkZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fd29ya2xldE5vZGUucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICBuYW1lOiAnc3RvcCdcbiAgICB9KTtcbiAgfTtcblxuICBwNS5Tb3VuZFJlY29yZGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGlmICh0aGlzLmlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLmlucHV0ID0gbnVsbDtcbiAgICB0aGlzLl93b3JrbGV0Tm9kZSA9IG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBTYXZlIGEgcDUuU291bmRGaWxlIGFzIGEgLndhdiBmaWxlLiBUaGUgYnJvd3NlciB3aWxsIHByb21wdCB0aGUgdXNlclxuICAgKiB0byBkb3dubG9hZCB0aGUgZmlsZSB0byB0aGVpciBkZXZpY2UuXG4gICAqIEZvciB1cGxvYWRpbmcgYXVkaW8gdG8gYSBzZXJ2ZXIsIHVzZVxuICAgKiA8YSBocmVmPVwiL2RvY3MvcmVmZXJlbmNlLyMvcDUuU291bmRGaWxlL3NhdmVCbG9iXCI+YHA1LlNvdW5kRmlsZS5zYXZlQmxvYmA8L2E+LlxuICAgKlxuICAgKiAgQGZvciBwNVxuICAgKiAgQG1ldGhvZCBzYXZlU291bmRcbiAgICogIEBwYXJhbSAge3A1LlNvdW5kRmlsZX0gc291bmRGaWxlIHA1LlNvdW5kRmlsZSB0aGF0IHlvdSB3aXNoIHRvIHNhdmVcbiAgICogIEBwYXJhbSAge1N0cmluZ30gZmlsZU5hbWUgICAgICBuYW1lIG9mIHRoZSByZXN1bHRpbmcgLndhdiBmaWxlLlxuICAgKi9cblxuXG4gIHA1LnByb3RvdHlwZS5zYXZlU291bmQgPSBmdW5jdGlvbiAoc291bmRGaWxlLCBmaWxlTmFtZSkge1xuICAgIHZhciBkYXRhVmlldyA9IGNvbnZlcnRUb1dhdihzb3VuZEZpbGUuYnVmZmVyKTtcbiAgICBwNS5wcm90b3R5cGUud3JpdGVGaWxlKFtkYXRhVmlld10sIGZpbGVOYW1lLCAnd2F2Jyk7XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogIDxwPlBlYWtEZXRlY3Qgd29ya3MgaW4gY29uanVuY3Rpb24gd2l0aCBwNS5GRlQgdG9cbiAgICogIGxvb2sgZm9yIG9uc2V0cyBpbiBzb21lIG9yIGFsbCBvZiB0aGUgZnJlcXVlbmN5IHNwZWN0cnVtLlxuICAgKiAgPC9wPlxuICAgKiAgPHA+XG4gICAqICBUbyB1c2UgcDUuUGVha0RldGVjdCwgY2FsbCA8Y29kZT51cGRhdGU8L2NvZGU+IGluIHRoZSBkcmF3IGxvb3BcbiAgICogIGFuZCBwYXNzIGluIGEgcDUuRkZUIG9iamVjdC5cbiAgICogIDwvcD5cbiAgICogIDxwPlxuICAgKiAgWW91IGNhbiBsaXN0ZW4gZm9yIGEgc3BlY2lmaWMgcGFydCBvZiB0aGUgZnJlcXVlbmN5IHNwZWN0cnVtIGJ5XG4gICAqICBzZXR0aW5nIHRoZSByYW5nZSBiZXR3ZWVuIDxjb2RlPmZyZXExPC9jb2RlPiBhbmQgPGNvZGU+ZnJlcTI8L2NvZGU+LlxuICAgKiAgPC9wPlxuICAgKlxuICAgKiAgPHA+PGNvZGU+dGhyZXNob2xkPC9jb2RlPiBpcyB0aGUgdGhyZXNob2xkIGZvciBkZXRlY3RpbmcgYSBwZWFrLFxuICAgKiAgc2NhbGVkIGJldHdlZW4gMCBhbmQgMS4gSXQgaXMgbG9nYXJpdGhtaWMsIHNvIDAuMSBpcyBoYWxmIGFzIGxvdWRcbiAgICogIGFzIDEuMC48L3A+XG4gICAqXG4gICAqICA8cD5cbiAgICogIFRoZSB1cGRhdGUgbWV0aG9kIGlzIG1lYW50IHRvIGJlIHJ1biBpbiB0aGUgZHJhdyBsb29wLCBhbmRcbiAgICogIDxiPmZyYW1lczwvYj4gZGV0ZXJtaW5lcyBob3cgbWFueSBsb29wcyBtdXN0IHBhc3MgYmVmb3JlXG4gICAqICBhbm90aGVyIHBlYWsgY2FuIGJlIGRldGVjdGVkLlxuICAgKiAgRm9yIGV4YW1wbGUsIGlmIHRoZSBmcmFtZVJhdGUoKSA9IDYwLCB5b3UgY291bGQgZGV0ZWN0IHRoZSBiZWF0IG9mIGFcbiAgICogIDEyMCBiZWF0LXBlci1taW51dGUgc29uZyB3aXRoIHRoaXMgZXF1YXRpb246XG4gICAqICA8Y29kZT4gZnJhbWVzUGVyUGVhayA9IDYwIC8gKGVzdGltYXRlZEJQTSAvIDYwICk7PC9jb2RlPlxuICAgKiAgPC9wPlxuICAgKlxuICAgKiAgPHA+XG4gICAqICBCYXNlZCBvbiBleGFtcGxlIGNvbnRyaWJ0dWVkIGJ5IEBiMnJlbmdlciwgYW5kIGEgc2ltcGxlIGJlYXQgZGV0ZWN0aW9uXG4gICAqICBleHBsYW5hdGlvbiBieSA8YVxuICAgKiAgaHJlZj1cImh0dHA6Ly93d3cuYWlydGlnaHRpbnRlcmFjdGl2ZS5jb20vMjAxMy8xMC9tYWtpbmctYXVkaW8tcmVhY3RpdmUtdmlzdWFscy9cIlxuICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmVsaXggVHVybmVyPC9hPi5cbiAgICogIDwvcD5cbiAgICpcbiAgICogIEBjbGFzcyAgcDUuUGVha0RldGVjdFxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyZXExXSAgICAgbG93RnJlcXVlbmN5IC0gZGVmYXVsdHMgdG8gMjBIelxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxMl0gICAgIGhpZ2hGcmVxdWVuY3kgLSBkZWZhdWx0cyB0byAyMDAwMCBIelxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt0aHJlc2hvbGRdIFRocmVzaG9sZCBmb3IgZGV0ZWN0aW5nIGEgYmVhdCBiZXR3ZWVuIDAgYW5kIDFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkIGxvZ2FyaXRobWljYWxseSB3aGVyZSAwLjEgaXMgMS8yIHRoZSBsb3VkbmVzc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiAxLjAuIERlZmF1bHRzIHRvIDAuMzUuXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyYW1lc1BlclBlYWtdICAgICBEZWZhdWx0cyB0byAyMC5cbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKlxuICAgKiAgdmFyIGNudiwgc291bmRGaWxlLCBmZnQsIHBlYWtEZXRlY3Q7XG4gICAqICB2YXIgZWxsaXBzZVdpZHRoID0gMTA7XG4gICAqXG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBzb3VuZEZpbGUgPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Lm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMCk7XG4gICAqICAgIG5vU3Ryb2tlKCk7XG4gICAqICAgIGZpbGwoMjU1KTtcbiAgICogICAgdGV4dEFsaWduKENFTlRFUik7XG4gICAqXG4gICAqICAgIC8vIHA1LlBlYWtEZXRlY3QgcmVxdWlyZXMgYSBwNS5GRlRcbiAgICogICAgZmZ0ID0gbmV3IHA1LkZGVCgpO1xuICAgKiAgICBwZWFrRGV0ZWN0ID0gbmV3IHA1LlBlYWtEZXRlY3QoKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMCk7XG4gICAqICAgIHRleHQoJ2NsaWNrIHRvIHBsYXkvcGF1c2UnLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqXG4gICAqICAgIC8vIHBlYWtEZXRlY3QgYWNjZXB0cyBhbiBmZnQgcG9zdC1hbmFseXNpc1xuICAgKiAgICBmZnQuYW5hbHl6ZSgpO1xuICAgKiAgICBwZWFrRGV0ZWN0LnVwZGF0ZShmZnQpO1xuICAgKlxuICAgKiAgICBpZiAoIHBlYWtEZXRlY3QuaXNEZXRlY3RlZCApIHtcbiAgICogICAgICBlbGxpcHNlV2lkdGggPSA1MDtcbiAgICogICAgfSBlbHNlIHtcbiAgICogICAgICBlbGxpcHNlV2lkdGggKj0gMC45NTtcbiAgICogICAgfVxuICAgKlxuICAgKiAgICBlbGxpcHNlKHdpZHRoLzIsIGhlaWdodC8yLCBlbGxpcHNlV2lkdGgsIGVsbGlwc2VXaWR0aCk7XG4gICAqICB9XG4gICAqXG4gICAqICAvLyB0b2dnbGUgcGxheS9zdG9wIHdoZW4gY2FudmFzIGlzIGNsaWNrZWRcbiAgICogIGZ1bmN0aW9uIG1vdXNlQ2xpY2tlZCgpIHtcbiAgICogICAgaWYgKG1vdXNlWCA+IDAgJiYgbW91c2VYIDwgd2lkdGggJiYgbW91c2VZID4gMCAmJiBtb3VzZVkgPCBoZWlnaHQpIHtcbiAgICogICAgICBpZiAoc291bmRGaWxlLmlzUGxheWluZygpICkge1xuICAgKiAgICAgICAgc291bmRGaWxlLnN0b3AoKTtcbiAgICogICAgICB9IGVsc2Uge1xuICAgKiAgICAgICAgc291bmRGaWxlLnBsYXkoKTtcbiAgICogICAgICB9XG4gICAqICAgIH1cbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG4gIHA1LlBlYWtEZXRlY3QgPSBmdW5jdGlvbiAoZnJlcTEsIGZyZXEyLCB0aHJlc2hvbGQsIF9mcmFtZXNQZXJQZWFrKSB7XG4gICAgdGhpcy5mcmFtZXNQZXJQZWFrID0gX2ZyYW1lc1BlclBlYWsgfHwgMjA7XG4gICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RQZWFrID0gMDtcbiAgICB0aGlzLmRlY2F5UmF0ZSA9IDAuOTU7XG4gICAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgMC4zNTtcbiAgICB0aGlzLmN1dG9mZiA9IDA7IFxuXG4gICAgdGhpcy5jdXRvZmZNdWx0ID0gMS41O1xuICAgIHRoaXMuZW5lcmd5ID0gMDtcbiAgICB0aGlzLnBlbmVyZ3kgPSAwOyBcblxuICAgIHRoaXMuY3VycmVudFZhbHVlID0gMDtcbiAgICAvKipcbiAgICAgKiAgaXNEZXRlY3RlZCBpcyBzZXQgdG8gdHJ1ZSB3aGVuIGEgcGVhayBpcyBkZXRlY3RlZC5cbiAgICAgKlxuICAgICAqICBAYXR0cmlidXRlIGlzRGV0ZWN0ZWQge0Jvb2xlYW59XG4gICAgICogIEBkZWZhdWx0ICBmYWxzZVxuICAgICAqL1xuXG4gICAgdGhpcy5pc0RldGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5mMSA9IGZyZXExIHx8IDQwO1xuICAgIHRoaXMuZjIgPSBmcmVxMiB8fCAyMDAwMDsgXG5cbiAgICB0aGlzLl9vblBlYWsgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfTtcbiAgLyoqXG4gICAqICBUaGUgdXBkYXRlIG1ldGhvZCBpcyBydW4gaW4gdGhlIGRyYXcgbG9vcC5cbiAgICpcbiAgICogIEFjY2VwdHMgYW4gRkZUIG9iamVjdC4gWW91IG11c3QgY2FsbCAuYW5hbHl6ZSgpXG4gICAqICBvbiB0aGUgRkZUIG9iamVjdCBwcmlvciB0byB1cGRhdGluZyB0aGUgcGVha0RldGVjdFxuICAgKiAgYmVjYXVzZSBpdCByZWxpZXMgb24gYSBjb21wbGV0ZWQgRkZUIGFuYWx5c2lzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgdXBkYXRlXG4gICAqICBAcGFyYW0gIHtwNS5GRlR9IGZmdE9iamVjdCBBIHA1LkZGVCBvYmplY3RcbiAgICovXG5cblxuICBwNS5QZWFrRGV0ZWN0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZmZ0T2JqZWN0KSB7XG4gICAgdmFyIG5yZyA9IHRoaXMuZW5lcmd5ID0gZmZ0T2JqZWN0LmdldEVuZXJneSh0aGlzLmYxLCB0aGlzLmYyKSAvIDI1NTtcblxuICAgIGlmIChucmcgPiB0aGlzLmN1dG9mZiAmJiBucmcgPiB0aGlzLnRocmVzaG9sZCAmJiBucmcgLSB0aGlzLnBlbmVyZ3kgPiAwKSB7XG4gICAgICB0aGlzLl9vblBlYWsoKTtcblxuICAgICAgdGhpcy5pc0RldGVjdGVkID0gdHJ1ZTsgXG5cbiAgICAgIHRoaXMuY3V0b2ZmID0gbnJnICogdGhpcy5jdXRvZmZNdWx0O1xuICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RQZWFrID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0RldGVjdGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmZyYW1lc1NpbmNlTGFzdFBlYWsgPD0gdGhpcy5mcmFtZXNQZXJQZWFrKSB7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0UGVhaysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXRvZmYgKj0gdGhpcy5kZWNheVJhdGU7XG4gICAgICAgIHRoaXMuY3V0b2ZmID0gTWF0aC5tYXgodGhpcy5jdXRvZmYsIHRoaXMudGhyZXNob2xkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5yZztcbiAgICB0aGlzLnBlbmVyZ3kgPSBucmc7XG4gIH07XG4gIC8qKlxuICAgKiAgb25QZWFrIGFjY2VwdHMgdHdvIGFyZ3VtZW50czogYSBmdW5jdGlvbiB0byBjYWxsIHdoZW5cbiAgICogIGEgcGVhayBpcyBkZXRlY3RlZC4gVGhlIHZhbHVlIG9mIHRoZSBwZWFrLFxuICAgKiAgYmV0d2VlbiAwLjAgYW5kIDEuMCwgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogIEBtZXRob2QgIG9uUGVha1xuICAgKiAgQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIE5hbWUgb2YgYSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjYWxsZWQgd2hlbiBhIHBlYWsgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZC5cbiAgICogIEBwYXJhbSAge09iamVjdH0gICBbdmFsXSAgICBPcHRpb25hbCB2YWx1ZSB0byBwYXNzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50byB0aGUgZnVuY3Rpb24gd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgcGVhayBpcyBkZXRlY3RlZC5cbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgdmFyIGNudiwgc291bmRGaWxlLCBmZnQsIHBlYWtEZXRlY3Q7XG4gICAqICB2YXIgZWxsaXBzZVdpZHRoID0gMDtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIHNvdW5kRmlsZSA9IGxvYWRTb3VuZCgnYXNzZXRzL2JlYXQubXAzJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwxMDApO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICpcbiAgICogICAgZmZ0ID0gbmV3IHA1LkZGVCgpO1xuICAgKiAgICBwZWFrRGV0ZWN0ID0gbmV3IHA1LlBlYWtEZXRlY3QoKTtcbiAgICpcbiAgICogICAgc2V0dXBTb3VuZCgpO1xuICAgKlxuICAgKiAgICAvLyB3aGVuIGEgYmVhdCBpcyBkZXRlY3RlZCwgY2FsbCB0cmlnZ2VyQmVhdCgpXG4gICAqICAgIHBlYWtEZXRlY3Qub25QZWFrKHRyaWdnZXJCZWF0KTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMCk7XG4gICAqICAgIGZpbGwoMjU1KTtcbiAgICogICAgdGV4dCgnY2xpY2sgdG8gcGxheScsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICpcbiAgICogICAgZmZ0LmFuYWx5emUoKTtcbiAgICogICAgcGVha0RldGVjdC51cGRhdGUoZmZ0KTtcbiAgICpcbiAgICogICAgZWxsaXBzZVdpZHRoICo9IDAuOTU7XG4gICAqICAgIGVsbGlwc2Uod2lkdGgvMiwgaGVpZ2h0LzIsIGVsbGlwc2VXaWR0aCwgZWxsaXBzZVdpZHRoKTtcbiAgICogIH1cbiAgICpcbiAgICogIC8vIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHBlYWtEZXRlY3Qub25QZWFrXG4gICAqICBmdW5jdGlvbiB0cmlnZ2VyQmVhdCgpIHtcbiAgICogICAgZWxsaXBzZVdpZHRoID0gNTA7XG4gICAqICB9XG4gICAqXG4gICAqICAvLyBtb3VzZWNsaWNrIHN0YXJ0cy9zdG9wcyBzb3VuZFxuICAgKiAgZnVuY3Rpb24gc2V0dXBTb3VuZCgpIHtcbiAgICogICAgY252Lm1vdXNlQ2xpY2tlZCggZnVuY3Rpb24oKSB7XG4gICAqICAgICAgaWYgKHNvdW5kRmlsZS5pc1BsYXlpbmcoKSApIHtcbiAgICogICAgICAgIHNvdW5kRmlsZS5zdG9wKCk7XG4gICAqICAgICAgfSBlbHNlIHtcbiAgICogICAgICAgIHNvdW5kRmlsZS5wbGF5KCk7XG4gICAqICAgICAgfVxuICAgKiAgICB9KTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5QZWFrRGV0ZWN0LnByb3RvdHlwZS5vblBlYWsgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHZhbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHNlbGYuX29uUGVhayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKHNlbGYuZW5lcmd5LCB2YWwpO1xuICAgIH07XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICAvKipcbiAgICogIEEgZ2FpbiBub2RlIGlzIHVzZWZ1bGwgdG8gc2V0IHRoZSByZWxhdGl2ZSB2b2x1bWUgb2Ygc291bmQuXG4gICAqICBJdCdzIHR5cGljYWxseSB1c2VkIHRvIGJ1aWxkIG1peGVycy5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5HYWluXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKlxuICAgKiAgLy8gbG9hZCB0d28gc291bmRmaWxlIGFuZCBjcm9zc2ZhZGUgYmVldHdlZW4gdGhlbVxuICAgKiAgbGV0IHNvdW5kMSxzb3VuZDI7XG4gICAqICBsZXQgc291bmQxR2Fpbiwgc291bmQyR2FpbiwgbWFzdGVyR2FpbjtcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKXtcbiAgICogICAgc291bmRGb3JtYXRzKCdvZ2cnLCAnbXAzJyk7XG4gICAqICAgIHNvdW5kMSA9IGxvYWRTb3VuZCgnYXNzZXRzL0RhbXNjcmF5Xy1fRGFuY2luZ19UaWdlcl8wMScpO1xuICAgKiAgICBzb3VuZDIgPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Jyk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoc3RhcnRTb3VuZCk7XG4gICAqICAgIC8vIGNyZWF0ZSBhICdtYXN0ZXInIGdhaW4gdG8gd2hpY2ggd2Ugd2lsbCBjb25uZWN0IGJvdGggc291bmRmaWxlc1xuICAgKiAgICBtYXN0ZXJHYWluID0gbmV3IHA1LkdhaW4oKTtcbiAgICogICAgbWFzdGVyR2Fpbi5jb25uZWN0KCk7XG4gICAqICAgIHNvdW5kMS5kaXNjb25uZWN0KCk7IC8vIGRpY29ubmVjdCBmcm9tIHA1IG91dHB1dFxuICAgKiAgICBzb3VuZDFHYWluID0gbmV3IHA1LkdhaW4oKTsgLy8gc2V0dXAgYSBnYWluIG5vZGVcbiAgICogICAgc291bmQxR2Fpbi5zZXRJbnB1dChzb3VuZDEpOyAvLyBjb25uZWN0IHRoZSBmaXJzdCBzb3VuZCB0byBpdHMgaW5wdXRcbiAgICogICAgc291bmQxR2Fpbi5jb25uZWN0KG1hc3RlckdhaW4pOyAvLyBjb25uZWN0IGl0cyBvdXRwdXQgdG8gdGhlICdtYXN0ZXInXG4gICAqICAgIHNvdW5kMi5kaXNjb25uZWN0KCk7XG4gICAqICAgIHNvdW5kMkdhaW4gPSBuZXcgcDUuR2FpbigpO1xuICAgKiAgICBzb3VuZDJHYWluLnNldElucHV0KHNvdW5kMik7XG4gICAqICAgIHNvdW5kMkdhaW4uY29ubmVjdChtYXN0ZXJHYWluKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIHN0YXJ0U291bmQoKSB7XG4gICAqICAgIHNvdW5kMS5sb29wKCk7XG4gICAqICAgIHNvdW5kMi5sb29wKCk7XG4gICAqICAgIGxvb3AoKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIG1vdXNlUmVsZWFzZWQoKSB7XG4gICAqICAgIHNvdW5kMS5zdG9wKCk7XG4gICAqICAgIHNvdW5kMi5zdG9wKCk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBkcmF3KCl7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dEFsaWduKENFTlRFUik7XG4gICAqICAgIHRleHRTaXplKDExKTtcbiAgICogICAgZmlsbCgwKTtcbiAgICogICAgaWYgKCFzb3VuZDEuaXNQbGF5aW5nKCkpIHtcbiAgICogICAgICB0ZXh0KCd0YXAgYW5kIGRyYWcgdG8gcGxheScsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICogICAgICByZXR1cm47XG4gICAqICAgIH1cbiAgICogICAgLy8gbWFwIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSB0byB2YWx1ZXMgdXNlYWJsZSBmb3Igdm9sdW1lICAgICogIGNvbnRyb2wgb2Ygc291bmQxXG4gICAqICAgIHZhciBzb3VuZDFWb2x1bWUgPSBjb25zdHJhaW4obWFwKG1vdXNlWCx3aWR0aCwwLDAsMSksIDAsIDEpO1xuICAgKiAgICB2YXIgc291bmQyVm9sdW1lID0gMS1zb3VuZDFWb2x1bWU7XG4gICAqICAgIHNvdW5kMUdhaW4uYW1wKHNvdW5kMVZvbHVtZSk7XG4gICAqICAgIHNvdW5kMkdhaW4uYW1wKHNvdW5kMlZvbHVtZSk7XG4gICAqICAgIC8vIG1hcCB0aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG1vdXNlIHRvIHZhbHVlcyB1c2VhYmxlIGZvciAnbWFzdGVyICAgICogIHZvbHVtZSBjb250cm9sJ1xuICAgKiAgICB2YXIgbWFzdGVyVm9sdW1lID0gY29uc3RyYWluKG1hcChtb3VzZVksaGVpZ2h0LDAsMCwxKSwgMCwgMSk7XG4gICAqICAgIG1hc3RlckdhaW4uYW1wKG1hc3RlclZvbHVtZSk7XG4gICAqICAgIHRleHQoJ21hc3RlcicsIHdpZHRoLzIsIGhlaWdodCAtIG1hc3RlclZvbHVtZSAqIGhlaWdodCAqIDAuOSlcbiAgICogICAgZmlsbCgyNTUsIDAsIDI1NSk7XG4gICAqICAgIHRleHRBbGlnbihMRUZUKTtcbiAgICogICAgdGV4dCgnc291bmQxJywgNSwgaGVpZ2h0IC0gc291bmQxVm9sdW1lICogaGVpZ2h0ICogMC45KTtcbiAgICogICAgdGV4dEFsaWduKFJJR0hUKTtcbiAgICogICAgdGV4dCgnc291bmQyJywgd2lkdGggLSA1LCBoZWlnaHQgLSBzb3VuZDJWb2x1bWUgKiBoZWlnaHQgKiAwLjkpO1xuICAgKiAgfVxuICAgKjwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5HYWluID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWMgPSBwNXNvdW5kLmF1ZGlvY29udGV4dDtcbiAgICB0aGlzLmlucHV0ID0gdGhpcy5hYy5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLmFjLmNyZWF0ZUdhaW4oKTsgXG5cbiAgICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSAwLjU7XG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMub3V0cHV0KTsgXG5cbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqICBDb25uZWN0IGEgc291cmNlIHRvIHRoZSBnYWluIG5vZGUuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRJbnB1dFxuICAgKiAgQGZvciBwNS5HYWluXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHNyYyAgICAgcDUuc291bmQgLyBXZWIgQXVkaW8gb2JqZWN0IHdpdGggYSBzb3VuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAgICovXG5cblxuICBwNS5HYWluLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICBzcmMuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgfTtcbiAgLyoqXG4gICAqICBTZW5kIG91dHB1dCB0byBhIHA1LnNvdW5kIG9yIHdlYiBhdWRpbyBvYmplY3RcbiAgICpcbiAgICogIEBtZXRob2QgIGNvbm5lY3RcbiAgICogIEBmb3IgcDUuR2FpblxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSB1bml0XG4gICAqL1xuXG5cbiAgcDUuR2Fpbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdmFyIHUgPSB1bml0IHx8IHA1LnNvdW5kT3V0LmlucHV0O1xuICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodS5pbnB1dCA/IHUuaW5wdXQgOiB1KTtcbiAgfTtcbiAgLyoqXG4gICAqICBEaXNjb25uZWN0IGFsbCBvdXRwdXQuXG4gICAqXG4gICAqICBAbWV0aG9kIGRpc2Nvbm5lY3RcbiAgICogIEBmb3IgcDUuR2FpblxuICAgKi9cblxuXG4gIHA1LkdhaW4ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgb3V0cHV0IGxldmVsIG9mIHRoZSBnYWluIG5vZGUuXG4gICAqXG4gICAqICBAbWV0aG9kICBhbXBcbiAgICogIEBmb3IgcDUuR2FpblxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSB2b2x1bWUgYW1wbGl0dWRlIGJldHdlZW4gMCBhbmQgMS4wXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtyYW1wVGltZV0gY3JlYXRlIGEgZmFkZSB0aGF0IGxhc3RzIHJhbXBUaW1lXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gc2NoZWR1bGUgdGhpcyBldmVudCB0byBoYXBwZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBwNS5HYWluLnByb3RvdHlwZS5hbXAgPSBmdW5jdGlvbiAodm9sLCByYW1wVGltZSwgdEZyb21Ob3cpIHtcbiAgICB2YXIgcmFtcFRpbWUgPSByYW1wVGltZSB8fCAwO1xuICAgIHZhciB0RnJvbU5vdyA9IHRGcm9tTm93IHx8IDA7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciBjdXJyZW50Vm9sID0gdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZTtcbiAgICB0aGlzLm91dHB1dC5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhub3cpO1xuICAgIHRoaXMub3V0cHV0LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoY3VycmVudFZvbCwgbm93ICsgdEZyb21Ob3cpO1xuICAgIHRoaXMub3V0cHV0LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodm9sLCBub3cgKyB0RnJvbU5vdyArIHJhbXBUaW1lKTtcbiAgfTtcblxuICBwNS5HYWluLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5vdXRwdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW5wdXQpIHtcbiAgICAgIHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMuaW5wdXQ7XG4gICAgfVxuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBFZmZlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cbiAgZnVuY3Rpb24gbWFrZURpc3RvcnRpb25DdXJ2ZShhbW91bnQpIHtcbiAgICB2YXIgayA9IHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInID8gYW1vdW50IDogNTA7XG4gICAgdmFyIG51bVNhbXBsZXMgPSA0NDEwMDtcbiAgICB2YXIgY3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KG51bVNhbXBsZXMpO1xuICAgIHZhciBkZWcgPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgeDtcblxuICAgIGZvciAoOyBpIDwgbnVtU2FtcGxlczsgKytpKSB7XG4gICAgICB4ID0gaSAqIDIgLyBudW1TYW1wbGVzIC0gMTtcbiAgICAgIGN1cnZlW2ldID0gKDMgKyBrKSAqIHggKiAyMCAqIGRlZyAvIChNYXRoLlBJICsgayAqIE1hdGguYWJzKHgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VydmU7XG4gIH1cbiAgLyoqXG4gICAqIEEgRGlzdG9ydGlvbiBlZmZlY3QgY3JlYXRlZCB3aXRoIGEgV2F2ZXNoYXBlciBOb2RlLFxuICAgKiB3aXRoIGFuIGFwcHJvYWNoIGFkYXB0ZWQgZnJvbVxuICAgKiBbS2V2aW4gRW5uaXNdKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjIzMTI4NDEvd2F2ZXNoYXBlci1ub2RlLWluLXdlYmF1ZGlvLWhvdy10by1lbXVsYXRlLWRpc3RvcnRpb24pXG4gICAqXG4gICAqIFRoaXMgY2xhc3MgZXh0ZW5kcyA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0XCI+cDUuRWZmZWN0PC9hPi5cbiAgICogTWV0aG9kcyA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2FtcFwiPmFtcCgpPC9hPiwgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9jaGFpblwiPmNoYWluKCk8L2E+LFxuICAgKiA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2RyeXdldFwiPmRyeXdldCgpPC9hPiwgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9jb25uZWN0XCI+Y29ubmVjdCgpPC9hPiwgYW5kXG4gICAqIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZGlzY29ubmVjdFwiPmRpc2Nvbm5lY3QoKTwvYT4gYXJlIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQGNsYXNzIHA1LkRpc3RvcnRpb25cbiAgICogQGV4dGVuZHMgcDUuRWZmZWN0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Ftb3VudD0wLjI1XSBVbmJvdW5kZWQgZGlzdG9ydGlvbiBhbW91bnQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3JtYWwgdmFsdWVzIHJhbmdlIGZyb20gMC0xLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW292ZXJzYW1wbGU9J25vbmUnXSAnbm9uZScsICcyeCcsIG9yICc0eCcuXG4gICAqXG4gICAqL1xuXG5cbiAgcDUuRGlzdG9ydGlvbiA9IGZ1bmN0aW9uIChhbW91bnQsIG92ZXJzYW1wbGUpIHtcbiAgICBFZmZlY3QuY2FsbCh0aGlzKTtcblxuICAgIGlmICh0eXBlb2YgYW1vdW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYW1vdW50ID0gMC4yNTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYW1vdW50IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG92ZXJzYW1wbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvdmVyc2FtcGxlID0gJzJ4JztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG92ZXJzYW1wbGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJzYW1wbGUgbXVzdCBiZSBhIFN0cmluZycpO1xuICAgIH1cblxuICAgIHZhciBjdXJ2ZUFtb3VudCA9IHA1LnByb3RvdHlwZS5tYXAoYW1vdW50LCAwLjAsIDEuMCwgMCwgMjAwMCk7XG4gICAgLyoqXG4gICAgICogIFRoZSBwNS5EaXN0b3J0aW9uIGlzIGJ1aWx0IHdpdGggYVxuICAgICAqICA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI1dhdmVTaGFwZXJOb2RlXCI+XG4gICAgICogIFdlYiBBdWRpbyBXYXZlU2hhcGVyIE5vZGU8L2E+LlxuICAgICAqXG4gICAgICogIEBwcm9wZXJ0eSB7QXVkaW9Ob2RlfSBXYXZlU2hhcGVyTm9kZVxuICAgICAqL1xuXG4gICAgdGhpcy53YXZlU2hhcGVyTm9kZSA9IHRoaXMuYWMuY3JlYXRlV2F2ZVNoYXBlcigpO1xuICAgIHRoaXMuYW1vdW50ID0gY3VydmVBbW91bnQ7XG4gICAgdGhpcy53YXZlU2hhcGVyTm9kZS5jdXJ2ZSA9IG1ha2VEaXN0b3J0aW9uQ3VydmUoY3VydmVBbW91bnQpO1xuICAgIHRoaXMud2F2ZVNoYXBlck5vZGUub3ZlcnNhbXBsZSA9IG92ZXJzYW1wbGU7XG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMud2F2ZVNoYXBlck5vZGUpO1xuICAgIHRoaXMud2F2ZVNoYXBlck5vZGUuY29ubmVjdCh0aGlzLndldCk7XG4gIH07XG5cbiAgcDUuRGlzdG9ydGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVmZmVjdC5wcm90b3R5cGUpO1xuICAvKipcbiAgICogUHJvY2VzcyBhIHNvdW5kIHNvdXJjZSwgb3B0aW9uYWxseSBzcGVjaWZ5IGFtb3VudCBhbmQgb3ZlcnNhbXBsZSB2YWx1ZXMuXG4gICAqXG4gICAqIEBtZXRob2QgcHJvY2Vzc1xuICAgKiBAZm9yIHA1LkRpc3RvcnRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFthbW91bnQ9MC4yNV0gVW5ib3VuZGVkIGRpc3RvcnRpb24gYW1vdW50LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9ybWFsIHZhbHVlcyByYW5nZSBmcm9tIDAtMS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvdmVyc2FtcGxlPSdub25lJ10gJ25vbmUnLCAnMngnLCBvciAnNHgnLlxuICAgKi9cblxuICBwNS5EaXN0b3J0aW9uLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgYW1vdW50LCBvdmVyc2FtcGxlKSB7XG4gICAgc3JjLmNvbm5lY3QodGhpcy5pbnB1dCk7XG4gICAgdGhpcy5zZXQoYW1vdW50LCBvdmVyc2FtcGxlKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldCB0aGUgYW1vdW50IGFuZCBvdmVyc2FtcGxlIG9mIHRoZSB3YXZlc2hhcGVyIGRpc3RvcnRpb24uXG4gICAqXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBmb3IgcDUuRGlzdG9ydGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Ftb3VudD0wLjI1XSBVbmJvdW5kZWQgZGlzdG9ydGlvbiBhbW91bnQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3JtYWwgdmFsdWVzIHJhbmdlIGZyb20gMC0xLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW292ZXJzYW1wbGU9J25vbmUnXSAnbm9uZScsICcyeCcsIG9yICc0eCcuXG4gICAqL1xuXG5cbiAgcDUuRGlzdG9ydGlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGFtb3VudCwgb3ZlcnNhbXBsZSkge1xuICAgIGlmIChhbW91bnQpIHtcbiAgICAgIHZhciBjdXJ2ZUFtb3VudCA9IHA1LnByb3RvdHlwZS5tYXAoYW1vdW50LCAwLjAsIDEuMCwgMCwgMjAwMCk7XG4gICAgICB0aGlzLmFtb3VudCA9IGN1cnZlQW1vdW50O1xuICAgICAgdGhpcy53YXZlU2hhcGVyTm9kZS5jdXJ2ZSA9IG1ha2VEaXN0b3J0aW9uQ3VydmUoY3VydmVBbW91bnQpO1xuICAgIH1cblxuICAgIGlmIChvdmVyc2FtcGxlKSB7XG4gICAgICB0aGlzLndhdmVTaGFwZXJOb2RlLm92ZXJzYW1wbGUgPSBvdmVyc2FtcGxlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm4gdGhlIGRpc3RvcnRpb24gYW1vdW50LCB0eXBpY2FsbHkgYmV0d2VlbiAwLTEuXG4gICAqXG4gICAqICBAbWV0aG9kICBnZXRBbW91bnRcbiAgICogIEBmb3IgcDUuRGlzdG9ydGlvblxuICAgKiAgQHJldHVybiB7TnVtYmVyfSBVbmJvdW5kZWQgZGlzdG9ydGlvbiBhbW91bnQuXG4gICAqICAgICAgICAgICAgICAgICAgIE5vcm1hbCB2YWx1ZXMgcmFuZ2UgZnJvbSAwLTEuXG4gICAqL1xuXG5cbiAgcDUuRGlzdG9ydGlvbi5wcm90b3R5cGUuZ2V0QW1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmFtb3VudDtcbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm4gdGhlIG92ZXJzYW1wbGluZy5cbiAgICpcbiAgICogIEBtZXRob2QgZ2V0T3ZlcnNhbXBsZVxuICAgKiAgQGZvciBwNS5EaXN0b3J0aW9uXG4gICAqICBAcmV0dXJuIHtTdHJpbmd9IE92ZXJzYW1wbGUgY2FuIGVpdGhlciBiZSAnbm9uZScsICcyeCcsIG9yICc0eCcuXG4gICAqL1xuXG5cbiAgcDUuRGlzdG9ydGlvbi5wcm90b3R5cGUuZ2V0T3ZlcnNhbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53YXZlU2hhcGVyTm9kZS5vdmVyc2FtcGxlO1xuICB9O1xuXG4gIHA1LkRpc3RvcnRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMud2F2ZVNoYXBlck5vZGUpIHtcbiAgICAgIHRoaXMud2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy53YXZlU2hhcGVyTm9kZSA9IG51bGw7XG4gICAgfVxuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KVxuIF0pO1xuIiwiaW1wb3J0ICogYXMgcDUgZnJvbSBcInA1XCI7XG5pbXBvcnQgXCJwNS9saWIvYWRkb25zL3A1LnNvdW5kXCI7XG5cbmNvbnN0IHNrZXRjaCA9IChwOiBwNSkgPT4ge1xuICBsZXQgZmZ0OiBwNS5GRlQ7XG4gIGxldCBtaWM6IHA1LkF1ZGlvSW47XG5cbiAgcC5zZXR1cCA9ICgpID0+IHtcbiAgICBsZXQgY2FudmFzID0gcC5jcmVhdGVDYW52YXMoNzEwLCAxMDI0KTtcbiAgICBwLm5vRmlsbCgpO1xuXG4gICAgbWljID0gbmV3IHA1LkF1ZGlvSW4oKTtcbiAgICBtaWMuc3RhcnQoKTtcblxuICAgIGZmdCA9IG5ldyBwNS5GRlQoKTtcbiAgICBmZnQuc2V0SW5wdXQobWljKTtcbiAgfTtcblxuICBwLmRyYXcgPSAoKSA9PiB7XG4gICAgcC5iYWNrZ3JvdW5kKDIwMCk7XG5cbiAgICBsZXQgc3BlY3RydW0gPSBmZnQuYW5hbHl6ZSgpO1xuICAgIHAuYmVnaW5TaGFwZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlY3RydW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHAudmVydGV4KHAubWFwKHNwZWN0cnVtW2ldLCAwLCAyNTUsIDAsIHAud2lkdGgpLCBpKTtcbiAgICB9XG4gICAgcC5lbmRTaGFwZSgpO1xuICB9O1xufTtcblxubmV3IHA1KHNrZXRjaCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHA1OyJdLCJzb3VyY2VSb290IjoiIn0=